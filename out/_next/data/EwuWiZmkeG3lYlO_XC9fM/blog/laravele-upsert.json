{"pageProps":{"blog":{"id":"laravele-upsert","createdAt":"2022-02-17T13:10:20.839Z","updatedAt":"2022-02-17T13:10:54.928Z","publishedAt":"2022-02-16T13:10:20.000Z","revisedAt":"2022-02-17T13:10:44.894Z","title":"【Laravel8】Eloquentのupsertメソッドで複数レコードのupdateとinsertをよしなに行う","body":"<p>業務で、複数のデータについて、<br>・既存のデータがDBにあれば更新<br>・既存のデータがDBになければレコード追加<br>を行いたいという場面がありました。<br><br>そこで<code>update</code>か<code>insert</code>のどちらを行うかよしなに判断して<code>Bulk insert</code>を行ってくれるという、すごく便利な<code>Eloquent</code>の<code>upsert</code>メソッドの存在を知ったので、備忘録を書いておきます。<br></p><h2 id=\"h00bfa7a117\">upsertメソッドとは</h2><p>Laravel8から実装された機能で、<strong>1つのクエリで複数のアップサート</strong>を実行できるメソッドです。<br><br><strong>※アップサート（</strong><strong><code>upsert</code></strong><strong>）とは</strong><br>update + insertのことで、データの更新(update)とデータの挿入(insert)の両方の機能を併せ持つ。<br>対象のレコードがあればそのレコードを更新し、レコードがなければレコードの新規追加をするという場合で使う。<br><a href=\"https://readouble.com/laravel/8.x/ja/eloquent.html#:~:text=%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E5%A0%B4%E5%90%88%E3%80%81-,upsert%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89,-%E3%81%AFcreated_at%E3%81%A8\" target=\"_blank\" rel=\"noopener noreferrer\">Eloquentの準備 8.x Laravel</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://readouble.com</a><br><br>Laravel7までにも<code>updateOrCreate</code>メソッドや<code>firstOrCreate</code>メソッドという一つのレコードをアップサートするメソッドはありましたが、<code>upsert</code>メソッドにより複数レコードを<code>Bulk insert</code>できるようになったようです。<br></p><h2 id=\"h4d849f4362\">使い方</h2><p><code>usersテーブル</code>に複数のデータを<code>upsert</code>する例を書いてみます。<br><br>前提として、DBの<code>usersテーブル</code>には<br><strong>・id：1、name：taro</strong><br><strong>・id：2、name：hanako</strong><br>の2つのレコードが既に存在するとします。<br><br>これに対して以下の通り<code>upsert</code>メソッドを実行します。</p><pre><code>User::upsert([\n  ['id' =&gt; 1, 'name' =&gt; 'taro', 'age' =&gt; 20],      // update\n  ['id' =&gt; 2, 'name' =&gt; 'jiro', 'age' =&gt; 22],      // update\n  ['id' =&gt; null, 'name' =&gt; 'taro', 'age' =&gt; 24]    // insert\n], ['id'], ['name', 'age']);</code></pre><p>結果は、第2引数に渡した<code>id</code>が一致するレコードがあった1つ目と2つ目は<code>update</code>となり、3つ目は<code>insert</code>になります。<br></p><h3 id=\"h997f312e71\">構文</h3><p><code>upsert</code>メソッドは3つの引数を持ちます。<br></p><ul><li>第1引数</li></ul><p><code>update</code>または<code>insert</code>を行いたい値を配列で渡す。<br></p><ul><li>第2引数</li></ul><p>レコードを一意に識別するカラム（プライマリーキーかユニークキー）を配列で渡す。<br></p><ul><li>第3引数（省略可）</li></ul><p><code>update</code>が行われる際に、更新する必要があるカラムを配列で渡す。<br>省略すると全カラム更新される。<br></p><h2 id=\"h86c1eb6dfa\">注意点</h2><p>色んな引数を渡して動作確認をしてみて、気を付けるべきと思ったことを挙げておきます。<br></p><h4 id=\"h93464fb061\">第2引数に指定して意味があるのはプライマリーキーもしくはユニークキーのみ</h4><p>上記の例で第2引数に<code>['id', 'name']</code>を渡したとします。<br><br>すると2つ目のデータ<code>['id' =&gt; 2, 'name' =&gt; 'jiro', 'age' =&gt; 22]</code>については、既存のDBのデータは<code>id：2、name：hanako</code>であり<code>name</code>が一致しないので<code>insert</code>になる…と思いきや、<code>update</code>が実行されました。<br><br>Readoubleにも</p><blockquote>2番目の引数は、関連付けられたテーブル内のレコードを一意に識別するカラムをリストします。</blockquote><p>と書いてあるので、第2引数に渡せるのは一意に識別できるカラムに限るようです。<br></p><h4 id=\"h80576f371d\">第2引数には第1引数に渡しているカラムを渡す</h4><p>先ほどの例で、以下のように第1引数には<code>id</code>を渡さず、第2引数に<code>id</code>を渡したとします。</p><pre><code>User::upsert([\n  ['name' =&gt; 'taro', 'age' =&gt; 20],\n  ['name' =&gt; 'jiro', 'age' =&gt; 22],\n  ['name' =&gt; 'taro', 'age' =&gt; 24] \n], ['id'], ['name', 'age']);</code></pre><p><br>この場合は<code>id</code>が一致するカラムがあったとしても全て<code>insert</code>になりました。<br>なので第2引数に指定するカラムは、必ず第1引数にも渡しておかないといけません。<br></p><h2 id=\"hb95673d4bb\">created_atとupdated_atは自動で設定される</h2><p>モデルのタイムスタンプが有効になっている場合、<code>created_at</code>と<code>updated_at</code>のカラムは自動的に値を入れてくれます。<br><br>第1引数には<code>created_at</code>と<code>updated_at</code>について何も書かなくても、</p><ul><li><code>update</code>&nbsp;：<code>updated_at</code>のみ更新</li><li><code>insert</code>&nbsp;：<code>created_at</code>と<code>updated_at</code>は処理をしたときの時刻</li></ul><p>としてくれます。<br><br>普通の&nbsp;<code>insert</code>メソッドを使って<code>bulk insert</code>する場合は、<code>created_at</code>と<code>updated_at</code>は自動入力されず明示的に含める必要があるので、これは便利だなと思いました。<br></p><h2 id=\"h09ff17952e\">【おまけ】実装例</h2><p>実際のコードの書き方の例も残しておきたいと思います。<br><br>これは<code>upsert</code>だけでなく通常の<code>bulk insert</code>にも言えることですが、DBを更新するための配列を<code>foreach</code>や<code>for</code>文を回して作る際は、以下のように書くとスッキリします。</p><pre><code>// POSTされたデータ配列 $postedAnswers をupsertする場合\n\n$upsertAnswers = [];\n\nforeach ($postedAnswers as $answer) {\n  $upsertAnswers [] = [\n    'id' =&gt; $answer['id'] ?? null,\n    'body' =&gt; $answer['body'],\n    'type' =&gt; $answer['type']\n  ];\n}\n\n// idが一致するレコードがあれば更新、無ければレコード作成する\nAnswer::upsert($upsertSelections, ['id']);</code></pre><p><br>私ははじめ<code>array_push</code>を使って配列に要素を追加していっていましたが、先輩にレビューいただいて上記の書き方を知ったのでこれもメモでした！<br></p><h2 id=\"he45680f0bc\">参考記事</h2><p><a href=\"https://readouble.com/laravel/8.x/ja/eloquent.html#:~:text=%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E5%A0%B4%E5%90%88%E3%80%81-,upsert%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89,-%E3%81%AFcreated_at%E3%81%A8\" target=\"_blank\" rel=\"noopener noreferrer\">Eloquentの準備 8.x Laravel</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://readouble.com</a><br><a href=\"https://qiita.com/uchiii1/items/bb8043719f15e40db35b#eloquent%E3%81%AEupsert%E3%81%A3%E3%81%A6\" target=\"_blank\" rel=\"noopener noreferrer\">【Laravel８】Eloquentのupsert()について - Qiita</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com</a><br><a href=\"https://zenn.dev/y640/articles/9f66d6abfeecf6#%E4%BD%BF%E3%81%84%E6%96%B9\" target=\"_blank\" rel=\"noopener noreferrer\">【Laravel 8】Bulk insertはEloquent::upsertメソッドが便利</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://zenn.dev</a><br></p>","tags":[{"id":"laravel","createdAt":"2022-01-07T13:17:32.553Z","updatedAt":"2022-02-12T02:31:33.697Z","publishedAt":"2022-01-07T13:17:32.553Z","revisedAt":"2022-01-07T13:17:38.700Z","tag":"Laravel"}],"image":"laravel"},"highlightedBody":"<html><head></head><body><p>業務で、複数のデータについて、<br>・既存のデータがDBにあれば更新<br>・既存のデータがDBになければレコード追加<br>を行いたいという場面がありました。<br><br>そこで<code>update</code>か<code>insert</code>のどちらを行うかよしなに判断して<code>Bulk insert</code>を行ってくれるという、すごく便利な<code>Eloquent</code>の<code>upsert</code>メソッドの存在を知ったので、備忘録を書いておきます。<br></p><h2 id=\"h00bfa7a117\">upsertメソッドとは</h2><p>Laravel8から実装された機能で、<strong>1つのクエリで複数のアップサート</strong>を実行できるメソッドです。<br><br><strong>※アップサート（</strong><strong><code>upsert</code></strong><strong>）とは</strong><br>update + insertのことで、データの更新(update)とデータの挿入(insert)の両方の機能を併せ持つ。<br>対象のレコードがあればそのレコードを更新し、レコードがなければレコードの新規追加をするという場合で使う。<br><a href=\"https://readouble.com/laravel/8.x/ja/eloquent.html#:~:text=%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E5%A0%B4%E5%90%88%E3%80%81-,upsert%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89,-%E3%81%AFcreated_at%E3%81%A8\" target=\"_blank\" rel=\"noopener noreferrer\">Eloquentの準備 8.x Laravel</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://readouble.com</a><br><br>Laravel7までにも<code>updateOrCreate</code>メソッドや<code>firstOrCreate</code>メソッドという一つのレコードをアップサートするメソッドはありましたが、<code>upsert</code>メソッドにより複数レコードを<code>Bulk insert</code>できるようになったようです。<br></p><h2 id=\"h4d849f4362\">使い方</h2><p><code>usersテーブル</code>に複数のデータを<code>upsert</code>する例を書いてみます。<br><br>前提として、DBの<code>usersテーブル</code>には<br><strong>・id：1、name：taro</strong><br><strong>・id：2、name：hanako</strong><br>の2つのレコードが既に存在するとします。<br><br>これに対して以下の通り<code>upsert</code>メソッドを実行します。</p><pre><code class=\"hljs\">User::upsert([\n  [<span class=\"hljs-string\">'id'</span> =&gt; <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'name'</span> =&gt; <span class=\"hljs-string\">'taro'</span>, <span class=\"hljs-string\">'age'</span> =&gt; <span class=\"hljs-number\">20</span>],      <span class=\"hljs-comment\">// update</span>\n  [<span class=\"hljs-string\">'id'</span> =&gt; <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'name'</span> =&gt; <span class=\"hljs-string\">'jiro'</span>, <span class=\"hljs-string\">'age'</span> =&gt; <span class=\"hljs-number\">22</span>],      <span class=\"hljs-comment\">// update</span>\n  [<span class=\"hljs-string\">'id'</span> =&gt; <span class=\"hljs-keyword\">null</span>, <span class=\"hljs-string\">'name'</span> =&gt; <span class=\"hljs-string\">'taro'</span>, <span class=\"hljs-string\">'age'</span> =&gt; <span class=\"hljs-number\">24</span>]    <span class=\"hljs-comment\">// insert</span>\n], [<span class=\"hljs-string\">'id'</span>], [<span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'age'</span>]);</code></pre><p>結果は、第2引数に渡した<code>id</code>が一致するレコードがあった1つ目と2つ目は<code>update</code>となり、3つ目は<code>insert</code>になります。<br></p><h3 id=\"h997f312e71\">構文</h3><p><code>upsert</code>メソッドは3つの引数を持ちます。<br></p><ul><li>第1引数</li></ul><p><code>update</code>または<code>insert</code>を行いたい値を配列で渡す。<br></p><ul><li>第2引数</li></ul><p>レコードを一意に識別するカラム（プライマリーキーかユニークキー）を配列で渡す。<br></p><ul><li>第3引数（省略可）</li></ul><p><code>update</code>が行われる際に、更新する必要があるカラムを配列で渡す。<br>省略すると全カラム更新される。<br></p><h2 id=\"h86c1eb6dfa\">注意点</h2><p>色んな引数を渡して動作確認をしてみて、気を付けるべきと思ったことを挙げておきます。<br></p><h4 id=\"h93464fb061\">第2引数に指定して意味があるのはプライマリーキーもしくはユニークキーのみ</h4><p>上記の例で第2引数に<code>['id', 'name']</code>を渡したとします。<br><br>すると2つ目のデータ<code>['id' =&gt; 2, 'name' =&gt; 'jiro', 'age' =&gt; 22]</code>については、既存のDBのデータは<code>id：2、name：hanako</code>であり<code>name</code>が一致しないので<code>insert</code>になる…と思いきや、<code>update</code>が実行されました。<br><br>Readoubleにも</p><blockquote>2番目の引数は、関連付けられたテーブル内のレコードを一意に識別するカラムをリストします。</blockquote><p>と書いてあるので、第2引数に渡せるのは一意に識別できるカラムに限るようです。<br></p><h4 id=\"h80576f371d\">第2引数には第1引数に渡しているカラムを渡す</h4><p>先ほどの例で、以下のように第1引数には<code>id</code>を渡さず、第2引数に<code>id</code>を渡したとします。</p><pre><code class=\"hljs\">User::upsert([\n  [<span class=\"hljs-string\">'name'</span> =&gt; <span class=\"hljs-string\">'taro'</span>, <span class=\"hljs-string\">'age'</span> =&gt; <span class=\"hljs-number\">20</span>],\n  [<span class=\"hljs-string\">'name'</span> =&gt; <span class=\"hljs-string\">'jiro'</span>, <span class=\"hljs-string\">'age'</span> =&gt; <span class=\"hljs-number\">22</span>],\n  [<span class=\"hljs-string\">'name'</span> =&gt; <span class=\"hljs-string\">'taro'</span>, <span class=\"hljs-string\">'age'</span> =&gt; <span class=\"hljs-number\">24</span>] \n], [<span class=\"hljs-string\">'id'</span>], [<span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'age'</span>]);</code></pre><p><br>この場合は<code>id</code>が一致するカラムがあったとしても全て<code>insert</code>になりました。<br>なので第2引数に指定するカラムは、必ず第1引数にも渡しておかないといけません。<br></p><h2 id=\"hb95673d4bb\">created_atとupdated_atは自動で設定される</h2><p>モデルのタイムスタンプが有効になっている場合、<code>created_at</code>と<code>updated_at</code>のカラムは自動的に値を入れてくれます。<br><br>第1引数には<code>created_at</code>と<code>updated_at</code>について何も書かなくても、</p><ul><li><code>update</code>&nbsp;：<code>updated_at</code>のみ更新</li><li><code>insert</code>&nbsp;：<code>created_at</code>と<code>updated_at</code>は処理をしたときの時刻</li></ul><p>としてくれます。<br><br>普通の&nbsp;<code>insert</code>メソッドを使って<code>bulk insert</code>する場合は、<code>created_at</code>と<code>updated_at</code>は自動入力されず明示的に含める必要があるので、これは便利だなと思いました。<br></p><h2 id=\"h09ff17952e\">【おまけ】実装例</h2><p>実際のコードの書き方の例も残しておきたいと思います。<br><br>これは<code>upsert</code>だけでなく通常の<code>bulk insert</code>にも言えることですが、DBを更新するための配列を<code>foreach</code>や<code>for</code>文を回して作る際は、以下のように書くとスッキリします。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// POSTされたデータ配列 $postedAnswers をupsertする場合</span>\n\n<span class=\"hljs-variable\">$upsertAnswers</span> = [];\n\n<span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-variable\">$postedAnswers</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-variable\">$answer</span>) {\n  <span class=\"hljs-variable\">$upsertAnswers</span> [] = [\n    <span class=\"hljs-string\">'id'</span> =&gt; <span class=\"hljs-variable\">$answer</span>[<span class=\"hljs-string\">'id'</span>] ?? <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-string\">'body'</span> =&gt; <span class=\"hljs-variable\">$answer</span>[<span class=\"hljs-string\">'body'</span>],\n    <span class=\"hljs-string\">'type'</span> =&gt; <span class=\"hljs-variable\">$answer</span>[<span class=\"hljs-string\">'type'</span>]\n  ];\n}\n\n<span class=\"hljs-comment\">// idが一致するレコードがあれば更新、無ければレコード作成する</span>\n<span class=\"hljs-title class_\">Answer</span>::<span class=\"hljs-title function_ invoke__\">upsert</span>(<span class=\"hljs-variable\">$upsertSelections</span>, [<span class=\"hljs-string\">'id'</span>]);</code></pre><p><br>私ははじめ<code>array_push</code>を使って配列に要素を追加していっていましたが、先輩にレビューいただいて上記の書き方を知ったのでこれもメモでした！<br></p><h2 id=\"he45680f0bc\">参考記事</h2><p><a href=\"https://readouble.com/laravel/8.x/ja/eloquent.html#:~:text=%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E5%A0%B4%E5%90%88%E3%80%81-,upsert%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89,-%E3%81%AFcreated_at%E3%81%A8\" target=\"_blank\" rel=\"noopener noreferrer\">Eloquentの準備 8.x Laravel</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://readouble.com</a><br><a href=\"https://qiita.com/uchiii1/items/bb8043719f15e40db35b#eloquent%E3%81%AEupsert%E3%81%A3%E3%81%A6\" target=\"_blank\" rel=\"noopener noreferrer\">【Laravel８】Eloquentのupsert()について - Qiita</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com</a><br><a href=\"https://zenn.dev/y640/articles/9f66d6abfeecf6#%E4%BD%BF%E3%81%84%E6%96%B9\" target=\"_blank\" rel=\"noopener noreferrer\">【Laravel 8】Bulk insertはEloquent::upsertメソッドが便利</a><a href=\"unsafe:[object Object]\" target=\"_blank\" rel=\"noopener noreferrer\">https://zenn.dev</a><br></p></body></html>"},"__N_SSG":true}
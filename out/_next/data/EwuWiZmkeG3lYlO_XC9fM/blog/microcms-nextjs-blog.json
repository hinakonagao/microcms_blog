{"pageProps":{"blog":{"id":"microcms-nextjs-blog","createdAt":"2022-02-17T12:46:35.174Z","updatedAt":"2022-03-02T23:51:43.327Z","publishedAt":"2022-02-26T23:51:43.000Z","revisedAt":"2022-03-02T23:51:43.327Z","title":"microCMS × Next.js（TypeScript）で個人ブログを作る","body":"<h2 id=\"h9707d3a59a\">概要</h2><p><code>microCMS</code>、<code>Next.js（TypeScript）</code>を使ってブログサイトを作成した手順と、追加で実装した機能について、またその過程で学んだことの備忘録記事です。<br><br>基本的には公式のチュートリアル通りに進めていますが、TypeScriptの型付けや記事内のコードブロックのハイライトなど詰まった箇所もあったので、まとめておきたいと思います。<br></p><ul><li>デプロイURL</li></ul><p><a href=\"https://microcms-blog-hinakonagao.vercel.app/\" target=\"_blank\" rel=\"noopener noreferrer\">https://microcms-blog-hinakonagao.vercel.app</a><br></p><ul><li>GitHub</li></ul><p><a href=\"https://github.com/hinakonagao/microcms_blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/hinakonagao/microcms_blog</a><br><br>※この記事ではページのスタイリングは解説しません。<br>MaterialUIを主に使用してスタイリングを行っているので、詳しいコードはGitHubをご覧いただければと思います。<br></p><h3 id=\"h48162eced8\">使用技術</h3><ul><li>Next.js　12.0.10</li><li>React　17.0.2</li><li>TypeScript　4.5.5</li><li>ESLint　8.8.0</li><li>prettier　2.5.1</li></ul><p><br></p><h2 id=\"hc953739b3f\">全体の流れ</h2><p>１．microCMSの準備（アカウント作成・記事コンテンツのAPI作成）<br>２．Next.jsのプロジェクト作成<br>３．APIリクエストのための環境変数の設定<br>４．公式のSDK「microcms-js-sdk」の導入<br>５．記事一覧画面の作成<br>６．記事詳細画面の作成<br>７．コードブロックのシンタックスハイライトの実装<br>８．【おまけ】タグでの絞り込み機能の実装<br>９．【おまけ】ページネーション機能の実装<br><br>というような流れで説明していきます。<br></p><h2 id=\"hd1205c1797\">1. microCMSの準備</h2><p>まずはmicroCMSのアカウントを作成し、APIを作成します。<br><br>手順は公式のチュートリアルに詳しく書かれているので、ここでの説明は割愛します。<br><a style=\"color:#4aac00\" href=\"https://blog.microcms.io/microcms-next-jamstack-blog/#:%7E:text=%E3%81%8C%E7%AB%8B%E3%81%A1%E4%B8%8A%E3%81%8C%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82-,2.%20microCMS%E3%81%AE%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B,-%E6%AC%A1%E3%81%AB%E3%80%81microCMS%E3%81%A7\" target=\"_blank\" rel=\"noopener noreferrer\">microCMS + Next.jsでJamstackブログを作ってみよう　2. microCMSの用意する</a><br><br>私は&nbsp;<code>blog</code>&nbsp;と&nbsp;<code>tag</code>&nbsp;の2つのAPIエンドポイントを作成しました。<br></p><h3 id=\"hebabef9705\">blog</h3><p>ブログコンテンツを登録しておくリスト形式の API です。</p><ul><li>title：記事タイトル</li><li>body：記事本文</li><li>tags：タグ（別のエンドポイント&nbsp;<code>/tag</code>&nbsp;に登録したタグを複数参照できるように設定）</li><li>image：表示する画像名（プロジェクトディレクトリに保存した画像の中から、ブラウザに表示する画像を指定するために使用）</li></ul><p><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/577556386f954864b763ec82bdea4d3c/blog.jpg\" alt=\"\"><br></p><h3 id=\"h1d9b92c0c9\">tag</h3><p>ブログ記事に紐づけるタグを登録しておくリスト形式の API です。<br><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/24cd3d349eb74b35a9ee5ca8f901543a/tag.jpg\" alt=\"\"><br></p><h2 id=\"hce660a84c7\">2. Next.jsプロジェクトを作成する</h2><p>下記のコマンドを実行してNext.jsのプロジェクトを作成し、続けて開発サーバーを立ち上げます。</p><pre><code>$ yarn create next-app --typescript\n// プロジェクト名の入力を求められるので入力する\n\n$ cd ./microcms_blog/\n\n$ yarn dev</code></pre><p><br>次に<code>src</code>ディレクトリを作成して、<code>pages</code>ディレクトリと<code>styles</code>ディレクトリを<code>src</code>ディレクトリの配下に移動させます。</p><pre><code>$ mkdir src &amp;&amp; mv pages src &amp;&amp; mv styles src</code></pre><p><br>さらに、モジュールのインポートを絶対パスで指定できるよう、ベースURLを&nbsp;<code>src</code>&nbsp;ディレクトリに設定します。</p><pre><code>// tsconfig.json\n{\n  \"compilerOptions\": {\n    // 追加\n    \"baseUrl\": \"src\"\n  }\n}</code></pre><p>ベースURLの設定についてはこちらの記事を参考にさせていただきました。<br><a href=\"https://fwywd.com/tech/next-base-url\" target=\"_blank\" rel=\"noopener noreferrer\">【Next.js】特定のディレクトリを基準にし、絶対パスでモジュールをインポートする方法 | fwywd（フュード）powered by キ...</a><br></p><h2 id=\"ha56333b74a\">ESLint / Prettier</h2><p>Next.js のバージョン11 からは、デフォルトでESLintが搭載されています。<br>ESLintに関するインストール済のパッケージは以下の2つです。</p><pre><code>// package.json\n{\n  ...\n  \"devDependencies\": {\n    \"eslint\": \"8.8.0\",    // 構文解析のエンジン\n    \"eslint-config-next\": \"12.0.10\",    // ESLintのルール\n  }\n  ...\n}</code></pre><p><br>Next.js の新規プロジェクト作成時に生成された&nbsp;<code>.eslintrc</code>&nbsp;は ESLint の設定ファイルを意味しており、<strong>デフォルトで&nbsp;</strong><strong><code>eslint-config-next</code></strong><strong>&nbsp;の設定が適用</strong>されています。（ルールの詳細は後述）</p><pre><code>// .eslintrc.json\n\n{\n  \"extends\": \"next/core-web-vitals\",\n}\n\n</code></pre><p><br>少しだけESLintの設定を加えます。</p><pre><code>// .eslintrc.json\n\n{\n  \"extends\": \"next/core-web-vitals\",\n  // 以下のルールを追記\n  \"rules\": {\n    \"react/display-name\": \"off\",\n    \"react-hooks/exhaustive-deps\": \"off\",\n    \"@next/next/no-sync-scripts\": \"off\"\n  }\n}</code></pre><p><br>Prettier は含まれていないため、インストールしておきます。</p><pre><code>$ yarn -DE add prettier eslint-config-prettier</code></pre><h2 id=\"h5095390624\"><br>3. 環境変数の設定</h2><p>microCMSのAPIへアクセスする際は、サービスドメインを指定し、リクエストにそのサービスドメインのAPIキーを含める事でデータを取得することができます。<br><br>※microCMSでのAPIキーの作成方法は公式ページを参照ください。<br><a style=\"color:#4aac00\" href=\"https://document.microcms.io/content-api/x-microcms-api-key\" target=\"_blank\" rel=\"noopener noreferrer\">APIキー（X-MICROCMS-API-KEY）</a><br><br>まずは環境変数を管理するファイルを作成します。<br>※&nbsp;<code>.local</code>をつけるとローカル環境で使うことができ、&nbsp;<code>.development</code>をつけると開発環境で使えます。</p><pre><code>$ touch .env.development.local</code></pre><p><br><code>.env.development.local</code>ファイルを作成したら、<code>サービスドメイン</code>とmicroCMSの<code>APIキー</code>を書き込みます。<br>※サービスドメインは、例えば自分のmicroCMSページのURLが&nbsp;<code>https://aiueo.microcms.io/</code>&nbsp;であれば&nbsp;<code>aiueo</code>&nbsp;の部分になります。</p><pre><code>SERVICE_DOMAIN=xxxxxxxxxxx\nAPI_KEY=xxxxxxxxxxxx</code></pre><p><br><code>env</code>&nbsp;ファイルに書いた値は、以下のようにしてプロジェクト内で参照することができます。</p><pre><code>process.env.API_KEY</code></pre><h2 id=\"h84f24c70f8\"><br>4.microcms-js-sdkの準備</h2><p>APIリクエストには公式が提供している<code>microcms-js-sdk</code>を使います。<br><br>まずは<code>microcms-js-sdk</code>をインストールします。</p><pre><code>$ yarn add microcms-js-sdk</code></pre><p><br><code>libs/client.ts</code>&nbsp;を作成してSDKの初期化を行います。</p><pre><code>$ mkdir src/libs\n$ touch ./src/libs/client.ts</code></pre><p><br><code>serviceDomain</code>&nbsp;と&nbsp;<code>apiKey</code>&nbsp;の値は&nbsp;<code>env</code>&nbsp;ファイルを参照します。</p><pre><code>// libs/client.ts\n\nimport { createClient } from \"microcms-js-sdk\";\n\nexport const client = createClient({\n  serviceDomain: process.env.SERVICE_DOMAIN || \"\",\n  apiKey: process.env.API_KEY || \"\",\n});</code></pre><p><br>※<code>serviceDomain</code>&nbsp;と&nbsp;<code>apiKey</code>&nbsp;は&nbsp;<code>string</code>型、.envファイルから参照する環境変数は&nbsp;<code>string | undefined</code>型なので、もし以下のように&nbsp;<code>|| \"\"</code>&nbsp;の部分を書かないとエラーが出ます。</p><pre><code>serviceDomain: process.env.SERVICE_DOMAIN\n// 型 'string | undefined' を型 'string' に割り当てることはできません。型 'undefined' を型 'string' に割り当てることはできません。</code></pre><h2 id=\"h4e79de37a7\"><br>5. microCMSから記事データを取得する（一覧画面）</h2><h3 id=\"hde4a1d43ba\">型の事前準備</h3><p>microCMSから取得するブログ記事とタグのデータ型を定義しておきます。<br><br>型定義ファイルを別途作成します。</p><pre><code>$ mkdir src/types\n$ touch ./src/types/blog.ts</code></pre><p><br>作成したファイルに型を定義します。<br>今回私が作成したAPIだと以下の通りになります。</p><pre><code>// src/types/blog.ts\n\nexport type Blog = {\n  id: string;\n  body: string;\n  title: string;\n  tags: Tag[];\n  image: string;\n  createdAt: string;\n  updatedAt: string;\n  publishedAt: string;\n  revisedAt: string;\n};\n\nexport type Tag = {\n  id: string;\n  tag: string;\n  createdAt: string;\n  updatedAt: string;\n  publishedAt: string;\n  revisedAt: string;\n};</code></pre><h3 id=\"hbc42ef09fb\"><br>APIリクエストを行う</h3><p><code>getStaticProps</code>を使ってmicroCMSのAPIを叩き、データを取得します。<br><code>pages/index.tsx</code>&nbsp;に以下のように書きます。</p><pre><code>// pages/index.js\n\n\nimport Link from \"next/link\";\nimport type { InferGetStaticPropsType, NextPage } from \"next\";\nimport { client } from \"libs/client\";    // srcから見た絶対パスで指定\nimport type { Blog, Tag } from \"types/blog\";    // srcから見た絶対パスで指定\n\n// microCMSへAPIリクエスト\nexport const getStaticProps = async () =&gt; {\n  const blog = await client.get({ endpoint: \"blog\" });\n  const tag = await client.get({ endpoint: \"tag\" });\n\n  return {\n    props: {\n      blogs: blog.contents,\n      tags: tag.contents,\n    },\n  };\n};\n\n// Props（blogsとtags）の型\ntype Props = {\n  blogs: Blog[];\n  tags: Tag[];\n};\n\nconst Home: NextPage&lt;InferGetStaticPropsType&lt;typeof getStaticProps&gt;&gt; = ({\n  blogs,\n  tags,\n}: Props) =&gt; {\n  console.log(blogs);\n  console.log(tags);\n　// ... 以下省略</code></pre><p><br>ここで&nbsp;<code>http://localhost:3000</code>&nbsp;にアクセスすると、コンソールにAPIから取得したデータが表示されるはずです。<br><br>私の作成したAPIだと、以下の画像のようなデータが取れています。</p><h3 id=\"hf4a22cee96\">blogs</h3><p><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/21ce7cb8666749859e4e9a8a1a57939a/blogs.jpg\" alt=\"\"><br></p><h3 id=\"h0502f3a90c\">tags</h3><p><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/3634ac49f1c749069024d8d2e57474f1/tags.jpg\" alt=\"\"><br><br>ではこのデータを画面に表示します。<br><br>※ディレクトリ構成は以下のようにします。</p><ul><li>pages/index.js&nbsp;→ 記事一覧画面</li><li>pages/blog/[id].ts → 記事詳細画面</li></ul><p><br>一覧画面に記事タイトルをリスト形式で表示し、記事詳細画面へのリンクをつけます。</p><pre><code>// pages/index.tsx\n\nconst Home: NextPage&lt;InferGetStaticPropsType&lt;typeof getStaticProps&gt;&gt; = ({\n  blogs,\n  tags,\n}: Props) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;ul&gt;\n        {blogs.map((blog) =&gt; (\n          &lt;li key={blog.id}&gt;\n            &lt;Link href={`/blog/${blog.id}`}&gt;\n              &lt;a&gt;{blog.title}&lt;/a&gt;\n            &lt;/Link&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  )\n}</code></pre><p><br>これで&nbsp;<code>http://localhost:3000</code>&nbsp;にアクセスすると記事タイトル一覧が表示され、タイトルをクリックすると&nbsp;<code>http://localhost:3000/blog/[microCMSで設定したコンテンツID]</code>&nbsp;のURLへ遷移するはずです。<br><br>次にこの遷移先のページを作ります。<br></p><h2 id=\"h85b588f038\">6. 記事詳細画面を作成する</h2><p>一覧画面でブログ記事の詳細画面を作っていきます。<br><br>上記のリンク先に指定した通り、&nbsp;<code>pages/blog/[id].ts</code>に詳細画面を作ります。<br>まずはファイルを作成します。</p><pre><code>$ mkdir src/pages/blog\n$ touch ./src/pages/blog/[id].tsx</code></pre><p><br>作成したファイルを、以下のように編集します。</p><pre><code>// pages/blog/[id].tsx\n\nimport {\n  GetStaticPaths,\n  GetStaticProps,\n  InferGetStaticPropsType,\n  NextPage,\n} from \"next\";\nimport { client } from \"libs/client\";\nimport type { Blog } from \"types/blog\";\n\n// APIリクエストを行うパスを指定\nexport const getStaticPaths: GetStaticPaths&lt;Params&gt; = async () =&gt; {\n  const data = await client.get({ endpoint: \"blog\" });\n\n  const paths = data.contents.map((content) =&gt; `/blog/${content.id}`);\n  return { paths, fallback: false };\n};\n\n// microCMSへAPIリクエスト\nexport const getStaticProps: GetStaticProps&lt;Props, Params&gt; = async (\n  const id = context.params?.id;\n  const data = await client.get({ endpoint: \"blog\", contentId: id });\n\n  return {\n    props: {\n      blog: data,\n    },\n  };\n};\n\n// // Props（blog）の型\ntype Props = {\n  blog: Blog;\n};\n\nconst BlogId: NextPage&lt;InferGetStaticPropsType&lt;typeof getStaticProps&gt;&gt; = ({\n  blog,\n}: Props) =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;{blog.title}&lt;/h1&gt;\n      &lt;p&gt;{blog.publishedAt}&lt;/p&gt;\n            {blog.tags.map((tag) =&gt; (\n        &lt;li key={tag.id}&gt;\n          #{tag.tag}\n        &lt;/li&gt;\n      ))}\n      &lt;div\n        dangerouslySetInnerHTML={{\n          __html: `${blog.body}`,\n        }}\n      /&gt;\n    &lt;/main&gt;\n  );\n}</code></pre><h3 id=\"h8a50fc5ec1\"><br>ポイント解説</h3><ul><li><code>fallback: false</code>&nbsp;の設定</li></ul><p><code>getStaticPaths</code>&nbsp;で&nbsp;<code>return { fallback: false };</code>&nbsp;と書いています。<br><br>これにより、&nbsp;<code>http://localhost:3000/blog/[存在しないコンテンツID]</code>&nbsp;のURLにアクセスすると404ページへ遷移するようになります。<br>※&nbsp;<code>fallback: true</code>&nbsp;にして存在しないURLにアクセスした場合はエラー画面が出てしまいます。<br></p><ul><li><code>dangerouslySetInnerHTML</code></li></ul><p>以下の通り、記事本文は&nbsp;<code>dangerouslySetInnerHTML</code>&nbsp;を通して表示しています。<br></p><pre><code>&lt;div\n  dangerouslySetInnerHTML={{\n    __html: `${blog.body}`,\n  }}\n/&gt;</code></pre><p><br>APIから返される記事本文は文字列形式（HTMLタグも文字列として取得される）なので、これをHTMLとして描画するために<code>dangerouslySetInnerHTML</code>&nbsp;を使っています。<br></p><h2 id=\"h7941af99cd\">7. コードブロックのハイライトを行う</h2><p>microCMSのリッチエディタでソースコードとして記述した部分は、</p><pre><code>&lt;pre&gt;\n  &lt;code&gt;\n    // コード\n  &lt;/code&gt;\n&lt;/pre&gt;</code></pre><p>という形式で取得されます。<br><br>このままdangerouslySetInnerHTMLを通すだけでは、何もハイライトされていないコードが表示されるので、ライブラリを使って装飾していきます。<br><br>microCMSの公式で紹介されている、<a style=\"color:#4aac00\" href=\"https://www.npmjs.com/package/cheerio\" target=\"_blank\" rel=\"noopener noreferrer\">cheerio</a>と<a style=\"color:#4aac00\" href=\"https://www.npmjs.com/package/highlight.js\" target=\"_blank\" rel=\"noopener noreferrer\">highlight.js</a>というライブラリを使ってサーバーサイドでハイライトを行いました。<br><a href=\"https://blog.microcms.io/syntax-highlighting-on-server-side/\" target=\"_blank\" rel=\"noopener noreferrer\">サーバサイドでシンタックスハイライトを行う</a><br><br>まずはライブラリをインストールします。</p><pre><code>$ yarn add highlight.js cheerio\n$ yarn add --dev @types/highlightjs @types/cheerio</code></pre><p><br>次にブログ記事を生成する際の&nbsp;<code>getStaticProps</code>&nbsp;内の記述を修正します。<br>※ライブラリについての説明は上記のmicroCMSの記事などを参照ください。</p><pre><code>// pages/blog/[id].tsx\n\n// importを追記\nimport cheerio from \"cheerio\";\nimport hljs from \"highlight.js\";\nimport \"highlight.js/styles/hybrid.css\";\n\n// 中略\n\nexport const getStaticProps: GetStaticProps&lt;Props, Params&gt; = async (\n  context\n) =&gt; {\n  const id = context.params?.id;\n  const blog = await client.get({ endpoint: \"blog\", contentId: id });\n  // 以下の部分を追記\n  const $ = cheerio.load(blog.body);\n  $(\"pre code\").each((_, elm) =&gt; {\n    const result = hljs.highlightAuto($(elm).text());\n    $(elm).html(result.value);\n    $(elm).addClass(\"hljs\");\n  });\n\n  return {\n    props: {\n      blog,\n      highlightedBody: $.html(),\n    },\n  };\n};</code></pre><p>これでサーバーサード側でシンタックスハイライト済の記事データを取得することができます。<br><br>※実装においては以下の記事も参考にさせていただきました。<br><a href=\"https://www.blogchin.net/blogs/p9f3s1x5k5yb/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.JS+microCMSで作成したブログに、ソースコードのシンタックスハイライトをつけてみる</a><br><a href=\"https://qiita.com/cawauchi/items/ff6489b17800c5676908\" target=\"_blank\" rel=\"noopener noreferrer\">next.js+microcmsでシンタックスハイライトの導入 - Qiita</a></p><h2 id=\"h5a51a8e35e\"><br>8. 【おまけ】タグでの絞り込み機能</h2><p>先述の通り、今回は&nbsp;<code>blog</code>&nbsp;と&nbsp;<code>tag</code>&nbsp;の2つのAPIを作成し、ブログ記事は複数の&nbsp;<code>tag</code>&nbsp;を持てるようにしました。<br><br>そして</p><ul><li>記事一覧画面で各記事が持つタグを表示</li><li>APIから取得した&nbsp;<code>tag</code>&nbsp;の一覧をサイドバーに表示（タグを選んで記事を絞り込む）</li></ul><p>を出来るようにしました。<br><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/0ef6284906254e6580e558fae4082554/tag_serch.jpg\" alt=\"\"><br></p><h3 id=\"h3ab24f6f50\">メリット</h3><p><code>tag</code>&nbsp;のAPIエンドポイントを別途作成する構成にしたことで、以下のようなメリットがあります。</p><ul><li>サイドバーに設置した&nbsp;<code>tag</code>&nbsp;一覧の表示順の並べ替えや修正を、コードをいじらずmicroCMSの管理画面で行える。</li><li><code>tag</code>&nbsp;名を修正したい時に、記事のタグを一つひとつ修正しなくともAPIの&nbsp;<code>tag</code>&nbsp;を修正すれば一括して変更できる。</li></ul><h3 id=\"h50d6571ee1\"><br>実装方法（記事一覧の表示について）</h3><p>まずは、&nbsp;<code>getStaticProps</code>&nbsp;から受け取った記事をそのまま全て表示するのではなく、画面に表示する記事だけを格納する&nbsp;<code>state</code>&nbsp;を別途作成します。</p><pre><code>const [showBlogs, setShowBlogs] = useState(blogs)\n// 初期値にgetStaticPropsから受け取ったブログ記事データを入れる</code></pre><p><br>そして画面には&nbsp;<code>showBlogs</code>&nbsp;の中身を&nbsp;<code>map</code>&nbsp;で回して一覧表示します。<br>※絞り込みによって&nbsp;<code>showBlogs</code>&nbsp;に記事が入っていなかった場合のための条件付きレンダリングも記述しておきます。</p><pre><code>{!showBlogs.length &amp;&amp; &lt;p&gt;There are no posts...&lt;/p&gt;}\n{showBlogs.map((blog) =&gt; (\n    // 記事を表示</code></pre><p><br><br><strong>※注</strong><br><strong>このブログサイトはMaterialUIを使ってスタイリングを行っており、ここからは実際の実装通り、通常のHTMLタグではなくMaterialUIのタグで表記させていただきます。</strong><br><strong>（MaterialUIのタグ名を見ればどんな役割の要素なのか想像がつくと思うので、MaterialUIに触れたことが無い方も何となく読み取っていただけるかなと思います。）</strong><br><br><br>記事の一覧表示の中で、この記事が持つ&nbsp;<code>tag</code>&nbsp;も&nbsp;<code>map</code>&nbsp;で回して表示します。</p><pre><code>{showBlogs.map((blog) =&gt; (\n\n    // 中略\n\n    // 持っているtagを全て表示\n    {blog.tags.map((tag) =&gt; (\n      &lt;Typography key={tag.id}&gt;\n        #{tag.tag}\n      &lt;/Typography&gt;\n    ))}</code></pre><h3 id=\"h79fb2c15aa\"><br>実装方法（タグによる絞り込みについて）</h3><p><code>tag</code>&nbsp;のAPIエンドポイントから受け取るデータは、以下の<code>tag</code>型の配列でした。</p><pre><code>export type Tag = {\n  id: string;\n  tag: string;\n  createdAt: string;\n  updatedAt: string;\n  publishedAt: string;\n  revisedAt: string;\n};</code></pre><p><br>なのでまずはこのデータから、tag名だけを抜き出して配列に格納します。</p><pre><code>// getStaticPropsで取得したtagsからtag名のみ抜き出す\nconst tagList = tags.map((tag) =&gt; tag.tag);</code></pre><p><br>作成した&nbsp;<code>tagList</code>&nbsp;を使って、サイドバーにタグ一覧を表示します。</p><pre><code>&lt;List&gt;\n  &lt;Typography&gt;\n    # Tags\n  &lt;/Typography&gt;\n\n  &lt;ListItemButton onClick={() =&gt; selectTag(\"all\")}&gt;\n    &lt;ListItemText primary=\"All\"/&gt;   // primaryに指定した文字列が表示される\n  &lt;/ListItemButton&gt;\n\n  {tagList.map((tag) =&gt; (\n    &lt;ListItemButton key={tag} onClick={() =&gt; selectTag(tag)}&gt;\n      &lt;ListItemText primary={tag}/&gt;   // primaryに指定した文字列が表示される\n    &lt;/ListItemButton&gt;\n  ))}\n&lt;/List&gt;</code></pre><p><br><code>onClick</code>&nbsp;に指定した&nbsp;<code>selectTag()</code>&nbsp;メソッドを実装します。</p><pre><code>// タグ絞り込み\nconst selectTag = (tag: string) =&gt; {\n  if (tag === \"all\") {\n    setShowBlogs(blogs);\n  } else {\n    const selectedBlogs = blogs.filter((blog) =&gt; {\n      const haveTags = blog.tags.map((tag) =&gt; tag.tag);\n      return haveTags.includes(tag);\n    });\n    setShowBlogs(selectedBlogs);\n  }\n\n  // 画面最上部へスクロールさせる\n  window.scrollTo({\n    top: 0,\n    behavior: \"smooth\",\n  });\n};</code></pre><p><br>検索のロジックについては以前別の記事に書いたので、詳しくはこちらをご覧ください。<br><a style=\"color:#4aac00\" href=\"https://qiita.com/hinako_n/items/a0745afe0631578c698e\" target=\"_blank\" rel=\"noopener noreferrer\">Reactでリアルタイムの検索機能を実装する - Qiita</a><br><br>以上で「All」を選べば全記事が表示され、タグを選べばそのタグを持つ記事のみが表示されるようになりました。<br></p><h2 id=\"h88cdec125d\"> 9.【おまけ】ページネーション機能の実装</h2><p><code>react-paginate</code>というライブラリを使って、ページネーション機能を実装しました。  <br>ライブラリ： <a href=\"https://www.npmjs.com/package/react-paginate \" target=\"_blank\" rel=\"noopener noreferrer\">https://www.npmjs.com/package/react-paginate </a><br><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/9a2cb163f00a4910b6ebf063d87811ab/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3.jpg\" alt=\"\"><br><br>ライブラリについての詳しい説明では割愛し、ここでは実装したコードだけ載せさせていただきます。<br>使い方は以下の記事を参考にさせていただきました。<br><br><a href=\"https://de-milestones.com/react_pagination/\" target=\"_blank\" rel=\"noopener noreferrer\">https://de-milestones.com/react_pagination/</a><br><br><a href=\"https://tech.stmn.co.jp/entry/2020/10/28/141406\" target=\"_blank\" rel=\"noopener noreferrer\">https://tech.stmn.co.jp/entry/2020/10/28/141406</a><br></p><h3 id=\"h2661198b93\">実装手順</h3><p>まずはライブラリをインストールします。<br></p><pre><code>$ yarn add react-paginate</code></pre><p><br>記事一覧画面を編集していきます。<br><br>ページネーションの制御に使う <code>state</code>と、ページネーションをクリックした時に実行するメソッドを定義します。  <br><br>pages/index.tsx</p><pre><code>import ReactPaginate from \"react-paginate\";\n\n\n// 中略\n\n&nbsp;const [offset, setOffset] = useState(0);&nbsp;&nbsp;// 何番目の記事から表示するか\n&nbsp;const perPage = 6;&nbsp;&nbsp;// 1ページあたりに表示する記事数\n\n&nbsp;const handlePageChange = (data: { selected: number }) =&gt; {\n&nbsp;&nbsp;// クリックしたページ数を{selected: 1}のようなオブジェクト形式で引数に受ける\n&nbsp;&nbsp;setOffset(data.selected * perPage)&nbsp;&nbsp;// 表示する記事の開始位置を変更\n\n&nbsp;&nbsp;// ページ最上部へスクロールする\n&nbsp;&nbsp;window.scrollTo({&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;top: 0,\n&nbsp;&nbsp;&nbsp;behavior: \"smooth\",\n&nbsp;&nbsp;});\n&nbsp;};</code></pre><p><br>記事の一覧表示の箇所を修正します。</p><pre><code>// 表示する記事をsliceで抽出して一覧表示\n{showBlogs.slice(offset, offset + perPage).map((blog) =&gt; (</code></pre><p><br><br>ページネーションコンポーネントを記事一覧の下に設置します。</p><pre><code>// ページネーションコンポーネント\n&lt;ReactPaginate\n&nbsp;&nbsp;previousLabel={\"&lt;\"}&nbsp;// 前のページボタン\n&nbsp;&nbsp;nextLabel={\"&gt;\"}&nbsp;&nbsp;// 次のページボタン\n&nbsp;&nbsp;pageCount={Math.ceil(blogs.length / perPage)}&nbsp;&nbsp;// ページ総数\n&nbsp;&nbsp;onPageChange={handlePageChange}&nbsp;&nbsp;// クリック時のfunction\n&nbsp;&nbsp;containerClassName={\"pagination\"}&nbsp;&nbsp;// ページネーションであるulに付くクラス名\n&nbsp;&nbsp;activeClassName={\"active\"}&nbsp;&nbsp;// アクティブなページのliに着くクラス名\n/&gt;</code></pre><p><br>スタイルを付けます。</p><pre><code>.pagination {\n&nbsp;display: flex;\n&nbsp;align-items: center;\n&nbsp;justify-content: center;\n&nbsp;margin: 0 auto;\n&nbsp;padding: 40px 0;\n}\n\n.pagination li {\n&nbsp;margin: 0 16px;\n}\n\n.pagination li &gt; a {\n&nbsp;position: relative;\n&nbsp;font-size: 16px;\n&nbsp;width: 24px;\n&nbsp;height: 24px;\n&nbsp;outline: none;\n&nbsp;z-index: 100;\n&nbsp;cursor: pointer;\n}\n\n.pagination a::before {\n&nbsp;content: \"\";\n&nbsp;display: block;\n&nbsp;position: absolute;\n&nbsp;top: 50%;\n&nbsp;left: 50%;\n&nbsp;width: 32px;\n&nbsp;height: 32px;\n&nbsp;border-radius: 50%;\n&nbsp;transform: translate(-50%, -50%);\n&nbsp;z-index: -100;\n}\n\n.pagination li.active &gt; a::before {\n&nbsp;background-color: #929191;\n}\n\n.pagination li.active &gt; a {\n&nbsp;color: #f2f2f2;\n}</code></pre><p><br>以上でページネーションを実装できました。<br><br>予めフロント側で全件保持している記事データに対して表示を変えているだけなので、もちろんリロードもなく瞬時に切り替わります。<br></p><h2 id=\"h9b4c4b9dd7\"> 最後に</h2><p>microCMSは公式のチュートリアルやブログが豊富で分かりやすく、機能もどんどん拡張されており（最初は公式SDKも無かったらしい）、長く使っていくにも安心だなと思いました。<br><br>このブログは最低限の機能を作ってデプロイしたのでまだまだ未完成ですが、これから機能拡大・スタイル修正していきたいなと思います。<br></p><h2 id=\"h3bcda3e6b0\">最後に</h2><p>microCMSは公式のチュートリアルやブログが豊富で分かりやすく、機能もどんどん拡張されており（最初は公式SDKも無かったらしい）、長く使っていくにも安心だなと思いました。<br><br>このブログは最低限の機能を作ってデプロイしたのでまだまだ未完成ですが、これから機能拡大・スタイル修正していきたいなと思います。<br></p><h2 id=\"he45680f0bc\">参考記事</h2><p><a href=\"https://zenn.dev/elletech/articles/nextjs_microcms\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js(TypeScript)、TailwindCSS、microCMSでブログを作成しよう！</a><br><a href=\"https://blog.microcms.io/microcms-next-jamstack-blog/\" target=\"_blank\" rel=\"noopener noreferrer\">microCMS + Next.jsでJamstackブログを作ってみよう</a><br><a href=\"https://fwywd.com/tech/next-eslint-prettier\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js (TypeScript) に ESLint と Prettier を導入し、コードを綺麗に保とう | fwywd（フュード）...</a><br></p>","tags":[{"id":"nextjs","createdAt":"2022-01-07T13:18:14.144Z","updatedAt":"2022-02-12T02:31:58.832Z","publishedAt":"2022-01-07T13:18:14.144Z","revisedAt":"2022-01-07T13:18:14.144Z","tag":"Next.js"},{"id":"microcms","createdAt":"2022-02-17T12:48:01.991Z","updatedAt":"2022-02-17T12:48:13.704Z","publishedAt":"2022-02-17T12:48:01.991Z","revisedAt":"2022-02-17T12:48:01.991Z","tag":"microCMS"},{"id":"typescript","createdAt":"2022-01-07T13:18:58.358Z","updatedAt":"2022-02-17T03:22:47.524Z","publishedAt":"2022-01-07T13:18:58.358Z","revisedAt":"2022-02-17T03:22:47.524Z","tag":"TypeScript"}],"image":"blog"},"highlightedBody":"<html><head></head><body><h2 id=\"h9707d3a59a\">概要</h2><p><code>microCMS</code>、<code>Next.js（TypeScript）</code>を使ってブログサイトを作成した手順と、追加で実装した機能について、またその過程で学んだことの備忘録記事です。<br><br>基本的には公式のチュートリアル通りに進めていますが、TypeScriptの型付けや記事内のコードブロックのハイライトなど詰まった箇所もあったので、まとめておきたいと思います。<br></p><ul><li>デプロイURL</li></ul><p><a href=\"https://microcms-blog-hinakonagao.vercel.app/\" target=\"_blank\" rel=\"noopener noreferrer\">https://microcms-blog-hinakonagao.vercel.app</a><br></p><ul><li>GitHub</li></ul><p><a href=\"https://github.com/hinakonagao/microcms_blog\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/hinakonagao/microcms_blog</a><br><br>※この記事ではページのスタイリングは解説しません。<br>MaterialUIを主に使用してスタイリングを行っているので、詳しいコードはGitHubをご覧いただければと思います。<br></p><h3 id=\"h48162eced8\">使用技術</h3><ul><li>Next.js　12.0.10</li><li>React　17.0.2</li><li>TypeScript　4.5.5</li><li>ESLint　8.8.0</li><li>prettier　2.5.1</li></ul><p><br></p><h2 id=\"hc953739b3f\">全体の流れ</h2><p>１．microCMSの準備（アカウント作成・記事コンテンツのAPI作成）<br>２．Next.jsのプロジェクト作成<br>３．APIリクエストのための環境変数の設定<br>４．公式のSDK「microcms-js-sdk」の導入<br>５．記事一覧画面の作成<br>６．記事詳細画面の作成<br>７．コードブロックのシンタックスハイライトの実装<br>８．【おまけ】タグでの絞り込み機能の実装<br>９．【おまけ】ページネーション機能の実装<br><br>というような流れで説明していきます。<br></p><h2 id=\"hd1205c1797\">1. microCMSの準備</h2><p>まずはmicroCMSのアカウントを作成し、APIを作成します。<br><br>手順は公式のチュートリアルに詳しく書かれているので、ここでの説明は割愛します。<br><a style=\"color:#4aac00\" href=\"https://blog.microcms.io/microcms-next-jamstack-blog/#:%7E:text=%E3%81%8C%E7%AB%8B%E3%81%A1%E4%B8%8A%E3%81%8C%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82-,2.%20microCMS%E3%81%AE%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B,-%E6%AC%A1%E3%81%AB%E3%80%81microCMS%E3%81%A7\" target=\"_blank\" rel=\"noopener noreferrer\">microCMS + Next.jsでJamstackブログを作ってみよう　2. microCMSの用意する</a><br><br>私は&nbsp;<code>blog</code>&nbsp;と&nbsp;<code>tag</code>&nbsp;の2つのAPIエンドポイントを作成しました。<br></p><h3 id=\"hebabef9705\">blog</h3><p>ブログコンテンツを登録しておくリスト形式の API です。</p><ul><li>title：記事タイトル</li><li>body：記事本文</li><li>tags：タグ（別のエンドポイント&nbsp;<code>/tag</code>&nbsp;に登録したタグを複数参照できるように設定）</li><li>image：表示する画像名（プロジェクトディレクトリに保存した画像の中から、ブラウザに表示する画像を指定するために使用）</li></ul><p><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/577556386f954864b763ec82bdea4d3c/blog.jpg\" alt=\"\"><br></p><h3 id=\"h1d9b92c0c9\">tag</h3><p>ブログ記事に紐づけるタグを登録しておくリスト形式の API です。<br><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/24cd3d349eb74b35a9ee5ca8f901543a/tag.jpg\" alt=\"\"><br></p><h2 id=\"hce660a84c7\">2. Next.jsプロジェクトを作成する</h2><p>下記のコマンドを実行してNext.jsのプロジェクトを作成し、続けて開発サーバーを立ち上げます。</p><pre><code class=\"hljs\">$ yarn create <span class=\"hljs-keyword\">next</span>-app --typescript\n<span class=\"hljs-regexp\">//</span> プロジェクト名の入力を求められるので入力する\n\n$ cd .<span class=\"hljs-regexp\">/microcms_blog/</span>\n\n$ yarn dev</code></pre><p><br>次に<code>src</code>ディレクトリを作成して、<code>pages</code>ディレクトリと<code>styles</code>ディレクトリを<code>src</code>ディレクトリの配下に移動させます。</p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> src &amp;&amp; <span class=\"hljs-built_in\">mv</span> pages src &amp;&amp; <span class=\"hljs-built_in\">mv</span> styles src</span></code></pre><p><br>さらに、モジュールのインポートを絶対パスで指定できるよう、ベースURLを&nbsp;<code>src</code>&nbsp;ディレクトリに設定します。</p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> tsconfig.json\n{\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-regexp\">//</span> 追加\n    <span class=\"hljs-string\">\"baseUrl\"</span>: <span class=\"hljs-string\">\"src\"</span>\n  }\n}</code></pre><p>ベースURLの設定についてはこちらの記事を参考にさせていただきました。<br><a href=\"https://fwywd.com/tech/next-base-url\" target=\"_blank\" rel=\"noopener noreferrer\">【Next.js】特定のディレクトリを基準にし、絶対パスでモジュールをインポートする方法 | fwywd（フュード）powered by キ...</a><br></p><h2 id=\"ha56333b74a\">ESLint / Prettier</h2><p>Next.js のバージョン11 からは、デフォルトでESLintが搭載されています。<br>ESLintに関するインストール済のパッケージは以下の2つです。</p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> package.json\n{\n  ...\n  <span class=\"hljs-string\">\"devDependencies\"</span>: {\n    <span class=\"hljs-string\">\"eslint\"</span>: <span class=\"hljs-string\">\"8.8.0\"</span>,    <span class=\"hljs-regexp\">//</span> 構文解析のエンジン\n    <span class=\"hljs-string\">\"eslint-config-next\"</span>: <span class=\"hljs-string\">\"12.0.10\"</span>,    <span class=\"hljs-regexp\">//</span> ESLintのルール\n  }\n  ...\n}</code></pre><p><br>Next.js の新規プロジェクト作成時に生成された&nbsp;<code>.eslintrc</code>&nbsp;は ESLint の設定ファイルを意味しており、<strong>デフォルトで&nbsp;</strong><strong><code>eslint-config-next</code></strong><strong>&nbsp;の設定が適用</strong>されています。（ルールの詳細は後述）</p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> .eslintrc.json\n\n{\n  <span class=\"hljs-string\">\"extends\"</span>: <span class=\"hljs-string\">\"next/core-web-vitals\"</span>,\n}\n\n</code></pre><p><br>少しだけESLintの設定を加えます。</p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> .eslintrc.json\n\n{\n  <span class=\"hljs-string\">\"extends\"</span>: <span class=\"hljs-string\">\"next/core-web-vitals\"</span>,\n  <span class=\"hljs-regexp\">//</span> 以下のルールを追記\n  <span class=\"hljs-string\">\"rules\"</span>: {\n    <span class=\"hljs-string\">\"react/display-name\"</span>: <span class=\"hljs-string\">\"off\"</span>,\n    <span class=\"hljs-string\">\"react-hooks/exhaustive-deps\"</span>: <span class=\"hljs-string\">\"off\"</span>,\n    <span class=\"hljs-string\">\"@next/next/no-sync-scripts\"</span>: <span class=\"hljs-string\">\"off\"</span>\n  }\n}</code></pre><p><br>Prettier は含まれていないため、インストールしておきます。</p><pre><code class=\"hljs\">$ yarn -DE <span class=\"hljs-keyword\">add </span>prettier eslint-<span class=\"hljs-built_in\">config</span>-prettier</code></pre><h2 id=\"h5095390624\"><br>3. 環境変数の設定</h2><p>microCMSのAPIへアクセスする際は、サービスドメインを指定し、リクエストにそのサービスドメインのAPIキーを含める事でデータを取得することができます。<br><br>※microCMSでのAPIキーの作成方法は公式ページを参照ください。<br><a style=\"color:#4aac00\" href=\"https://document.microcms.io/content-api/x-microcms-api-key\" target=\"_blank\" rel=\"noopener noreferrer\">APIキー（X-MICROCMS-API-KEY）</a><br><br>まずは環境変数を管理するファイルを作成します。<br>※&nbsp;<code>.local</code>をつけるとローカル環境で使うことができ、&nbsp;<code>.development</code>をつけると開発環境で使えます。</p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">touch</span> .env.development.local</span></code></pre><p><br><code>.env.development.local</code>ファイルを作成したら、<code>サービスドメイン</code>とmicroCMSの<code>APIキー</code>を書き込みます。<br>※サービスドメインは、例えば自分のmicroCMSページのURLが&nbsp;<code>https://aiueo.microcms.io/</code>&nbsp;であれば&nbsp;<code>aiueo</code>&nbsp;の部分になります。</p><pre><code class=\"hljs\"><span class=\"hljs-attr\">SERVICE_DOMAIN</span>=xxxxxxxxxxx\n<span class=\"hljs-attr\">API_KEY</span>=xxxxxxxxxxxx</code></pre><p><br><code>env</code>&nbsp;ファイルに書いた値は、以下のようにしてプロジェクト内で参照することができます。</p><pre><code class=\"hljs\">process.env.API_KEY</code></pre><h2 id=\"h84f24c70f8\"><br>4.microcms-js-sdkの準備</h2><p>APIリクエストには公式が提供している<code>microcms-js-sdk</code>を使います。<br><br>まずは<code>microcms-js-sdk</code>をインストールします。</p><pre><code class=\"hljs\">$ yarn <span class=\"hljs-built_in\">add</span> microcms-js-sdk</code></pre><p><br><code>libs/client.ts</code>&nbsp;を作成してSDKの初期化を行います。</p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> src/libs</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">touch</span> ./src/libs/client.ts</span></code></pre><p><br><code>serviceDomain</code>&nbsp;と&nbsp;<code>apiKey</code>&nbsp;の値は&nbsp;<code>env</code>&nbsp;ファイルを参照します。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// libs/client.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { createClient } from <span class=\"hljs-string\">\"microcms-js-sdk\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-type\">const</span> client = <span class=\"hljs-built_in\">createClient</span>({\n  serviceDomain: process.env.SERVICE_DOMAIN || <span class=\"hljs-string\">\"\"</span>,\n  apiKey: process.env.API_KEY || <span class=\"hljs-string\">\"\"</span>,\n});</code></pre><p><br>※<code>serviceDomain</code>&nbsp;と&nbsp;<code>apiKey</code>&nbsp;は&nbsp;<code>string</code>型、.envファイルから参照する環境変数は&nbsp;<code>string | undefined</code>型なので、もし以下のように&nbsp;<code>|| \"\"</code>&nbsp;の部分を書かないとエラーが出ます。</p><pre><code class=\"hljs\">serviceDomain: process.env.SERVICE_DOMAIN\n<span class=\"hljs-regexp\">//</span> 型 <span class=\"hljs-string\">'string | undefined'</span> を型 <span class=\"hljs-string\">'string'</span> に割り当てることはできません。型 <span class=\"hljs-string\">'undefined'</span> を型 <span class=\"hljs-string\">'string'</span> に割り当てることはできません。</code></pre><h2 id=\"h4e79de37a7\"><br>5. microCMSから記事データを取得する（一覧画面）</h2><h3 id=\"hde4a1d43ba\">型の事前準備</h3><p>microCMSから取得するブログ記事とタグのデータ型を定義しておきます。<br><br>型定義ファイルを別途作成します。</p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> src/types</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">touch</span> ./src/types/blog.ts</span></code></pre><p><br>作成したファイルに型を定義します。<br>今回私が作成したAPIだと以下の通りになります。</p><pre><code class=\"hljs\">// src/types/blog.ts\n\nexport type Blog = {\n  <span class=\"hljs-attribute\">id</span>: string;\n  <span class=\"hljs-attribute\">body</span>: string;\n  <span class=\"hljs-attribute\">title</span>: string;\n  <span class=\"hljs-attribute\">tags</span>: Tag[];\n  <span class=\"hljs-attribute\">image</span>: string;\n  <span class=\"hljs-attribute\">createdAt</span>: string;\n  <span class=\"hljs-attribute\">updatedAt</span>: string;\n  <span class=\"hljs-attribute\">publishedAt</span>: string;\n  <span class=\"hljs-attribute\">revisedAt</span>: string;\n};\n\nexport type Tag = {\n  <span class=\"hljs-attribute\">id</span>: string;\n  <span class=\"hljs-attribute\">tag</span>: string;\n  <span class=\"hljs-attribute\">createdAt</span>: string;\n  <span class=\"hljs-attribute\">updatedAt</span>: string;\n  <span class=\"hljs-attribute\">publishedAt</span>: string;\n  <span class=\"hljs-attribute\">revisedAt</span>: string;\n};</code></pre><h3 id=\"hbc42ef09fb\"><br>APIリクエストを行う</h3><p><code>getStaticProps</code>を使ってmicroCMSのAPIを叩き、データを取得します。<br><code>pages/index.tsx</code>&nbsp;に以下のように書きます。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// pages/index.js</span>\n\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Link</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/link\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">InferGetStaticPropsType</span>, <span class=\"hljs-title class_\">NextPage</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next\"</span>;\n<span class=\"hljs-keyword\">import</span> { client } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"libs/client\"</span>;    <span class=\"hljs-comment\">// srcから見た絶対パスで指定</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Blog</span>, <span class=\"hljs-title class_\">Tag</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"types/blog\"</span>;    <span class=\"hljs-comment\">// srcから見た絶対パスで指定</span>\n\n<span class=\"hljs-comment\">// microCMSへAPIリクエスト</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getStaticProps</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> blog = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">get</span>({ <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"blog\"</span> });\n  <span class=\"hljs-keyword\">const</span> tag = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">get</span>({ <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"tag\"</span> });\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">blogs</span>: blog.<span class=\"hljs-property\">contents</span>,\n      <span class=\"hljs-attr\">tags</span>: tag.<span class=\"hljs-property\">contents</span>,\n    },\n  };\n};\n\n<span class=\"hljs-comment\">// Props（blogsとtags）の型</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Props</span> = {\n  <span class=\"hljs-attr\">blogs</span>: <span class=\"hljs-title class_\">Blog</span>[];\n  <span class=\"hljs-attr\">tags</span>: <span class=\"hljs-title class_\">Tag</span>[];\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Home</span>: <span class=\"hljs-title class_\">NextPage</span>&lt;<span class=\"hljs-title class_\">InferGetStaticPropsType</span>&lt;<span class=\"hljs-keyword\">typeof</span> getStaticProps&gt;&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  blogs,\n  tags,\n}: Props</span>) =&gt;</span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(blogs);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tags);\n　<span class=\"hljs-comment\">// ... 以下省略</span></code></pre><p><br>ここで&nbsp;<code>http://localhost:3000</code>&nbsp;にアクセスすると、コンソールにAPIから取得したデータが表示されるはずです。<br><br>私の作成したAPIだと、以下の画像のようなデータが取れています。</p><h3 id=\"hf4a22cee96\">blogs</h3><p><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/21ce7cb8666749859e4e9a8a1a57939a/blogs.jpg\" alt=\"\"><br></p><h3 id=\"h0502f3a90c\">tags</h3><p><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/3634ac49f1c749069024d8d2e57474f1/tags.jpg\" alt=\"\"><br><br>ではこのデータを画面に表示します。<br><br>※ディレクトリ構成は以下のようにします。</p><ul><li>pages/index.js&nbsp;→ 記事一覧画面</li><li>pages/blog/[id].ts → 記事詳細画面</li></ul><p><br>一覧画面に記事タイトルをリスト形式で表示し、記事詳細画面へのリンクをつけます。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// pages/index.tsx</span>\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Home</span>: <span class=\"hljs-title class_\">NextPage</span>&lt;<span class=\"hljs-title class_\">InferGetStaticPropsType</span>&lt;<span class=\"hljs-keyword\">typeof</span> getStaticProps&gt;&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  blogs,\n  tags,\n}: Props</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n        {blogs.map((blog) =&gt; (\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{blog.id}</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">{</span>`/<span class=\"hljs-attr\">blog</span>/${<span class=\"hljs-attr\">blog.id</span>}`}&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>&gt;</span>{blog.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Link</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        ))}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  )\n}</code></pre><p><br>これで&nbsp;<code>http://localhost:3000</code>&nbsp;にアクセスすると記事タイトル一覧が表示され、タイトルをクリックすると&nbsp;<code>http://localhost:3000/blog/[microCMSで設定したコンテンツID]</code>&nbsp;のURLへ遷移するはずです。<br><br>次にこの遷移先のページを作ります。<br></p><h2 id=\"h85b588f038\">6. 記事詳細画面を作成する</h2><p>一覧画面でブログ記事の詳細画面を作っていきます。<br><br>上記のリンク先に指定した通り、&nbsp;<code>pages/blog/[id].ts</code>に詳細画面を作ります。<br>まずはファイルを作成します。</p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> src/pages/blog</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">touch</span> ./src/pages/blog/[<span class=\"hljs-built_in\">id</span>].tsx</span></code></pre><p><br>作成したファイルを、以下のように編集します。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// pages/blog/[id].tsx</span>\n\n<span class=\"hljs-keyword\">import</span> {\n  <span class=\"hljs-title class_\">GetStaticPaths</span>,\n  <span class=\"hljs-title class_\">GetStaticProps</span>,\n  <span class=\"hljs-title class_\">InferGetStaticPropsType</span>,\n  <span class=\"hljs-title class_\">NextPage</span>,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next\"</span>;\n<span class=\"hljs-keyword\">import</span> { client } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"libs/client\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">type</span> { <span class=\"hljs-title class_\">Blog</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"types/blog\"</span>;\n\n<span class=\"hljs-comment\">// APIリクエストを行うパスを指定</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">getStaticPaths</span>: <span class=\"hljs-title class_\">GetStaticPaths</span>&lt;<span class=\"hljs-title class_\">Params</span>&gt; = <span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">get</span>({ <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"blog\"</span> });\n\n  <span class=\"hljs-keyword\">const</span> paths = data.<span class=\"hljs-property\">contents</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">content</span>) =&gt;</span> <span class=\"hljs-string\">`/blog/<span class=\"hljs-subst\">${content.id}</span>`</span>);\n  <span class=\"hljs-keyword\">return</span> { paths, <span class=\"hljs-attr\">fallback</span>: <span class=\"hljs-literal\">false</span> };\n};\n\n<span class=\"hljs-comment\">// microCMSへAPIリクエスト</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">getStaticProps</span>: <span class=\"hljs-title class_\">GetStaticProps</span>&lt;<span class=\"hljs-title class_\">Props</span>, <span class=\"hljs-title class_\">Params</span>&gt; = <span class=\"hljs-keyword\">async</span> (\n  <span class=\"hljs-keyword\">const</span> id = context.<span class=\"hljs-property\">params</span>?.<span class=\"hljs-property\">id</span>;\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">get</span>({ <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"blog\"</span>, <span class=\"hljs-attr\">contentId</span>: id });\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">props</span>: {\n      <span class=\"hljs-attr\">blog</span>: data,\n    },\n  };\n};\n\n<span class=\"hljs-comment\">// // Props（blog）の型</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Props</span> = {\n  <span class=\"hljs-attr\">blog</span>: <span class=\"hljs-title class_\">Blog</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">BlogId</span>: <span class=\"hljs-title class_\">NextPage</span>&lt;<span class=\"hljs-title class_\">InferGetStaticPropsType</span>&lt;<span class=\"hljs-keyword\">typeof</span> getStaticProps&gt;&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">{\n  blog,\n}: Props</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{blog.title}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{blog.publishedAt}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n            {blog.tags.map((tag) =&gt; (\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{tag.id}</span>&gt;</span>\n          #{tag.tag}\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n      ))}\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">dangerouslySetInnerHTML</span>=<span class=\"hljs-string\">{{</span>\n          <span class=\"hljs-attr\">__html:</span> `${<span class=\"hljs-attr\">blog.body</span>}`,\n        }}\n      /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span></span>\n  );\n}</code></pre><h3 id=\"h8a50fc5ec1\"><br>ポイント解説</h3><ul><li><code>fallback: false</code>&nbsp;の設定</li></ul><p><code>getStaticPaths</code>&nbsp;で&nbsp;<code>return { fallback: false };</code>&nbsp;と書いています。<br><br>これにより、&nbsp;<code>http://localhost:3000/blog/[存在しないコンテンツID]</code>&nbsp;のURLにアクセスすると404ページへ遷移するようになります。<br>※&nbsp;<code>fallback: true</code>&nbsp;にして存在しないURLにアクセスした場合はエラー画面が出てしまいます。<br></p><ul><li><code>dangerouslySetInnerHTML</code></li></ul><p>以下の通り、記事本文は&nbsp;<code>dangerouslySetInnerHTML</code>&nbsp;を通して表示しています。<br></p><pre><code class=\"hljs\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">dangerouslySetInnerHTML</span>=</span></span><span class=\"hljs-template-variable\">{{\n    <span class=\"hljs-name\">__html:</span> `${blog.body}`,\n  }}</span><span class=\"language-xml\"><span class=\"hljs-tag\">\n/&gt;</span></span></code></pre><p><br>APIから返される記事本文は文字列形式（HTMLタグも文字列として取得される）なので、これをHTMLとして描画するために<code>dangerouslySetInnerHTML</code>&nbsp;を使っています。<br></p><h2 id=\"h7941af99cd\">7. コードブロックのハイライトを行う</h2><p>microCMSのリッチエディタでソースコードとして記述した部分は、</p><pre><code class=\"hljs\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pre</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">code</span>&gt;</span>\n    // コード\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">code</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pre</span>&gt;</span></code></pre><p>という形式で取得されます。<br><br>このままdangerouslySetInnerHTMLを通すだけでは、何もハイライトされていないコードが表示されるので、ライブラリを使って装飾していきます。<br><br>microCMSの公式で紹介されている、<a style=\"color:#4aac00\" href=\"https://www.npmjs.com/package/cheerio\" target=\"_blank\" rel=\"noopener noreferrer\">cheerio</a>と<a style=\"color:#4aac00\" href=\"https://www.npmjs.com/package/highlight.js\" target=\"_blank\" rel=\"noopener noreferrer\">highlight.js</a>というライブラリを使ってサーバーサイドでハイライトを行いました。<br><a href=\"https://blog.microcms.io/syntax-highlighting-on-server-side/\" target=\"_blank\" rel=\"noopener noreferrer\">サーバサイドでシンタックスハイライトを行う</a><br><br>まずはライブラリをインストールします。</p><pre><code class=\"hljs\"><span class=\"hljs-variable\">$ </span>yarn add highlight.js cheerio\n<span class=\"hljs-variable\">$ </span>yarn add --dev <span class=\"hljs-variable\">@types</span>/highlightjs <span class=\"hljs-variable\">@types</span>/cheerio</code></pre><p><br>次にブログ記事を生成する際の&nbsp;<code>getStaticProps</code>&nbsp;内の記述を修正します。<br>※ライブラリについての説明は上記のmicroCMSの記事などを参照ください。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// pages/blog/[id].tsx</span>\n\n<span class=\"hljs-comment\">// importを追記</span>\n<span class=\"hljs-keyword\">import</span> cheerio <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"cheerio\"</span>;\n<span class=\"hljs-keyword\">import</span> hljs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"highlight.js\"</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"highlight.js/styles/hybrid.css\"</span>;\n\n<span class=\"hljs-comment\">// 中略</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">getStaticProps</span>: <span class=\"hljs-title class_\">GetStaticProps</span>&lt;<span class=\"hljs-title class_\">Props</span>, <span class=\"hljs-title class_\">Params</span>&gt; = <span class=\"hljs-keyword\">async</span> (\n  context\n) =&gt; {\n  <span class=\"hljs-keyword\">const</span> id = context.<span class=\"hljs-property\">params</span>?.<span class=\"hljs-property\">id</span>;\n  <span class=\"hljs-keyword\">const</span> blog = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">get</span>({ <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"blog\"</span>, <span class=\"hljs-attr\">contentId</span>: id });\n  <span class=\"hljs-comment\">// 以下の部分を追記</span>\n  <span class=\"hljs-keyword\">const</span> $ = cheerio.<span class=\"hljs-title function_\">load</span>(blog.<span class=\"hljs-property\">body</span>);\n  $(<span class=\"hljs-string\">\"pre code\"</span>).<span class=\"hljs-title function_\">each</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, elm</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> result = hljs.<span class=\"hljs-title function_\">highlightAuto</span>($(elm).<span class=\"hljs-title function_\">text</span>());\n    $(elm).<span class=\"hljs-title function_\">html</span>(result.<span class=\"hljs-property\">value</span>);\n    $(elm).<span class=\"hljs-title function_\">addClass</span>(<span class=\"hljs-string\">\"hljs\"</span>);\n  });\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">props</span>: {\n      blog,\n      <span class=\"hljs-attr\">highlightedBody</span>: $.<span class=\"hljs-title function_\">html</span>(),\n    },\n  };\n};</code></pre><p>これでサーバーサード側でシンタックスハイライト済の記事データを取得することができます。<br><br>※実装においては以下の記事も参考にさせていただきました。<br><a href=\"https://www.blogchin.net/blogs/p9f3s1x5k5yb/\" target=\"_blank\" rel=\"noopener noreferrer\">Next.JS+microCMSで作成したブログに、ソースコードのシンタックスハイライトをつけてみる</a><br><a href=\"https://qiita.com/cawauchi/items/ff6489b17800c5676908\" target=\"_blank\" rel=\"noopener noreferrer\">next.js+microcmsでシンタックスハイライトの導入 - Qiita</a></p><h2 id=\"h5a51a8e35e\"><br>8. 【おまけ】タグでの絞り込み機能</h2><p>先述の通り、今回は&nbsp;<code>blog</code>&nbsp;と&nbsp;<code>tag</code>&nbsp;の2つのAPIを作成し、ブログ記事は複数の&nbsp;<code>tag</code>&nbsp;を持てるようにしました。<br><br>そして</p><ul><li>記事一覧画面で各記事が持つタグを表示</li><li>APIから取得した&nbsp;<code>tag</code>&nbsp;の一覧をサイドバーに表示（タグを選んで記事を絞り込む）</li></ul><p>を出来るようにしました。<br><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/0ef6284906254e6580e558fae4082554/tag_serch.jpg\" alt=\"\"><br></p><h3 id=\"h3ab24f6f50\">メリット</h3><p><code>tag</code>&nbsp;のAPIエンドポイントを別途作成する構成にしたことで、以下のようなメリットがあります。</p><ul><li>サイドバーに設置した&nbsp;<code>tag</code>&nbsp;一覧の表示順の並べ替えや修正を、コードをいじらずmicroCMSの管理画面で行える。</li><li><code>tag</code>&nbsp;名を修正したい時に、記事のタグを一つひとつ修正しなくともAPIの&nbsp;<code>tag</code>&nbsp;を修正すれば一括して変更できる。</li></ul><h3 id=\"h50d6571ee1\"><br>実装方法（記事一覧の表示について）</h3><p>まずは、&nbsp;<code>getStaticProps</code>&nbsp;から受け取った記事をそのまま全て表示するのではなく、画面に表示する記事だけを格納する&nbsp;<code>state</code>&nbsp;を別途作成します。</p><pre><code class=\"hljs\">const <span class=\"hljs-literal\">[<span class=\"hljs-identifier\">showBlogs</span>, <span class=\"hljs-identifier\">setShowBlogs</span>]</span> = use<span class=\"hljs-constructor\">State(<span class=\"hljs-params\">blogs</span>)</span>\n<span class=\"hljs-comment\">// 初期値にgetStaticPropsから受け取ったブログ記事データを入れる</span></code></pre><p><br>そして画面には&nbsp;<code>showBlogs</code>&nbsp;の中身を&nbsp;<code>map</code>&nbsp;で回して一覧表示します。<br>※絞り込みによって&nbsp;<code>showBlogs</code>&nbsp;に記事が入っていなかった場合のための条件付きレンダリングも記述しておきます。</p><pre><code class=\"hljs\">{!showBlogs.<span class=\"hljs-built_in\">length</span> &amp;&amp; &lt;p&gt;There are no posts...&lt;/p&gt;}\n{showBlogs.<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">blog</span>) =&gt;</span> (\n    <span class=\"hljs-comment\">// 記事を表示</span></code></pre><p><br><br><strong>※注</strong><br><strong>このブログサイトはMaterialUIを使ってスタイリングを行っており、ここからは実際の実装通り、通常のHTMLタグではなくMaterialUIのタグで表記させていただきます。</strong><br><strong>（MaterialUIのタグ名を見ればどんな役割の要素なのか想像がつくと思うので、MaterialUIに触れたことが無い方も何となく読み取っていただけるかなと思います。）</strong><br><br><br>記事の一覧表示の中で、この記事が持つ&nbsp;<code>tag</code>&nbsp;も&nbsp;<code>map</code>&nbsp;で回して表示します。</p><pre><code class=\"hljs\">{showBlogs.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">blog</span>) =&gt;</span> (\n\n    <span class=\"hljs-comment\">// 中略</span>\n\n    <span class=\"hljs-comment\">// 持っているtagを全て表示</span>\n    {blog.<span class=\"hljs-property\">tags</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">tag</span>) =&gt;</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Typography</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{tag.id}</span>&gt;</span>\n        #{tag.tag}\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Typography</span>&gt;</span></span>\n    ))}</code></pre><h3 id=\"h79fb2c15aa\"><br>実装方法（タグによる絞り込みについて）</h3><p><code>tag</code>&nbsp;のAPIエンドポイントから受け取るデータは、以下の<code>tag</code>型の配列でした。</p><pre><code class=\"hljs\">export <span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">Tag</span> <span class=\"hljs-title\">= {\n  id</span>: <span class=\"hljs-keyword\">string</span>;\n  <span class=\"hljs-keyword\">tag</span>: <span class=\"hljs-keyword\">string</span>;\n  createdAt: <span class=\"hljs-keyword\">string</span>;\n  updatedAt: <span class=\"hljs-keyword\">string</span>;\n  publishedAt: <span class=\"hljs-keyword\">string</span>;\n  revisedAt: <span class=\"hljs-keyword\">string</span>;\n};</code></pre><p><br>なのでまずはこのデータから、tag名だけを抜き出して配列に格納します。</p><pre><code class=\"hljs\">// getStaticPropsで取得したtagsから<span class=\"hljs-keyword\">tag</span>名のみ抜き出す\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">tag</span>List = tags.map((<span class=\"hljs-keyword\">tag</span>) =&gt; <span class=\"hljs-keyword\">tag</span>.<span class=\"hljs-keyword\">tag</span>);</code></pre><p><br>作成した&nbsp;<code>tagList</code>&nbsp;を使って、サイドバーにタグ一覧を表示します。</p><pre><code class=\"hljs\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">List</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Typography</span>&gt;</span>\n    # Tags\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Typography</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItemButton</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> selectTag(\"all\")}&gt;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItemText</span> <span class=\"hljs-attr\">primary</span>=<span class=\"hljs-string\">\"All\"</span>/&gt;</span>   // primaryに指定した文字列が表示される\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ListItemButton</span>&gt;</span>\n\n  {tagList.map((tag) =&gt; (\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItemButton</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{tag}</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> selectTag(tag)}&gt;\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListItemText</span> <span class=\"hljs-attr\">primary</span>=<span class=\"hljs-string\">{tag}/</span>&gt;</span>   // primaryに指定した文字列が表示される\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ListItemButton</span>&gt;</span>\n  ))}\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">List</span>&gt;</span></code></pre><p><br><code>onClick</code>&nbsp;に指定した&nbsp;<code>selectTag()</code>&nbsp;メソッドを実装します。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// タグ絞り込み</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">selectTag</span> = (<span class=\"hljs-params\">tag: <span class=\"hljs-built_in\">string</span></span>) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (tag === <span class=\"hljs-string\">\"all\"</span>) {\n    <span class=\"hljs-title function_\">setShowBlogs</span>(blogs);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">const</span> selectedBlogs = blogs.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">blog</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> haveTags = blog.<span class=\"hljs-property\">tags</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">tag</span>) =&gt;</span> tag.<span class=\"hljs-property\">tag</span>);\n      <span class=\"hljs-keyword\">return</span> haveTags.<span class=\"hljs-title function_\">includes</span>(tag);\n    });\n    <span class=\"hljs-title function_\">setShowBlogs</span>(selectedBlogs);\n  }\n\n  <span class=\"hljs-comment\">// 画面最上部へスクロールさせる</span>\n  <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">scrollTo</span>({\n    <span class=\"hljs-attr\">top</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">behavior</span>: <span class=\"hljs-string\">\"smooth\"</span>,\n  });\n};</code></pre><p><br>検索のロジックについては以前別の記事に書いたので、詳しくはこちらをご覧ください。<br><a style=\"color:#4aac00\" href=\"https://qiita.com/hinako_n/items/a0745afe0631578c698e\" target=\"_blank\" rel=\"noopener noreferrer\">Reactでリアルタイムの検索機能を実装する - Qiita</a><br><br>以上で「All」を選べば全記事が表示され、タグを選べばそのタグを持つ記事のみが表示されるようになりました。<br></p><h2 id=\"h88cdec125d\"> 9.【おまけ】ページネーション機能の実装</h2><p><code>react-paginate</code>というライブラリを使って、ページネーション機能を実装しました。  <br>ライブラリ： <a href=\"https://www.npmjs.com/package/react-paginate \" target=\"_blank\" rel=\"noopener noreferrer\">https://www.npmjs.com/package/react-paginate </a><br><br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/9a2cb163f00a4910b6ebf063d87811ab/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3.jpg\" alt=\"\"><br><br>ライブラリについての詳しい説明では割愛し、ここでは実装したコードだけ載せさせていただきます。<br>使い方は以下の記事を参考にさせていただきました。<br><br><a href=\"https://de-milestones.com/react_pagination/\" target=\"_blank\" rel=\"noopener noreferrer\">https://de-milestones.com/react_pagination/</a><br><br><a href=\"https://tech.stmn.co.jp/entry/2020/10/28/141406\" target=\"_blank\" rel=\"noopener noreferrer\">https://tech.stmn.co.jp/entry/2020/10/28/141406</a><br></p><h3 id=\"h2661198b93\">実装手順</h3><p>まずはライブラリをインストールします。<br></p><pre><code class=\"hljs\">$ yarn <span class=\"hljs-built_in\">add</span> react-paginate</code></pre><p><br>記事一覧画面を編集していきます。<br><br>ページネーションの制御に使う <code>state</code>と、ページネーションをクリックした時に実行するメソッドを定義します。  <br><br>pages/index.tsx</p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ReactPaginate</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-paginate\"</span>;\n\n\n<span class=\"hljs-comment\">// 中略</span>\n\n&nbsp;<span class=\"hljs-keyword\">const</span> [offset, setOffset] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>);&nbsp;&nbsp;<span class=\"hljs-comment\">// 何番目の記事から表示するか</span>\n&nbsp;<span class=\"hljs-keyword\">const</span> perPage = <span class=\"hljs-number\">6</span>;&nbsp;&nbsp;<span class=\"hljs-comment\">// 1ページあたりに表示する記事数</span>\n\n&nbsp;<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">handlePageChange</span> = (<span class=\"hljs-params\">data: { selected: <span class=\"hljs-built_in\">number</span> }</span>) =&gt; {\n&nbsp;&nbsp;<span class=\"hljs-comment\">// クリックしたページ数を{selected: 1}のようなオブジェクト形式で引数に受ける</span>\n&nbsp;&nbsp;<span class=\"hljs-title function_\">setOffset</span>(data.<span class=\"hljs-property\">selected</span> * perPage)&nbsp;&nbsp;<span class=\"hljs-comment\">// 表示する記事の開始位置を変更</span>\n\n&nbsp;&nbsp;<span class=\"hljs-comment\">// ページ最上部へスクロールする</span>\n&nbsp;&nbsp;<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">scrollTo</span>({&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\">top</span>: <span class=\"hljs-number\">0</span>,\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attr\">behavior</span>: <span class=\"hljs-string\">\"smooth\"</span>,\n&nbsp;&nbsp;});\n&nbsp;};</code></pre><p><br>記事の一覧表示の箇所を修正します。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// 表示する記事をsliceで抽出して一覧表示</span>\n{showBlogs.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-built_in\">offset</span>, <span class=\"hljs-built_in\">offset</span> + perPage).<span class=\"hljs-built_in\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">blog</span>) =&gt;</span> (</code></pre><p><br><br>ページネーションコンポーネントを記事一覧の下に設置します。</p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// ページネーションコンポーネント</span>\n&lt;ReactPaginate\n&nbsp;&nbsp;previousLabel={<span class=\"hljs-string\">\"&lt;\"</span>}&nbsp;<span class=\"hljs-comment\">// 前のページボタン</span>\n&nbsp;&nbsp;nextLabel={<span class=\"hljs-string\">\"&gt;\"</span>}&nbsp;&nbsp;<span class=\"hljs-comment\">// 次のページボタン</span>\n&nbsp;&nbsp;pageCount={Math.<span class=\"hljs-built_in\">ceil</span>(blogs.<span class=\"hljs-built_in\">length</span> / perPage)}&nbsp;&nbsp;<span class=\"hljs-comment\">// ページ総数</span>\n&nbsp;&nbsp;onPageChange={handlePageChange}&nbsp;&nbsp;<span class=\"hljs-comment\">// クリック時のfunction</span>\n&nbsp;&nbsp;containerClassName={<span class=\"hljs-string\">\"pagination\"</span>}&nbsp;&nbsp;<span class=\"hljs-comment\">// ページネーションであるulに付くクラス名</span>\n&nbsp;&nbsp;activeClassName={<span class=\"hljs-string\">\"active\"</span>}&nbsp;&nbsp;<span class=\"hljs-comment\">// アクティブなページのliに着くクラス名</span>\n/&gt;</code></pre><p><br>スタイルを付けます。</p><pre><code class=\"hljs\"><span class=\"hljs-selector-class\">.pagination</span> {\n&nbsp;<span class=\"hljs-attribute\">display</span>: flex;\n&nbsp;<span class=\"hljs-attribute\">align-items</span>: center;\n&nbsp;<span class=\"hljs-attribute\">justify-content</span>: center;\n&nbsp;<span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> auto;\n&nbsp;<span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">40px</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-selector-class\">.pagination</span> <span class=\"hljs-selector-tag\">li</span> {\n&nbsp;<span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">16px</span>;\n}\n\n<span class=\"hljs-selector-class\">.pagination</span> <span class=\"hljs-selector-tag\">li</span> &gt; <span class=\"hljs-selector-tag\">a</span> {\n&nbsp;<span class=\"hljs-attribute\">position</span>: relative;\n&nbsp;<span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;\n&nbsp;<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">24px</span>;\n&nbsp;<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">24px</span>;\n&nbsp;<span class=\"hljs-attribute\">outline</span>: none;\n&nbsp;<span class=\"hljs-attribute\">z-index</span>: <span class=\"hljs-number\">100</span>;\n&nbsp;<span class=\"hljs-attribute\">cursor</span>: pointer;\n}\n\n<span class=\"hljs-selector-class\">.pagination</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">::before</span> {\n&nbsp;<span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">\"\"</span>;\n&nbsp;<span class=\"hljs-attribute\">display</span>: block;\n&nbsp;<span class=\"hljs-attribute\">position</span>: absolute;\n&nbsp;<span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">50%</span>;\n&nbsp;<span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">50%</span>;\n&nbsp;<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">32px</span>;\n&nbsp;<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">32px</span>;\n&nbsp;<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">50%</span>;\n&nbsp;<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">translate</span>(-<span class=\"hljs-number\">50%</span>, -<span class=\"hljs-number\">50%</span>);\n&nbsp;<span class=\"hljs-attribute\">z-index</span>: -<span class=\"hljs-number\">100</span>;\n}\n\n<span class=\"hljs-selector-class\">.pagination</span> <span class=\"hljs-selector-tag\">li</span><span class=\"hljs-selector-class\">.active</span> &gt; <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">::before</span> {\n&nbsp;<span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#929191</span>;\n}\n\n<span class=\"hljs-selector-class\">.pagination</span> <span class=\"hljs-selector-tag\">li</span><span class=\"hljs-selector-class\">.active</span> &gt; <span class=\"hljs-selector-tag\">a</span> {\n&nbsp;<span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#f2f2f2</span>;\n}</code></pre><p><br>以上でページネーションを実装できました。<br><br>予めフロント側で全件保持している記事データに対して表示を変えているだけなので、もちろんリロードもなく瞬時に切り替わります。<br></p><h2 id=\"h9b4c4b9dd7\"> 最後に</h2><p>microCMSは公式のチュートリアルやブログが豊富で分かりやすく、機能もどんどん拡張されており（最初は公式SDKも無かったらしい）、長く使っていくにも安心だなと思いました。<br><br>このブログは最低限の機能を作ってデプロイしたのでまだまだ未完成ですが、これから機能拡大・スタイル修正していきたいなと思います。<br></p><h2 id=\"h3bcda3e6b0\">最後に</h2><p>microCMSは公式のチュートリアルやブログが豊富で分かりやすく、機能もどんどん拡張されており（最初は公式SDKも無かったらしい）、長く使っていくにも安心だなと思いました。<br><br>このブログは最低限の機能を作ってデプロイしたのでまだまだ未完成ですが、これから機能拡大・スタイル修正していきたいなと思います。<br></p><h2 id=\"he45680f0bc\">参考記事</h2><p><a href=\"https://zenn.dev/elletech/articles/nextjs_microcms\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js(TypeScript)、TailwindCSS、microCMSでブログを作成しよう！</a><br><a href=\"https://blog.microcms.io/microcms-next-jamstack-blog/\" target=\"_blank\" rel=\"noopener noreferrer\">microCMS + Next.jsでJamstackブログを作ってみよう</a><br><a href=\"https://fwywd.com/tech/next-eslint-prettier\" target=\"_blank\" rel=\"noopener noreferrer\">Next.js (TypeScript) に ESLint と Prettier を導入し、コードを綺麗に保とう | fwywd（フュード）...</a><br></p></body></html>"},"__N_SSG":true}
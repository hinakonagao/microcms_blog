{"pageProps":{"blog":{"id":"docker-lemp","createdAt":"2022-02-10T12:13:34.104Z","updatedAt":"2022-02-12T10:24:14.756Z","publishedAt":"2022-01-31T12:13:34.000Z","revisedAt":"2022-02-12T10:04:24.386Z","title":"DockerでPHP（Laravel）+ nginx + MySQLのLEMP環境を構築する","body":"<p>Docker, Docker Compose を使って、<code>PHP（Laravel） + nginx + MySQL</code>の<code>LEMP環境</code>を構築する記事です。   <br><br>検索するとDockerfileやdocker-compose.ymlの書き方については色んな方が記事を書いてくださっていて、動く環境を作ること自体は難しくありませんでした。<br><br>ですが、筆者はひとつコンテナを作っては動作確認していくという過程を経てすごく理解が深まったなと思うので、ファイルの書き方だけでなく動作確認したことやその結果を含めて記事に残しておきたいと思います。<br><br>↓　完成後のリポジトリはこちらです。<br><a href=\"unsafe:[object Object]\">https://github.com/hinakonagao/laravel_docker</a><br><br></p><h1 id=\"hdb194e8fef\"> 全体像</h1><p>最終的なディレクトリ構成は以下の通りです。<br><br>全コンテナを管理するdocker-compose.ymlがトップレベルにあり、同じくトップレベルにあるdockerディレクトリ配下に各コンテナのDockerfileや設定ファイルを置いています。</p><pre><code>docker_sample/\n├── src&nbsp;&nbsp;// Laravelプロジェクトのソースコード\n├── docker\n│&nbsp;&nbsp;├── app&nbsp;&nbsp;// PHPコンテナ\n│&nbsp;&nbsp;│&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;│&nbsp;&nbsp;└── php.ini\n│&nbsp;&nbsp;├── db&nbsp;&nbsp;&nbsp;// MySQLコンテナ\n│&nbsp;&nbsp;│&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;│&nbsp;&nbsp;└── my.cnf\n│&nbsp;&nbsp;└── web&nbsp;&nbsp;// nginxコンテナ\n│&nbsp;&nbsp;&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;&nbsp;&nbsp;└── default.conf\n└──&nbsp;docker-compose.yml&nbsp;&nbsp;// 全コンテナの管理</code></pre><p><br><br>早速一つずつコンテナを作っていきます。<br></p><h1 id=\"h949dc20ce4\">PHPのコンテナ（Laravelの開発環境）</h1><p>まずはLaravelの開発環境を構築するための、PHPのコンテナを作成します。<br></p><ul><li> docker-compose.ymlへの記述</li><li> PHPコンテナ用のDockerfile</li><li> PHPコンテナ用の設定ファイル（php.ini）</li></ul><p><br>について順に説明します。<br></p><h2 id=\"hce39c12d7b\"> docker-compose.yml（PHP）</h2><p><br>docker-compose.ymlのうち、PHPコンテナについての記述は以下の通りです。<br>※docker-compose.ymlはインデントが意味を持つので注意。</p><pre><code>version: \"3.9\"\n\nservices:\n&nbsp;app:&nbsp;&nbsp;// サービス名\n&nbsp;&nbsp;build:\n&nbsp;&nbsp;&nbsp;context: .\n&nbsp;&nbsp;&nbsp;dockerfile: ./docker/app/Dockerfile\n&nbsp;&nbsp;volumes:\n&nbsp;&nbsp;&nbsp;- ./src/:/app</code></pre><p><br></p><ul><li> <code>version:</code></li></ul><p>&nbsp;&nbsp;これはPHPコンテナについてではなく <code>docker-compose.yml</code> の先頭に書く設定ですが、Composeファイルのバージョンを表しています。  <br>&nbsp;&nbsp;今回は最新の `3.9` を使います。（最新のバージョンは下記の公式サイトを参照）<br>&nbsp;&nbsp;<a href=\"https://docs.docker.com/compose/compose-file/\" target=\"_blank\" rel=\"noopener noreferrer\">Compose file</a> <br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>build:</code>  </li></ul><p>&nbsp;&nbsp;ビルドコンテキストを指定します。</p><ul><li> context：ビルドコンテキスト（buildを実行する場所）の設定</li><li> dockerfile：buildするDockerfileまでのパス（docker-compose.ymlから見た相対パス）</li></ul><p>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;参考記事： <a href=\"https://qiita.com/sam8helloworld/items/e7fffa9afc82aea68a7a\" target=\"_blank\" rel=\"noopener noreferrer\">docker-compose.ymlのbuild設定はとりあえずcontextもdockerfileも埋めとけって話 - Qiita</a> <br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>volumes:</code>  </li></ul><p>&nbsp;&nbsp;ホスト側の <code>./src/</code>をコンテナ側の <code>/app</code> にマウントするという意味になります。   <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※ここで <code>services:</code> の中に書いているこの <code>volumes:</code> は <code>バインドマウント</code> を行っています。    <br>&nbsp;&nbsp;参考記事：<a href=\"https://qiita.com/y518gaku/items/456f34c317a65a9dae86\" target=\"_blank\" rel=\"noopener noreferrer\">Dockerのマウント3種類についてわかったことをまとめる - Qiita</a> <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;何が起きているかは実際の挙動を見てみた方が分かりやすいと思うので、後ほどまた動作確認します。<br></p><h2 id=\"h2043ae13c7\">Dockerfile（PHP）</h2><p>Dockerfileはテキストファイルであり、Dockerイメージを作り上げるために実行する命令をこのファイルに書きます。<br><br>作成するDockerfileの全文がこちらです。</p><pre><code>FROM php:8.0-fpm\n\nENV TZ Asia/Tokyo\n\nRUN apt-get update &amp;&amp; \\\n\tapt-get install -y git unzip libzip-dev libicu-dev libonig-dev &amp;&amp; \\\n\tdocker-php-ext-install intl pdo_mysql zip bcmath\n\nCOPY ./docker/app/php.ini /usr/local/etc/php/php.ini\nCOPY --from=composer:2.0 /usr/bin/composer /usr/bin/composer\n\nWORKDIR /app</code></pre><p><br>一つずつ説明します。<br></p><pre><code>FROM php:8.0-fpm</code></pre><p><br>&nbsp;<code>FROM</code>ではイメージをビルドするためのベースイメージを設定します。  <br>書き方は <code>FROM イメージ名:タグ名</code> です。  <br>ここではDocker HubからPHP公式のイメージをベースとして指定しています。<br><a href=\"https://hub.docker.com/_/php\" target=\"_blank\" rel=\"noopener noreferrer\">Php - Official Image | Docker Hub</a> <br></p><pre><code>ENV TZ Asia/Tokyo</code></pre><p><br>&nbsp;<code>ENV</code>はコンテナ内のサーバー環境変数を設定します。  <br></p><pre><code>RUN apt-get update &amp;&amp; \\\n    apt-get install -y git unzip libzip-dev libicu-dev libonig-dev &amp;&amp; \\\n\tdocker-php-ext-install intl pdo_mysql zip bcmath</code></pre><p><br>&nbsp;<code>RUN</code> にはコンテナビルド時に実行するコマンドを書きます。  <br>&nbsp;<code>&amp;&amp;</code> で複数のコマンドをつなぎ、 <code>\\</code> で改行します。   <br>※ <code>&amp;&amp;</code> と <code>\\</code> を使うことで複数コマンドを1レイヤーにまとめることができ、公式でもベストプラクティスのTipsとして挙げられています。   <br><a href=\"https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/#:~:text=Tip%20%233%3A%20Identify%20cacheable%20units%20such%20as%20apt%2Dget%20update%20%26%20install\" target=\"_blank\" rel=\"noopener noreferrer\">Intro Guide to Dockerfile Best Practices - Docker Blog</a> <br><br><code>apt-get update</code> ：インストール可能なパッケージの「一覧」を更新  <br>&nbsp;<code>apt-get -y install</code>：パッケージをインストール  <br>&nbsp;<code>docker-php-ext-install</code>：PHPの拡張ライブラリをインストール  <br>※Laravelのインストールや開発に必要な（もしくは便利な）パッケージや拡張ライブラリをインストールしています。<br>※試しにこれらを全くインストールせず手順を進めてみると、コンテナを起動することはできますが、その後のLaravelプロジェクトを作成する時に大量のエラーに遭遇しました…（笑）<br></p><pre><code>COPY ./docker/app/php.ini /usr/local/etc/php/php.ini</code></pre><p><br>ローカルで（後ほど）作成する <code>php.ini</code> （PHPの設定ファイル）をDockerコンテナ内にコピーします。  <br>書き方は <code>COPY [ローカル側のパス] [コンテナ側のパス]</code>です。  <br><br>※ローカル側のパスは、Dockerfileから見てではなくbuildコマンドを実行するディレクトリから見た相対パスです。今回はDocker composeを使ってイメージビルドを行うので、docker-compose.ymlから見た相対パスになっています。<br></p><pre><code>COPY --from=composer:2.0 /usr/bin/composer /usr/bin/composer</code></pre><p><br>Laravelを使うためComposerをインストールします。<br>この書き方により<strong>マルチステージビルド</strong>という方法でインストールされます。 <br>※マルチステージビルドという方法はイメージの軽量化に役立つようです。 <br>公式ドキュメント：<a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\" target=\"_blank\" rel=\"noopener noreferrer\">Use multi-stage builds</a> <br></p><pre><code>WORKDIR /app</code></pre><p><br>コンテナを起動している時に <code>$ docker-compose exec コンテナ名 bash</code> というコマンドを実行すると、コンテナの中でbashを実行することができるのですが、 <code>WORKDIR</code>はその時のカレントディレクトリを指定しています。   <br></p><h2 id=\"h559c05704d\"> 設定ファイル（php.ini）</h2><p>&nbsp;<code>COPY ./docker/app/php.ini /usr/local/etc/php/php.ini</code> で出てきたPHPの設定ファイル <code>php.ini</code>を作成します。   <br><br>作成したファイルの中身がこちらです。<br></p><pre><code>zend.exception_ignore_args = off\nexpose_php = on\nmax_execution_time = 30\nmax_input_vars = 1000\nupload_max_filesize = 64M\npost_max_size = 128M\nmemory_limit = 256M\nerror_reporting = E_ALL\ndisplay_errors = on\ndisplay_startup_errors = on\nlog_errors = on\nerror_log = /var/log/php/php-error.log\ndefault_charset = UTF-8\n\n[Date]\ndate.timezone = Asia/Tokyo\n\n[mysqlnd]\nmysqlnd.collect_memory_statistics = on\n\n[Assertion]\nzend.assertions = 1\n\n[mbstring]\nmbstring.language = Japanese</code></pre><p><br>こちらの記事の開発用php.iniをまるっとお借りしました。<br>開発用 / 本番用の設定例と、項目ごとの説明も載っていて面白かったので、ぜひご覧ください。<br>参考記事：<a href=\"https://qiita.com/ucan-lab/items/0d74378e1b9ba81699a9\" target=\"_blank\" rel=\"noopener noreferrer\">PHP7.4 ぼくのかんがえたさいきょうのphp.ini - Qiita</a> <br></p><h2 id=\"h2c3fab92b5\"> PHPコンテナを起動する</h2><p><br>ここまででPHPのコンテナの準備が出来たので、実際に起動してみます。<br><br>docker-sompose.ymlのあるディレクトリで以下のコマンドを実行します。<br></p><pre><code>$ docker-compose up -d --build</code></pre><p><br></p><ul><li> <code>docker compose up</code> は <code>docker-compose.yml</code> に定義したサービスを起動します。   </li><li>  <code>-d</code>デタッチド」モードでコンテナを起動します。</li></ul><p>&nbsp;&nbsp;（デフォルトは「アタッチド」モードで全てのコンテナログを画面上に表示する。「デタッチド」モードではバックグラウンドで動作する。）<br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>--build</code> コンテナの開始前にイメージをビルドします。  </li></ul><p>&nbsp;&nbsp;（特に変更がない場合はキャッシュが使用される。）<br>&nbsp;&nbsp;&nbsp;<br>※ <code>$ docker-compose build</code> → <code>$ docker-compose up -d</code> を順に行うのと同じです。   <br></p><h3 id=\"hbdb8067534\"> 起動したコンテナを確認する</h3><p>以下のコマンドで起動中のコンテナを一覧で確認することができます。<br></p><pre><code>$ docker-compose ps\n\nNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORTS\ndocker_sample-app-1&nbsp;&nbsp;\"docker-php-entrypoi…\"&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9000/tcp</code></pre><p><br>STATUSがrunningになっていれば正常に起動しています。<br><br>今はPHPのコンテナしか作っていないので1つだけ表示されていますが、この後nginx, MySQLのコンテナを作り、最終的に3つのコンテナが表示されるようにします。<br><br>ここで今作業しているディレクトリの構成を確認してみます。<br></p><pre><code>$ tree\n.\n├── src&nbsp;&nbsp;// 作成された！\n├── docker\n│&nbsp;&nbsp;├── app\n│&nbsp;&nbsp;│&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;│&nbsp;&nbsp;└── php.ini\n└── docker-compose.yml</code></pre><p><br>するとdocker-compose.ymlに書いたバインドマウントの以下の部分を受けて、コンテナを起動したときに自動でsrcディレクトリが作成されたことが確認できます。（同様にコンテナ内にもappディレクトリが作成されています。）<br></p><pre><code>volumes:\n&nbsp;- ./src/:/app</code></pre><p><br></p><h3 id=\"h4353a13706\"> コンテナの中に入ってみる</h3><p><br>コンテナを起動中に以下のコマンドを実行すると、コンテナの中に入ってbashを実行することができます。<br></p><pre><code>$ docker-compose exec app bash\n// appの部分はサービス名を指定する</code></pre><p><br>これで今コンテナの中に入れたので、Dockerfileの記述通りにコンテナが作られているか、またPHP・Composer・インストールした拡張機能が使えるか確認していきます。<br></p><pre><code>// Dockerfileの「WORKDIR /app」で指定したカレントディレクトリ通りか確認\n[app]:/app$ pwd\n/app\n\n// PHPのバージョン確認\n[app]:/app$ php -v\nPHP 8.0.15 (cli) (built: Jan 26 2022 17:38:36) ( NTS )\nCopyright (c) The PHP Group\nZend Engine v4.0.15, Copyright (c) Zend Technologies\n\n// Composerのバージョン確認\n[app]:/app$ composer -v\n&nbsp;&nbsp;______\n&nbsp;/ ____/___&nbsp;____ ___&nbsp;____&nbsp;____&nbsp;________&nbsp;_____\n&nbsp;/ /&nbsp;&nbsp;/ __ \\/ __ `__ \\/ __ \\/ __ \\/ ___/ _ \\/ ___/\n/ /___/ /_/ / / / / / / /_/ / /_/ (__&nbsp;)&nbsp;__/ /\n\\____/\\____/_/ /_/ /_/ .___/\\____/____/\\___/_/\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/_/\nComposer version 2.0.14 2021-05-21 17:03:37\n\n// gitのバージョン確認\n[app]:/app$ git --version\ngit version 2.30.2\n\n// インストール済の拡張機能の一覧\n[app]:/app$ php -m\n[PHP Modules]\nbcmath\nintl\npdo_mysql\nzip\n// たくさん出てくるので他は省略\n\n// php.iniがコピー出来ているか確認\n[app]:/app$ cat /usr/local/etc/php/php.ini\nzend.exception_ignore_args = off\nexpose_php = on\nmax_execution_time = 30\nmax_input_vars = 1000\nupload_max_filesize = 64M\npost_max_size = 128M\nmemory_limit = 256M\nerror_reporting = E_ALL\ndisplay_errors = on\ndisplay_startup_errors = on\nlog_errors = on\nerror_log = /var/log/php/php-error.log\ndefault_charset = UTF-8\n\n[Date]\ndate.timezone = Asia/Tokyo\n\n[mysqlnd]\nmysqlnd.collect_memory_statistics = on\n\n[Assertion]\nzend.assertions = 1\n\n[mbstring]\nmbstring.language = Japaneseroot@0e3ba825df88</code></pre><p><br>確認できたのでコンテナを抜けます。<br></p><pre><code>$ exit\n\n// もしくは ctrl + d</code></pre><p><br></p><h3 id=\"hb30552acef\"> コンテナの外からコマンドを実行する</h3><p>上記のコンテナの中で実行したコマンドは、 <code>$ docker-compose exec サービス名 実行したいコマンド</code> でコンテナの外から実行することもできます。（コンテナが起動中に限る）  <br></p><h3 id=\"hbe7ef0b1fb\"> バインドマウントの挙動を確認する</h3><p>コンテナの外からコマンドが実行できるという確認も兼ねて、バインドマウントの動きを見る為、試しに以下のコマンドを実行してみます。<br></p><pre><code>// コンテナ内の/app配下にファイルを作ってみる\n$ docker-compose exec app touch sample.php\n$ docker-compose exec app pwd\n/app\n$ docker-compose exec app ls\nsample.php</code></pre><p><br>コンテナ内の/app配下にファイルを作成しました。<br><br>この/appという場所は、docker-compose.ymlに書いた以下の記述の通りにバインドマウントされています。<br></p><pre><code>volumes:\n&nbsp;- ./src/:/app</code></pre><p><br>これにより、プロジェクトディレクトリ配下の/srcにもsample.phpが作成されています。<br></p><pre><code>$ ls src\nsample.php</code></pre><p><br>以上より、コンテナ内の <code>/app</code> に対して行ったことが、プロジェクトの <code>/src</code> に反映していることが分かりました。   <br><br>では次に <code>/src</code> への変更がコンテナ内の <code>/app</code> に対しても反映するか試してみます。   <br><br>&nbsp;<code>/src/sample.php</code> をエディタで開いてファイルに <code>hello</code> と書きこみ、以下のコマンドを実行します。   <br></p><pre><code>$ docker-compose exec app cat sample.php\nhello\n\n// この時permission errorが出たら権限を変更する\n$ sudo chmod -R 777 ./src</code></pre><p><br>するとコンテナ内の <code>./app/sample.php</code> も編集されていることがわかります。  <br><br>このようにバインドマウントにより、ホスト側のディレクトリがコンテナ内へマウント出来ていることも確認できました。<br><br>試しに作成したファイルは不要なので消しておきます。<br></p><pre><code>$ rm src/sample.php</code></pre><p><br></p><h1 id=\"h3a503e139b\"> nginxのコンテナ（webサーバー）</h1><p>webサーバーとなるnginxのコンテナを作成します。<br><br>PHPコンテナのときと同じく、<br></p><ul><li> docker-compose.ymlへの記述</li><li> nginxコンテナ用のDockerfile</li><li> nginxコンテナ用の設定ファイル（default.conf）</li></ul><p><br>の流れで説明します。<br></p><h2 id=\"hc888d0dee3\"> docker-compose.yml（nginx）</h2><p><br>既に作成しているdocker-compose.ymlに、nginxのコンテナについての部分を追記します。<br></p><pre><code>services:\n&nbsp;api:\n\n// 中略\n\t\n&nbsp;web:&nbsp;&nbsp;// サービス名\n&nbsp;&nbsp;build:\n&nbsp;&nbsp;&nbsp;context: .\n&nbsp;&nbsp;&nbsp;dockerfile: ./docker/web/Dockerfile\n&nbsp;&nbsp;ports:\n&nbsp;&nbsp;&nbsp;- 8081:80\n&nbsp;&nbsp;depends_on:\n&nbsp;&nbsp;&nbsp;- app\n&nbsp;&nbsp;volumes:\n&nbsp;&nbsp;&nbsp;- ./src/:/app</code></pre><p><br>解説していきます。<br></p><ul><li> <code>build:</code> ・<code>volumes:</code>  </li></ul><p>&nbsp;&nbsp;ここはPHPコンテナと同様なので説明は省きます。<br>&nbsp;&nbsp;&nbsp;</p><ul><li><code>ports:</code>  </li></ul><p>&nbsp;&nbsp;ホスト側とコンテナ間のポート番号の対応付けを設定します。<br>&nbsp;&nbsp;書き方は <code>ホスト側のポート番号 : コンテナのポート番号</code>です。  <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※今回ホスト側（自分のPC）は既に他の開発で使っているポートとの兼ね合いで <code>8081</code> を使いました。コンテナ側はnginxのデフォルトのポート番号である <code>80</code> にしています。   <br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>depends_on:</code>  </li></ul><p>&nbsp;&nbsp;サービスの起動順序を制御します。<br>&nbsp;&nbsp;&nbsp;<code>web</code> の <code>depends_on</code> に <code>app</code> と書いているので、 <code>app</code> → <code>web</code> の順に起動するように指定しています。      <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※但しこの記述なしで <code>$ docker-compose up -d --build</code> をしてみても私の環境では全く問題なく動きました。が、サービス同士の依存関係を明示的に記すという意味でも書いておくに越したことはないという判断で書いています。  <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※ nginxとphp間でTCPによるfpm接続についてや、<code>depends_on</code> オプションについては以下の記事がすごく勉強になったので是非読んでみてください。  <br>&nbsp;&nbsp;参考記事：<a href=\"https://qiita.com/haruyanhopemucci/items/344f1e2fb95ed452bdb2#%E5%90%84%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%8C%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E5%90%8D%E3%81%AE%E5%90%8D%E5%89%8D%E8%A7%A3%E6%B1%BA%E3%82%92%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%99%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0\" target=\"_blank\" rel=\"noopener noreferrer\">【docker-compose】dependsonとサービス名解決にまつわるエトセトラ - Qiita</a> <br></p><h2 id=\"h5a107e8b8a\"> Dockerfile（nginx）</h2><p><br>作成するDockerfileの全文はこちらです。<br></p><pre><code>FROM nginx:1.20-alpine\n\nENV TZ Asia/Tokyo\n\nCOPY ./docker/web/default.conf /etc/nginx/conf.d/default.conf</code></pre><p><br>&nbsp;<code>FROM</code> , <code>ENV</code> , <code>COPY</code> の意味はPHPコンテナのDockerfileと同様なので詳しい説明は省略し、このファイルで設定していることを簡単にまとめます。    <br></p><ul><li> nginx公式のイメージ（Alpineベース）をベースイメージに使用</li></ul><p><a href=\"https://hub.docker.com/_/nginx\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx - Official Image | Docker Hub</a> <br>参考記事：<a href=\"https://charlie1012.hatenablog.jp/entry/2021/01/14/090000\" target=\"_blank\" rel=\"noopener noreferrer\">Dockerでよく利用されているAlpineは他のLinuxディストリビューションと比べて、どれだけ軽量なのか - プログラミングは芸術だ！</a>  <br></p><ul><li> 環境変数のタイムゾーンを設定する</li><li> nginxの設定ファイル（default.conf）をコンテナ内にバインドマウント</li></ul><p><br>※ちなみにnginxは1.18, 1.20などの偶数バージョンが安定バージョンであり、安定バージョンの使用を推奨されています。<br>公式ドキュメント：<a href=\"https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#stablevsmainline\" target=\"_blank\" rel=\"noopener noreferrer\">Installing NGINX Open Source</a> <br></p><h2 id=\"h833dd2537f\"> 設定ファイル（default.conf）</h2><p><br><code>./docker/web/default.conf</code>を作成します。  <br>Laravel公式に用意されているnginxの設定例をべースに使います。<br><a href=\"https://readouble.com/laravel/8.x/ja/deployment.html\" target=\"_blank\" rel=\"noopener noreferrer\">Laravel 8.x デプロイ</a> <br><br>&nbsp;<code>root</code> と<code>fastcgi_pass</code>の設定のみ、このプロジェクトに合わせて書き換えています。   <br></p><pre><code>server {\n&nbsp;&nbsp;listen 80;\n&nbsp;&nbsp;server_name example.com;\n&nbsp;&nbsp;root /app/public;&nbsp;&nbsp;// 書き換え\n\n&nbsp;&nbsp;add_header X-Frame-Options \"SAMEORIGIN\";\n&nbsp;&nbsp;add_header X-XSS-Protection \"1; mode=block\";\n&nbsp;&nbsp;add_header X-Content-Type-Options \"nosniff\";\n\n&nbsp;&nbsp;index index.php;\n\n&nbsp;&nbsp;charset utf-8;\n\n&nbsp;&nbsp;location / {\n&nbsp;&nbsp;&nbsp;&nbsp;try_files $uri $uri/ /index.php?$query_string;\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;location = /favicon.ico { access_log off; log_not_found off; }\n&nbsp;&nbsp;location = /robots.txt&nbsp;{ access_log off; log_not_found off; }\n\n&nbsp;&nbsp;error_page 404 /index.php;\n\n&nbsp;&nbsp;location ~ \\.php$ {\n&nbsp;&nbsp;&nbsp;&nbsp;fastcgi_pass app:9000;&nbsp;&nbsp;// 書き換え\n&nbsp;&nbsp;&nbsp;&nbsp;fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\n&nbsp;&nbsp;&nbsp;&nbsp;include fastcgi_params;\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;location ~ /\\.(?!well-known).* {\n&nbsp;&nbsp;&nbsp;&nbsp;deny all;\n&nbsp;&nbsp;}\n}</code></pre><p><br></p><ul><li> <code>root</code> </li></ul><p>リクエストのルートディレクトリです。<br><code>root /app/public;</code> と書いたので、 <code>localhost:8081</code>（docker-compose.ymlで設定したポート番号）にアクセスすると <code>/app/public</code>を見に行きます。   <br></p><ul><li> <code>fastcgi_pas</code></li></ul><p>FastCGIサーバーのアドレスです。<br>※FastCGI：Webサーバ上で動くプログラムを一度起動したらしばらく待機させることによって、プログラムの開始と終了にかかる手間を減らし、動きを速くしたりWebサーバの負荷を軽減することができる仕組み。<br><code>app:9000;</code> と書いたので、appコンテナの9000番ポートを指定しています。  <br></p><h2 id=\"hf271decc8d\"> nginxコンテナを起動する</h2><p>nginxのコンテナの準備が出来たので、また実際に起動してみます。<br><br>docker-sompose.ymlのあるディレクトリで以下のコマンドを実行します。<br></p><pre><code>$ docker-compose up -d --build\n\n$ docker-compose ps\nNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORTS\ndocker_sample-app-1&nbsp;&nbsp;\"docker-php-entrypoi…\"&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9000/tcp\ndocker_sample-web-1&nbsp;&nbsp;\"/docker-entrypoint.…\"&nbsp;&nbsp;web&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0.0.0:8081-&gt;80/tcp</code></pre><p><br>api（PHPのコンテナ）、web（nginxのコンテナ）の2つが起動できました。<br><br>またdocker_sample-web-1の <code>PORTS</code> が <code>0.0.0.0:8081-&gt;80/tcp</code> となっており、ホスト上の8081番ポートをコンテナの80番ポートへ割り当てられていることも確認できます。   <br></p><h3 id=\"h8f15037b6a\"> コンテナの動作確認</h3><p><br>nginxのバージョンを確認します。<br></p><pre><code>$ docker-compose exec web nginx -v\nnginx version: nginx/1.20.2</code></pre><p><br>コンテナの中に入ってみます。<br></p><pre><code>$ docker-compose exec web bash\nOCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \"bash\": executable file not found in $PATH: unknown</code></pre><p><br>するとエラーになりました。<br>Alpineをベースとすると <code>bash</code> は使えず、 <code>ash</code> や <code>sh</code> は使えるようです。    <br></p><pre><code>$ docker-compose exec web ash\n[web]:/ $ pwd\n/</code></pre><p><br>無事コンテナの中に入れました。<br></p><h3 id=\"h88903227dd\"> webサーバーとしての動作確認</h3><p><br></p><ul><li> リクエストに対してファイルを返しブラウザで表示できる</li><li> nginxのコンテナからPHPのコンテナへphpを実行させることができる</li></ul><p><br>上記2点を確認します。<br></p><pre><code>$ mkdir src/public\n$ touch src/public/test.php</code></pre><p><br>test.phpを以下のように編集します。<br></p><pre><code>&lt;?php&nbsp;\n\necho 'test.phpです';\nphpinfo();</code></pre><p><br><code>http://localhost:8081/test.php</code> にアクセスすると以下のように表示され、webサーバーが正しく動作していることが確認できます。  <br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/b84369391f704cafb9636049a0ac8e40/testphp.jpeg\" alt=\"\"><br>試しに作成したファイルは不要なので消しておきます。<br></p><pre><code>$ rm -rf src/*</code></pre><p><br></p><h1 id=\"h92f102c3c7\"> MySQLのコンテナ（データベース）</h1><p>データベースのMySQLコンテナを作成します。<br><br>以下の流れで説明します。<br></p><ul><li> docker-compose.ymlへの記述</li><li> MySQLコンテナ用のDockerfile</li><li> MySQLコンテナ用の設定ファイル（my.conf）</li></ul><p><br></p><h2 id=\"h6d7ad88963\"> docker-compose.yml（MySQL）</h2><p>既に作成しているdocker-compose.ymlに、MySQLのコンテナについての部分を追記します。<br></p><pre><code>services:\n\t\n// 中略\n\n&nbsp;db:&nbsp;&nbsp;// サービス名\n&nbsp;&nbsp;build:\n&nbsp;&nbsp;&nbsp;context: .\n&nbsp;&nbsp;&nbsp;dockerfile: ./docker/db/Dockerfile\n&nbsp;&nbsp;ports:\n&nbsp;&nbsp;&nbsp;- 3306:3306\n&nbsp;&nbsp;environment:\n&nbsp;&nbsp;&nbsp;MYSQL_DATABASE: database\n&nbsp;&nbsp;&nbsp;MYSQL_USER: user\n&nbsp;&nbsp;&nbsp;MYSQL_PASSWORD: password\n&nbsp;&nbsp;&nbsp;MYSQL_ROOT_PASSWORD: password\n&nbsp;&nbsp;&nbsp;TZ: 'Asia/Tokyo'\n&nbsp;&nbsp;volumes:\n&nbsp;&nbsp;&nbsp;- mysql-volume:/var/lib/mysql\n&nbsp;&nbsp;&nbsp;&nbsp;\nvolumes:\n&nbsp;mysql-volume:</code></pre><p><br></p><ul><li> <code>build:</code> ・ <code>ports:</code>   </li></ul><p>&nbsp;&nbsp;既出の通りです。<br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>enviroment:</code>  </li></ul><p>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;環境変数の設定です。<br>&nbsp;&nbsp;※名前やDB名・ユーザー名・パスワードは好きなものを設定します。<br>&nbsp;&nbsp;※実際のプロジェクト管理では、環境変数は <code>.env</code> に書いて <code>.gitignore</code> にするなどして、重要な情報が公開されないようにします。   <br>&nbsp;&nbsp;&nbsp;</p><ul><li> MYSQL_DATABASE：DB名</li><li> MYSQL_USER：ユーザー名</li><li> MYSQL_PASSWORD：パスワード</li><li> MYSQL_ROO<em>ROOT</em>WORD：ルート権限のパスワード</li><li> TZ：時間設定（Time Zone）</li></ul><p>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>volumes:</code>  </li></ul><p>&nbsp;&nbsp;考え方はPHPやnginxのコンテナ同様ですが、先ほどまではホスト側のディレクトリを書いていたところに <code>mysql-volume</code> と書いています。  <br>&nbsp;&nbsp;これにより `mysql-colume` という名前で作成した<strong>名前付きボリューム</strong>とコンテナ内を紐づけています。 <br></p><h3 id=\"h755cef0747\"> Docker Volume</h3><p>&nbsp;<code>Volume</code>  とは、<strong>コンテナを破棄してもデータを永続的に保存できる</strong>ように、コンテナ外に提供されているデータの保存領域です。 <br>Dockerの管理下でホスト上にストレージ領域を確保しており、Linux なら <code>/var/lib/docker/volumes/</code>以下にあります。  <br>参考記事：<a href=\"unsafe:Volume\">Docker、ボリューム(Volume)について真面目に調べた - Qiita</a> <br><br>&nbsp;<strong>なぜVolumeが必要なのか？</strong> <br>コンテナが起動している間はDBのレコードは保存された状態が続きますが、例えば以下のようなコマンドでコンテナを新しく作り直したとするとデータベースの情報はゼロに戻ってしまいます。<br></p><pre><code>// コンテナ削除\n$ docker-compose down\n\n// コンテナ起動\n$ docker-compose up -d</code></pre><p><br>これでは困るのでコンテナを破棄してもデータを残したい、、、というときにVolumesを使ってデータの永続化を行います。<br><br>※ボリュームには名前付きボリュームと匿名ボリュームがありますが、通常は管理しやすい名前付きボリュームを使うと良いかと思います。<br><br>名前付きボリュームを作成する場合は、データの永続化対象のコンテナに対して <code>volumes:</code> オプションでバインドマウントを行うだけでなく、以下のようにdocker-compose.ymlのトップレベルでボリューム名を定義します。  <br></p><pre><code>volumes:\n&nbsp;- mysql-volume:</code></pre><p><br></p><h2 id=\"h7541a8019d\"> Dockerfile（MySQL）</h2><p>作成するDockerfileの全文はこちらです。<br></p><pre><code>FROM mysql:8.0\n\nCOPY ./docker/db/my.cnf /etc/my.cnf</code></pre><p><br>内容を簡単にまとめると、</p><ul><li> 公式のMySQLイメージをベースイメージに使用</li></ul><p>[Mysql - Official Image | Docker Hub](https://hub.docker.com/_/mysql)</p><ul><li> MySQLの設定ファイル（my.cnf）をコンテナ内にバインドマウント</li></ul><p><br>※ここで使用しているイメージではM1 Macでは動作しないという情報が見られました。どうやらOracleのMySQLチームがメンテしている <code>mysql/mysql-server</code> のイメージだと動作するようです。  <br><a href=\"https://hub.docker.com/r/mysql/mysql-server\" target=\"_blank\" rel=\"noopener noreferrer\">mysql-server&nbsp;| Docker Hub</a> <br></p><h2 id=\"h1fb4ed6e13\"> 設定ファイル（my.conf）</h2><p><code>./docker/db/my.cnf</code>を作成します。  <br><br>色んな記事で作成されているmy.cnfを参考にさせていただきながら書きました。<br>参考記事：<a href=\"https://it-blue-collar-dairy.com/mysqlondocker-compose/\" target=\"_blank\" rel=\"noopener noreferrer\">【Docker】docker-composeでmysqlのコンテナを立てる</a> <br></p><ul><li> 文字コード</li><li> タイムゾーン</li><li> ログ</li></ul><p><br>の設定を行っています。<br></p><pre><code>[mysqld]\n# character\ncharacter_set_server = utf8mb4\ncollation_server = utf8mb4_0900_ai_ci\n\n# timezone\ndefault-time-zone = SYSTEM\nlog_timestamps = SYSTEM\n\n# Error Log\nlog-error = mysql-error.log\n\n# Slow Query Log\nslow_query_log = 1\nslow_query_log_file = mysql-slow.log\nlong_query_time = 1.0\nlog_queries_not_using_indexes = 0\n\n# General Log\ngeneral_log = 1\ngeneral_log_file = mysql-general.log\n\n[mysql]\ndefault-character-set = utf8mb4\n\n[client]\ndefault-character-set = utf8mb4</code></pre><p><br></p><h2 id=\"h067ee63297\"> MySQLコンテナを起動する</h2><p>MySQLのコンテナの準備が出来たので、また実際に起動してみます。<br><br>docker-sompose.ymlのあるディレクトリで以下のコマンドを実行します。</p><pre><code>$ docker-compose up -d --build\n\n$ docker-compose ps\nNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORTS\ndocker_sample-app-1&nbsp;&nbsp;\"docker-php-entrypoi…\"&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9000/tcp\ndocker_sample-db-1&nbsp;&nbsp;\"docker-entrypoint.s…\"&nbsp;&nbsp;db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0.0.0:3306-&gt;3306/tcp\ndocker_sample-web-1&nbsp;&nbsp;\"/docker-entrypoint.…\"&nbsp;&nbsp;web&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0.0.0:8081-&gt;80/tcp</code></pre><p><br>api（PHPのコンテナ）、web（nginxのコンテナ）、db（MySQLのコンテナ）の3つが起動できました。<br></p><h3 id=\"h42e7c9d39f\">コンテナの動作確認</h3><p>MySQLのバージョンを確認します。<br></p><pre><code>$ docker compose exec db mysql -V\nmysql&nbsp;Ver 8.0.28 for Linux on x86_64 (MySQL Community Server - GPL)</code></pre><p><br>※この後Laravelのプロジェクトを作成したら、このDBとLaravelを接続します。<br>そしてマイグレーションを行ってDBにテーブルを作成してから、MySQLにログインしてDBを使う動作確認をしたいと思います。<br></p><h1 id=\"hd865058a4e\"> Laravelのインストール</h1><h2 id=\"h6742e995c9\"> Laravelプロジェクトの作成</h2><p><br>LEMP環境が構築できたので、Laravelのアプリケーションを作っていきます。<br><br>appコンテナに入り、Laravelをインストールします。<br></p><pre><code>$ docker compose exec app bash\n[app]:/app$ composer create-project --prefer-dist \"laravel/laravel=8.*\" .\n[app]:/app$ php artisan -v\nLaravel Framework 8.81.0</code></pre><p><br>コンテナ内の/app配下にLaravelのプロジェクトが新規作成され、ホスト側の/src配下にも同じくLaravelのプロジェクトが出来ました。<br><br><code>localhost:8081</code>にアクセスして、ブラウザでもLaravelのウェルカムページが表示できることを確認します。  <br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/6328bcf6dfe64db7aff89f42adf30e00/laravel.jpeg\" alt=\"\"></p><h2 id=\"h33b0e81c46\"> DB接続</h2><p>appコンテナ（Laravel）からdbコンテナ（MySQL）へ接続する設定を行います。<br><br>Laravelではデータベースへの接続設定を <code>.env</code> ファイルに定義しているので、 <code>/src/.env</code> のDBの部分を以下のように修正します。   <br></p><pre><code>DB_CONNECTION=mysql\nDB_HOST=db&nbsp;&nbsp;// MySQLコンテナのサービス名\nDB_PORT=3306\nDB_DATABASE=database\nDB_USERNAME=root\nDB_PASSWORD=passwor</code></pre><p><br></p><ul><li>  <code>DB_HOST</code>はMySQLコンテナのサービス名を指定します。 </li><li> その他の項目もMySQLコンテナで設定した値（今回はdocker-compose.ymlのenviromentで定義）と同じ値を指定します。</li></ul><p><br>DBに接続出来ているか確認する為、以下のコマンドを実行してマイグレーションを行います。<br></p><pre><code>$ docker compose exec app bash\n[app]:/app$ php artisan migrate\nMigration table created successfully.\nMigrating: 2014_10_12_000000_create_users_table\nMigrated:&nbsp;2014_10_12_000000_create_users_table (55.42ms)\nMigrating: 2014_10_12_100000_create_password_resets_table\nMigrated:&nbsp;2014_10_12_100000_create_password_resets_table (51.11ms)\nMigrating: 2019_08_19_000000_create_failed_jobs_table\nMigrated:&nbsp;2019_08_19_000000_create_failed_jobs_table (45.12ms)\nMigrating: 2019_12_14_000001_create_personal_access_tokens_table\nMigrated:&nbsp;2019_12_14_000001_create_personal_access_tokens_table (75.74ms)</code></pre><p><br></p><h2 id=\"hf98e955142\"> MySQLを使ってみる</h2><p>MySQLのコンテナに入ってDBを確認してみます。<br></p><pre><code>$ docker-compose exec db bash\n[db]:/$ mysql -u root -p\n// パスワードを求められるので入力\n[db] mysql&gt; use database;\n[db] mysql&gt; show tables;\n+------------------------+\n| Tables_in_database&nbsp;&nbsp;&nbsp;|\n+------------------------+\n| failed_jobs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n| migrations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n| password_resets&nbsp;&nbsp;&nbsp;&nbsp;|\n| personal_access_tokens |\n| users&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n+------------------------+\n5 rows in set (0.00 sec)</code></pre><p><br>先ほどマイグレーションを実行したので、Laravelのデフォルトで用意されているマイグレーションファイル通りにテーブルが作成されていることが確認できました。<br></p><h2 id=\"h9b4c4b9dd7\"> 最後に</h2><p>これでDocker（Docker Compose）を使ったLEMP環境の構築が完了です。<br><br>今回作成した環境は非常にシンプルなものなので、業務で使うとなるともっと設定を細やかに行ったり、開発環境・ステージング環境・本番環境それぞれの設定ファイルを用意して設定を切り替えたりといった作業が必要になるかと思いますが、仕組みが分かればあとは全てこの延長にあるのかなと思います。<br><br>またいずれ環境ごとの設定ファイル切り替えだったり、あとはNodeのコンテナを使ってNext.jsの環境構築もやってみたいです。<br></p><h2 id=\"h3937880ed1\"> 参考記事</h2><p><br><a href=\"https://yutaro-blog.net/2021/04/29/docker-laravel-vuejs-2/\" target=\"_blank\" rel=\"noopener noreferrer\">https://yutaro-blog.net/2021/04/29/docker-laravel-vuejs-2/</a><br><br><a href=\"https://yutaro-blog.net/2021/04/30/docker-laravel-vuejs-3/#index_id11\" target=\"_blank\" rel=\"noopener noreferrer\">https://yutaro-blog.net/2021/04/30/docker-laravel-vuejs-3/#index_id11</a><br><br><a href=\"https://qiita.com/ucan-lab/items/56c9dc3cf2e6762672f4\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com/ucan-lab/items/56c9dc3cf2e6762672f4</a><br></p>","tags":[{"id":"docker","createdAt":"2022-02-12T02:32:18.767Z","updatedAt":"2022-02-12T10:02:36.384Z","publishedAt":"2022-02-12T02:32:18.767Z","revisedAt":"2022-02-12T10:02:36.384Z","tag":"Docker"},{"id":"laravel","createdAt":"2022-01-07T13:17:32.553Z","updatedAt":"2022-02-12T02:31:33.697Z","publishedAt":"2022-01-07T13:17:32.553Z","revisedAt":"2022-01-07T13:17:38.700Z","tag":"Laravel"},{"id":"php","createdAt":"2022-01-07T13:16:36.618Z","updatedAt":"2022-02-12T02:31:46.498Z","publishedAt":"2022-01-07T13:16:36.618Z","revisedAt":"2022-01-07T13:16:36.618Z","tag":"PHP"}],"image":"docker"},"highlightedBody":"<html><head></head><body><p>Docker, Docker Compose を使って、<code>PHP（Laravel） + nginx + MySQL</code>の<code>LEMP環境</code>を構築する記事です。   <br><br>検索するとDockerfileやdocker-compose.ymlの書き方については色んな方が記事を書いてくださっていて、動く環境を作ること自体は難しくありませんでした。<br><br>ですが、筆者はひとつコンテナを作っては動作確認していくという過程を経てすごく理解が深まったなと思うので、ファイルの書き方だけでなく動作確認したことやその結果を含めて記事に残しておきたいと思います。<br><br>↓　完成後のリポジトリはこちらです。<br><a href=\"unsafe:[object Object]\">https://github.com/hinakonagao/laravel_docker</a><br><br></p><h1 id=\"hdb194e8fef\"> 全体像</h1><p>最終的なディレクトリ構成は以下の通りです。<br><br>全コンテナを管理するdocker-compose.ymlがトップレベルにあり、同じくトップレベルにあるdockerディレクトリ配下に各コンテナのDockerfileや設定ファイルを置いています。</p><pre><code class=\"hljs\">docker_sample/\n├── src&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> Laravelプロジェクトのソースコード\n├── docker\n│&nbsp;&nbsp;├── app&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> PHPコンテナ\n│&nbsp;&nbsp;│&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;│&nbsp;&nbsp;└── php.ini\n│&nbsp;&nbsp;├── db&nbsp;&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> MySQLコンテナ\n│&nbsp;&nbsp;│&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;│&nbsp;&nbsp;└── my.cnf\n│&nbsp;&nbsp;└── web&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> nginxコンテナ\n│&nbsp;&nbsp;&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;&nbsp;&nbsp;└── default.conf\n└──&nbsp;docker-compose.yml&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> 全コンテナの管理</code></pre><p><br><br>早速一つずつコンテナを作っていきます。<br></p><h1 id=\"h949dc20ce4\">PHPのコンテナ（Laravelの開発環境）</h1><p>まずはLaravelの開発環境を構築するための、PHPのコンテナを作成します。<br></p><ul><li> docker-compose.ymlへの記述</li><li> PHPコンテナ用のDockerfile</li><li> PHPコンテナ用の設定ファイル（php.ini）</li></ul><p><br>について順に説明します。<br></p><h2 id=\"hce39c12d7b\"> docker-compose.yml（PHP）</h2><p><br>docker-compose.ymlのうち、PHPコンテナについての記述は以下の通りです。<br>※docker-compose.ymlはインデントが意味を持つので注意。</p><pre><code class=\"hljs\"><span class=\"hljs-symbol\">version:</span> <span class=\"hljs-string\">\"3.9\"</span>\n<span class=\"hljs-symbol\">\nservices:</span>\n<span class=\"hljs-symbol\">&nbsp;app:</span>&nbsp;&nbsp;<span class=\"hljs-comment\">// サービス名</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;build:</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;&nbsp;context:</span> .\n<span class=\"hljs-symbol\">&nbsp;&nbsp;&nbsp;dockerfile:</span> .<span class=\"hljs-keyword\">/docker/</span>app/Dockerfile\n<span class=\"hljs-symbol\">&nbsp;&nbsp;volumes:</span>\n&nbsp;&nbsp;&nbsp;- .<span class=\"hljs-keyword\">/src/</span>:/app</code></pre><p><br></p><ul><li> <code>version:</code></li></ul><p>&nbsp;&nbsp;これはPHPコンテナについてではなく <code>docker-compose.yml</code> の先頭に書く設定ですが、Composeファイルのバージョンを表しています。  <br>&nbsp;&nbsp;今回は最新の `3.9` を使います。（最新のバージョンは下記の公式サイトを参照）<br>&nbsp;&nbsp;<a href=\"https://docs.docker.com/compose/compose-file/\" target=\"_blank\" rel=\"noopener noreferrer\">Compose file</a> <br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>build:</code>  </li></ul><p>&nbsp;&nbsp;ビルドコンテキストを指定します。</p><ul><li> context：ビルドコンテキスト（buildを実行する場所）の設定</li><li> dockerfile：buildするDockerfileまでのパス（docker-compose.ymlから見た相対パス）</li></ul><p>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;参考記事： <a href=\"https://qiita.com/sam8helloworld/items/e7fffa9afc82aea68a7a\" target=\"_blank\" rel=\"noopener noreferrer\">docker-compose.ymlのbuild設定はとりあえずcontextもdockerfileも埋めとけって話 - Qiita</a> <br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>volumes:</code>  </li></ul><p>&nbsp;&nbsp;ホスト側の <code>./src/</code>をコンテナ側の <code>/app</code> にマウントするという意味になります。   <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※ここで <code>services:</code> の中に書いているこの <code>volumes:</code> は <code>バインドマウント</code> を行っています。    <br>&nbsp;&nbsp;参考記事：<a href=\"https://qiita.com/y518gaku/items/456f34c317a65a9dae86\" target=\"_blank\" rel=\"noopener noreferrer\">Dockerのマウント3種類についてわかったことをまとめる - Qiita</a> <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;何が起きているかは実際の挙動を見てみた方が分かりやすいと思うので、後ほどまた動作確認します。<br></p><h2 id=\"h2043ae13c7\">Dockerfile（PHP）</h2><p>Dockerfileはテキストファイルであり、Dockerイメージを作り上げるために実行する命令をこのファイルに書きます。<br><br>作成するDockerfileの全文がこちらです。</p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">FROM</span> php:<span class=\"hljs-number\">8.0</span>-fpm\n\nENV TZ Asia/Tokyo\n\nRUN apt-get update &amp;&amp; \\\n\tapt-get install -y git unzip libzip-dev libicu-dev libonig-dev &amp;&amp; \\\n\tdocker-php-ext-install intl pdo_mysql zip bcmath\n\n<span class=\"hljs-keyword\">COPY</span> .<span class=\"hljs-regexp\">/docker/</span>app<span class=\"hljs-regexp\">/php.ini /u</span>sr<span class=\"hljs-regexp\">/local/</span>etc<span class=\"hljs-regexp\">/php/</span>php.ini\n<span class=\"hljs-keyword\">COPY</span> --<span class=\"hljs-keyword\">from</span>=composer:<span class=\"hljs-number\">2.0</span> <span class=\"hljs-regexp\">/usr/</span>bin<span class=\"hljs-regexp\">/composer /u</span>sr<span class=\"hljs-regexp\">/bin/</span>composer\n\nWORKDIR /app</code></pre><p><br>一つずつ説明します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-attribute\">FROM</span> php:<span class=\"hljs-number\">8</span>.<span class=\"hljs-number\">0</span>-fpm</code></pre><p><br>&nbsp;<code>FROM</code>ではイメージをビルドするためのベースイメージを設定します。  <br>書き方は <code>FROM イメージ名:タグ名</code> です。  <br>ここではDocker HubからPHP公式のイメージをベースとして指定しています。<br><a href=\"https://hub.docker.com/_/php\" target=\"_blank\" rel=\"noopener noreferrer\">Php - Official Image | Docker Hub</a> <br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">ENV</span> TZ Asia/Tokyo</code></pre><p><br>&nbsp;<code>ENV</code>はコンテナ内のサーバー環境変数を設定します。  <br></p><pre><code class=\"hljs\">RUN apt-<span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">update</span> &amp;&amp; \\\n    apt-<span class=\"hljs-built_in\">get</span> install -y git unzip libzip-<span class=\"hljs-built_in\">dev</span> libicu-<span class=\"hljs-built_in\">dev</span> libonig-<span class=\"hljs-built_in\">dev</span> &amp;&amp; \\\n\tdocker-php-ext-install intl pdo_mysql zip bcmath</code></pre><p><br>&nbsp;<code>RUN</code> にはコンテナビルド時に実行するコマンドを書きます。  <br>&nbsp;<code>&amp;&amp;</code> で複数のコマンドをつなぎ、 <code>\\</code> で改行します。   <br>※ <code>&amp;&amp;</code> と <code>\\</code> を使うことで複数コマンドを1レイヤーにまとめることができ、公式でもベストプラクティスのTipsとして挙げられています。   <br><a href=\"https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/#:~:text=Tip%20%233%3A%20Identify%20cacheable%20units%20such%20as%20apt%2Dget%20update%20%26%20install\" target=\"_blank\" rel=\"noopener noreferrer\">Intro Guide to Dockerfile Best Practices - Docker Blog</a> <br><br><code>apt-get update</code> ：インストール可能なパッケージの「一覧」を更新  <br>&nbsp;<code>apt-get -y install</code>：パッケージをインストール  <br>&nbsp;<code>docker-php-ext-install</code>：PHPの拡張ライブラリをインストール  <br>※Laravelのインストールや開発に必要な（もしくは便利な）パッケージや拡張ライブラリをインストールしています。<br>※試しにこれらを全くインストールせず手順を進めてみると、コンテナを起動することはできますが、その後のLaravelプロジェクトを作成する時に大量のエラーに遭遇しました…（笑）<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">COPY</span> .<span class=\"hljs-regexp\">/docker/</span>app<span class=\"hljs-regexp\">/php.ini /u</span>sr<span class=\"hljs-regexp\">/local/</span>etc<span class=\"hljs-regexp\">/php/</span>php.ini</code></pre><p><br>ローカルで（後ほど）作成する <code>php.ini</code> （PHPの設定ファイル）をDockerコンテナ内にコピーします。  <br>書き方は <code>COPY [ローカル側のパス] [コンテナ側のパス]</code>です。  <br><br>※ローカル側のパスは、Dockerfileから見てではなくbuildコマンドを実行するディレクトリから見た相対パスです。今回はDocker composeを使ってイメージビルドを行うので、docker-compose.ymlから見た相対パスになっています。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">COPY</span> --<span class=\"hljs-keyword\">from</span>=composer:<span class=\"hljs-number\">2.0</span> <span class=\"hljs-regexp\">/usr/</span>bin<span class=\"hljs-regexp\">/composer /u</span>sr<span class=\"hljs-regexp\">/bin/</span>composer</code></pre><p><br>Laravelを使うためComposerをインストールします。<br>この書き方により<strong>マルチステージビルド</strong>という方法でインストールされます。 <br>※マルチステージビルドという方法はイメージの軽量化に役立つようです。 <br>公式ドキュメント：<a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\" target=\"_blank\" rel=\"noopener noreferrer\">Use multi-stage builds</a> <br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></code></pre><p><br>コンテナを起動している時に <code>$ docker-compose exec コンテナ名 bash</code> というコマンドを実行すると、コンテナの中でbashを実行することができるのですが、 <code>WORKDIR</code>はその時のカレントディレクトリを指定しています。   <br></p><h2 id=\"h559c05704d\"> 設定ファイル（php.ini）</h2><p>&nbsp;<code>COPY ./docker/app/php.ini /usr/local/etc/php/php.ini</code> で出てきたPHPの設定ファイル <code>php.ini</code>を作成します。   <br><br>作成したファイルの中身がこちらです。<br></p><pre><code class=\"hljs\"><span class=\"hljs-attr\">zend.exception_ignore_args</span> = <span class=\"hljs-literal\">off</span>\n<span class=\"hljs-attr\">expose_php</span> = <span class=\"hljs-literal\">on</span>\n<span class=\"hljs-attr\">max_execution_time</span> = <span class=\"hljs-number\">30</span>\n<span class=\"hljs-attr\">max_input_vars</span> = <span class=\"hljs-number\">1000</span>\n<span class=\"hljs-attr\">upload_max_filesize</span> = <span class=\"hljs-number\">64</span>M\n<span class=\"hljs-attr\">post_max_size</span> = <span class=\"hljs-number\">128</span>M\n<span class=\"hljs-attr\">memory_limit</span> = <span class=\"hljs-number\">256</span>M\n<span class=\"hljs-attr\">error_reporting</span> = E_ALL\n<span class=\"hljs-attr\">display_errors</span> = <span class=\"hljs-literal\">on</span>\n<span class=\"hljs-attr\">display_startup_errors</span> = <span class=\"hljs-literal\">on</span>\n<span class=\"hljs-attr\">log_errors</span> = <span class=\"hljs-literal\">on</span>\n<span class=\"hljs-attr\">error_log</span> = /var/log/php/php-error.log\n<span class=\"hljs-attr\">default_charset</span> = UTF-<span class=\"hljs-number\">8</span>\n\n<span class=\"hljs-section\">[Date]</span>\n<span class=\"hljs-attr\">date.timezone</span> = Asia/Tokyo\n\n<span class=\"hljs-section\">[mysqlnd]</span>\n<span class=\"hljs-attr\">mysqlnd.collect_memory_statistics</span> = <span class=\"hljs-literal\">on</span>\n\n<span class=\"hljs-section\">[Assertion]</span>\n<span class=\"hljs-attr\">zend.assertions</span> = <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-section\">[mbstring]</span>\n<span class=\"hljs-attr\">mbstring.language</span> = Japanese</code></pre><p><br>こちらの記事の開発用php.iniをまるっとお借りしました。<br>開発用 / 本番用の設定例と、項目ごとの説明も載っていて面白かったので、ぜひご覧ください。<br>参考記事：<a href=\"https://qiita.com/ucan-lab/items/0d74378e1b9ba81699a9\" target=\"_blank\" rel=\"noopener noreferrer\">PHP7.4 ぼくのかんがえたさいきょうのphp.ini - Qiita</a> <br></p><h2 id=\"h2c3fab92b5\"> PHPコンテナを起動する</h2><p><br>ここまででPHPのコンテナの準備が出来たので、実際に起動してみます。<br><br>docker-sompose.ymlのあるディレクトリで以下のコマンドを実行します。<br></p><pre><code class=\"hljs\">$ docker-compose up -d <span class=\"hljs-comment\">--build</span></code></pre><p><br></p><ul><li> <code>docker compose up</code> は <code>docker-compose.yml</code> に定義したサービスを起動します。   </li><li>  <code>-d</code>デタッチド」モードでコンテナを起動します。</li></ul><p>&nbsp;&nbsp;（デフォルトは「アタッチド」モードで全てのコンテナログを画面上に表示する。「デタッチド」モードではバックグラウンドで動作する。）<br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>--build</code> コンテナの開始前にイメージをビルドします。  </li></ul><p>&nbsp;&nbsp;（特に変更がない場合はキャッシュが使用される。）<br>&nbsp;&nbsp;&nbsp;<br>※ <code>$ docker-compose build</code> → <code>$ docker-compose up -d</code> を順に行うのと同じです。   <br></p><h3 id=\"hbdb8067534\"> 起動したコンテナを確認する</h3><p>以下のコマンドで起動中のコンテナを一覧で確認することができます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-variable\">$</span> docker<span class=\"hljs-literal\">-compose</span> <span class=\"hljs-built_in\">ps</span>\n\nNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORTS\ndocker_sample<span class=\"hljs-literal\">-app-1</span>&nbsp;&nbsp;<span class=\"hljs-string\">\"docker-php-entrypoi…\"</span>&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-number\">9000</span>/tcp</code></pre><p><br>STATUSがrunningになっていれば正常に起動しています。<br><br>今はPHPのコンテナしか作っていないので1つだけ表示されていますが、この後nginx, MySQLのコンテナを作り、最終的に3つのコンテナが表示されるようにします。<br><br>ここで今作業しているディレクトリの構成を確認してみます。<br></p><pre><code class=\"hljs\">$ tree\n.\n├── src&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> 作成された！\n├── docker\n│&nbsp;&nbsp;├── app\n│&nbsp;&nbsp;│&nbsp;&nbsp;├── Dockerfile\n│&nbsp;&nbsp;│&nbsp;&nbsp;└── php.ini\n└── docker-compose.yml</code></pre><p><br>するとdocker-compose.ymlに書いたバインドマウントの以下の部分を受けて、コンテナを起動したときに自動でsrcディレクトリが作成されたことが確認できます。（同様にコンテナ内にもappディレクトリが作成されています。）<br></p><pre><code class=\"hljs\">volumes:\n&nbsp;- .<span class=\"hljs-regexp\">/src/</span>:/app</code></pre><p><br></p><h3 id=\"h4353a13706\"> コンテナの中に入ってみる</h3><p><br>コンテナを起動中に以下のコマンドを実行すると、コンテナの中に入ってbashを実行することができます。<br></p><pre><code class=\"hljs\">$ docker-compose exec app bash\n<span class=\"hljs-regexp\">//</span> appの部分はサービス名を指定する</code></pre><p><br>これで今コンテナの中に入れたので、Dockerfileの記述通りにコンテナが作られているか、またPHP・Composer・インストールした拡張機能が使えるか確認していきます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> Dockerfileの「WORKDIR /app」で指定したカレントディレクトリ通りか確認\n[app]:/app$ pwd\n/app\n\n<span class=\"hljs-regexp\">//</span> PHPのバージョン確認\n[app]:/app$ php -v\nPHP <span class=\"hljs-number\">8.0</span>.<span class=\"hljs-number\">15</span> (cli) (built: Jan <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">2022</span> <span class=\"hljs-number\">17</span>:<span class=\"hljs-number\">38</span>:<span class=\"hljs-number\">36</span>) ( NTS )\nCopyright (c) The PHP Group\nZend Engine v4.<span class=\"hljs-number\">0.15</span>, Copyright (c) Zend Technologies\n\n<span class=\"hljs-regexp\">//</span> Composerのバージョン確認\n[app]:/app$ composer -v\n&nbsp;&nbsp;______\n&nbsp;<span class=\"hljs-regexp\">/ ____/</span>___&nbsp;____ ___&nbsp;____&nbsp;____&nbsp;________&nbsp;_____\n&nbsp;<span class=\"hljs-regexp\">/ /</span>&nbsp;&nbsp;<span class=\"hljs-regexp\">/ __ \\/ __ `__ \\/ __ \\/ __ \\/ ___/</span> _ \\<span class=\"hljs-regexp\">/ ___/</span>\n<span class=\"hljs-regexp\">/ /</span>___<span class=\"hljs-regexp\">/ /</span>_<span class=\"hljs-regexp\">/ /</span> <span class=\"hljs-regexp\">/ /</span> <span class=\"hljs-regexp\">/ /</span> <span class=\"hljs-regexp\">/ /</span>_<span class=\"hljs-regexp\">/ /</span> <span class=\"hljs-regexp\">/_/</span> (__&nbsp;)&nbsp;__<span class=\"hljs-regexp\">/ /</span>\n\\____<span class=\"hljs-regexp\">/\\____/</span>_<span class=\"hljs-regexp\">/ /</span>_<span class=\"hljs-regexp\">/ /</span>_<span class=\"hljs-regexp\">/ .___/</span>\\____<span class=\"hljs-regexp\">/____/</span>\\___<span class=\"hljs-regexp\">/_/</span>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-regexp\">/_/</span>\nComposer version <span class=\"hljs-number\">2.0</span>.<span class=\"hljs-number\">14</span> <span class=\"hljs-number\">2021</span>-<span class=\"hljs-number\">05</span>-<span class=\"hljs-number\">21</span> <span class=\"hljs-number\">17</span>:<span class=\"hljs-number\">03</span>:<span class=\"hljs-number\">37</span>\n\n<span class=\"hljs-regexp\">//</span> gitのバージョン確認\n[app]:/app$ git --version\ngit version <span class=\"hljs-number\">2.30</span>.<span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-regexp\">//</span> インストール済の拡張機能の一覧\n[app]:/app$ php -m\n[PHP Modules]\nbcmath\nintl\npdo_mysql\nzip\n<span class=\"hljs-regexp\">//</span> たくさん出てくるので他は省略\n\n<span class=\"hljs-regexp\">//</span> php.iniがコピー出来ているか確認\n[app]:<span class=\"hljs-regexp\">/app$ cat /u</span>sr<span class=\"hljs-regexp\">/local/</span>etc<span class=\"hljs-regexp\">/php/</span>php.ini\nzend.exception_ignore_args = off\nexpose_php = on\nmax_execution_time = <span class=\"hljs-number\">30</span>\nmax_input_vars = <span class=\"hljs-number\">1000</span>\nupload_max_filesize = <span class=\"hljs-number\">64</span>M\npost_max_size = <span class=\"hljs-number\">128</span>M\nmemory_limit = <span class=\"hljs-number\">256</span>M\nerror_reporting = E_ALL\ndisplay_errors = on\ndisplay_startup_errors = on\nlog_errors = on\nerror_log = <span class=\"hljs-regexp\">/var/</span>log<span class=\"hljs-regexp\">/php/</span>php-error.log\ndefault_charset = UTF-<span class=\"hljs-number\">8</span>\n\n[Date]\ndate.timezone = Asia/Tokyo\n\n[mysqlnd]\nmysqlnd.collect_memory_statistics = on\n\n[Assertion]\nzend.assertions = <span class=\"hljs-number\">1</span>\n\n[mbstring]\nmbstring.language = Japaneseroot@<span class=\"hljs-number\">0</span>e3ba825df88</code></pre><p><br>確認できたのでコンテナを抜けます。<br></p><pre><code class=\"hljs\">$ <span class=\"hljs-keyword\">exit</span>\n\n<span class=\"hljs-regexp\">//</span> もしくは ctrl + d</code></pre><p><br></p><h3 id=\"hb30552acef\"> コンテナの外からコマンドを実行する</h3><p>上記のコンテナの中で実行したコマンドは、 <code>$ docker-compose exec サービス名 実行したいコマンド</code> でコンテナの外から実行することもできます。（コンテナが起動中に限る）  <br></p><h3 id=\"hbe7ef0b1fb\"> バインドマウントの挙動を確認する</h3><p>コンテナの外からコマンドが実行できるという確認も兼ねて、バインドマウントの動きを見る為、試しに以下のコマンドを実行してみます。<br></p><pre><code class=\"hljs\">// コンテナ内の/app配下にファイルを作ってみる\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">docker-compose <span class=\"hljs-built_in\">exec</span> app <span class=\"hljs-built_in\">touch</span> sample.php</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">docker-compose <span class=\"hljs-built_in\">exec</span> app <span class=\"hljs-built_in\">pwd</span></span>\n/app\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">docker-compose <span class=\"hljs-built_in\">exec</span> app <span class=\"hljs-built_in\">ls</span></span>\nsample.php</code></pre><p><br>コンテナ内の/app配下にファイルを作成しました。<br><br>この/appという場所は、docker-compose.ymlに書いた以下の記述の通りにバインドマウントされています。<br></p><pre><code class=\"hljs\">volumes:\n&nbsp;- .<span class=\"hljs-regexp\">/src/</span>:/app</code></pre><p><br>これにより、プロジェクトディレクトリ配下の/srcにもsample.phpが作成されています。<br></p><pre><code class=\"hljs\"><span class=\"hljs-variable\">$</span> <span class=\"hljs-built_in\">ls</span> src\nsample.php</code></pre><p><br>以上より、コンテナ内の <code>/app</code> に対して行ったことが、プロジェクトの <code>/src</code> に反映していることが分かりました。   <br><br>では次に <code>/src</code> への変更がコンテナ内の <code>/app</code> に対しても反映するか試してみます。   <br><br>&nbsp;<code>/src/sample.php</code> をエディタで開いてファイルに <code>hello</code> と書きこみ、以下のコマンドを実行します。   <br></p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">docker-compose <span class=\"hljs-built_in\">exec</span> app <span class=\"hljs-built_in\">cat</span> sample.php</span>\nhello\n\n// この時permission errorが出たら権限を変更する\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">sudo <span class=\"hljs-built_in\">chmod</span> -R 777 ./src</span></code></pre><p><br>するとコンテナ内の <code>./app/sample.php</code> も編集されていることがわかります。  <br><br>このようにバインドマウントにより、ホスト側のディレクトリがコンテナ内へマウント出来ていることも確認できました。<br><br>試しに作成したファイルは不要なので消しておきます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">rm</span> src/sample.php</span></code></pre><p><br></p><h1 id=\"h3a503e139b\"> nginxのコンテナ（webサーバー）</h1><p>webサーバーとなるnginxのコンテナを作成します。<br><br>PHPコンテナのときと同じく、<br></p><ul><li> docker-compose.ymlへの記述</li><li> nginxコンテナ用のDockerfile</li><li> nginxコンテナ用の設定ファイル（default.conf）</li></ul><p><br>の流れで説明します。<br></p><h2 id=\"hc888d0dee3\"> docker-compose.yml（nginx）</h2><p><br>既に作成しているdocker-compose.ymlに、nginxのコンテナについての部分を追記します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-symbol\">services:</span>\n<span class=\"hljs-symbol\">&nbsp;api:</span>\n\n<span class=\"hljs-comment\">// 中略</span>\n<span class=\"hljs-symbol\">\t\n&nbsp;web:</span>&nbsp;&nbsp;<span class=\"hljs-comment\">// サービス名</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;build:</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;&nbsp;context:</span> .\n<span class=\"hljs-symbol\">&nbsp;&nbsp;&nbsp;dockerfile:</span> .<span class=\"hljs-keyword\">/docker/</span>web/Dockerfile\n<span class=\"hljs-symbol\">&nbsp;&nbsp;ports:</span>\n&nbsp;&nbsp;&nbsp;- <span class=\"hljs-number\">8081</span>:<span class=\"hljs-number\">80</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;depends_on:</span>\n&nbsp;&nbsp;&nbsp;- app\n<span class=\"hljs-symbol\">&nbsp;&nbsp;volumes:</span>\n&nbsp;&nbsp;&nbsp;- .<span class=\"hljs-keyword\">/src/</span>:/app</code></pre><p><br>解説していきます。<br></p><ul><li> <code>build:</code> ・<code>volumes:</code>  </li></ul><p>&nbsp;&nbsp;ここはPHPコンテナと同様なので説明は省きます。<br>&nbsp;&nbsp;&nbsp;</p><ul><li><code>ports:</code>  </li></ul><p>&nbsp;&nbsp;ホスト側とコンテナ間のポート番号の対応付けを設定します。<br>&nbsp;&nbsp;書き方は <code>ホスト側のポート番号 : コンテナのポート番号</code>です。  <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※今回ホスト側（自分のPC）は既に他の開発で使っているポートとの兼ね合いで <code>8081</code> を使いました。コンテナ側はnginxのデフォルトのポート番号である <code>80</code> にしています。   <br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>depends_on:</code>  </li></ul><p>&nbsp;&nbsp;サービスの起動順序を制御します。<br>&nbsp;&nbsp;&nbsp;<code>web</code> の <code>depends_on</code> に <code>app</code> と書いているので、 <code>app</code> → <code>web</code> の順に起動するように指定しています。      <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※但しこの記述なしで <code>$ docker-compose up -d --build</code> をしてみても私の環境では全く問題なく動きました。が、サービス同士の依存関係を明示的に記すという意味でも書いておくに越したことはないという判断で書いています。  <br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;※ nginxとphp間でTCPによるfpm接続についてや、<code>depends_on</code> オプションについては以下の記事がすごく勉強になったので是非読んでみてください。  <br>&nbsp;&nbsp;参考記事：<a href=\"https://qiita.com/haruyanhopemucci/items/344f1e2fb95ed452bdb2#%E5%90%84%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%8C%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E5%90%8D%E3%81%AE%E5%90%8D%E5%89%8D%E8%A7%A3%E6%B1%BA%E3%82%92%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%99%E3%82%8B%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0\" target=\"_blank\" rel=\"noopener noreferrer\">【docker-compose】dependsonとサービス名解決にまつわるエトセトラ - Qiita</a> <br></p><h2 id=\"h5a107e8b8a\"> Dockerfile（nginx）</h2><p><br>作成するDockerfileの全文はこちらです。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">FROM</span> nginx:<span class=\"hljs-number\">1.20</span>-alpine\n\nENV TZ Asia/Tokyo\n\n<span class=\"hljs-keyword\">COPY</span> .<span class=\"hljs-regexp\">/docker/</span>web<span class=\"hljs-regexp\">/default.conf /</span>etc<span class=\"hljs-regexp\">/nginx/</span>conf.d/<span class=\"hljs-keyword\">default</span>.conf</code></pre><p><br>&nbsp;<code>FROM</code> , <code>ENV</code> , <code>COPY</code> の意味はPHPコンテナのDockerfileと同様なので詳しい説明は省略し、このファイルで設定していることを簡単にまとめます。    <br></p><ul><li> nginx公式のイメージ（Alpineベース）をベースイメージに使用</li></ul><p><a href=\"https://hub.docker.com/_/nginx\" target=\"_blank\" rel=\"noopener noreferrer\">Nginx - Official Image | Docker Hub</a> <br>参考記事：<a href=\"https://charlie1012.hatenablog.jp/entry/2021/01/14/090000\" target=\"_blank\" rel=\"noopener noreferrer\">Dockerでよく利用されているAlpineは他のLinuxディストリビューションと比べて、どれだけ軽量なのか - プログラミングは芸術だ！</a>  <br></p><ul><li> 環境変数のタイムゾーンを設定する</li><li> nginxの設定ファイル（default.conf）をコンテナ内にバインドマウント</li></ul><p><br>※ちなみにnginxは1.18, 1.20などの偶数バージョンが安定バージョンであり、安定バージョンの使用を推奨されています。<br>公式ドキュメント：<a href=\"https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/#stablevsmainline\" target=\"_blank\" rel=\"noopener noreferrer\">Installing NGINX Open Source</a> <br></p><h2 id=\"h833dd2537f\"> 設定ファイル（default.conf）</h2><p><br><code>./docker/web/default.conf</code>を作成します。  <br>Laravel公式に用意されているnginxの設定例をべースに使います。<br><a href=\"https://readouble.com/laravel/8.x/ja/deployment.html\" target=\"_blank\" rel=\"noopener noreferrer\">Laravel 8.x デプロイ</a> <br><br>&nbsp;<code>root</code> と<code>fastcgi_pass</code>の設定のみ、このプロジェクトに合わせて書き換えています。   <br></p><pre><code class=\"hljs\">server {\n&nbsp;&nbsp;listen <span class=\"hljs-number\">80</span>;\n&nbsp;&nbsp;server_name example.com;\n&nbsp;&nbsp;root /app/public;&nbsp;&nbsp;// 書き換え\n\n&nbsp;&nbsp;add_header X-Frame-Options <span class=\"hljs-string\">\"SAMEORIGIN\"</span>;\n&nbsp;&nbsp;add_header X-XSS-Protection <span class=\"hljs-string\">\"1; mode=block\"</span>;\n&nbsp;&nbsp;add_header X-Content-<span class=\"hljs-keyword\">Type</span>-Options <span class=\"hljs-string\">\"nosniff\"</span>;\n\n&nbsp;&nbsp;index index.php;\n\n&nbsp;&nbsp;charset utf-<span class=\"hljs-number\">8</span>;\n\n&nbsp;&nbsp;<span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">/ {\n&nbsp;&nbsp;&nbsp;&nbsp;try_files</span> $uri $uri/ /index.php?$query_string;\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;<span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">= /favicon</span>.ico { access_log off; log_not_found off; }\n&nbsp;&nbsp;<span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">= /robots</span>.txt&nbsp;{ access_log off; log_not_found off; }\n\n&nbsp;&nbsp;error_page <span class=\"hljs-number\">404</span> /index.php;\n\n&nbsp;&nbsp;<span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ \\.php</span>$ {\n&nbsp;&nbsp;&nbsp;&nbsp;fastcgi_pass app:<span class=\"hljs-number\">9000</span>;&nbsp;&nbsp;// 書き換え\n&nbsp;&nbsp;&nbsp;&nbsp;fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\n&nbsp;&nbsp;&nbsp;&nbsp;include fastcgi_params;\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;<span class=\"hljs-keyword\">location</span> <span class=\"hljs-title\">~ /\\.(?!well-known</span>).* {\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">deny</span> all;\n&nbsp;&nbsp;}\n}</code></pre><p><br></p><ul><li> <code>root</code> </li></ul><p>リクエストのルートディレクトリです。<br><code>root /app/public;</code> と書いたので、 <code>localhost:8081</code>（docker-compose.ymlで設定したポート番号）にアクセスすると <code>/app/public</code>を見に行きます。   <br></p><ul><li> <code>fastcgi_pas</code></li></ul><p>FastCGIサーバーのアドレスです。<br>※FastCGI：Webサーバ上で動くプログラムを一度起動したらしばらく待機させることによって、プログラムの開始と終了にかかる手間を減らし、動きを速くしたりWebサーバの負荷を軽減することができる仕組み。<br><code>app:9000;</code> と書いたので、appコンテナの9000番ポートを指定しています。  <br></p><h2 id=\"hf271decc8d\"> nginxコンテナを起動する</h2><p>nginxのコンテナの準備が出来たので、また実際に起動してみます。<br><br>docker-sompose.ymlのあるディレクトリで以下のコマンドを実行します。<br></p><pre><code class=\"hljs\">$ docker-compose up -d <span class=\"hljs-comment\">--build</span>\n\n$ docker-compose ps\nNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORTS\ndocker_sample-app<span class=\"hljs-number\">-1</span>&nbsp;&nbsp;<span class=\"hljs-string\">\"docker-php-entrypoi…\"</span>&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">running</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-number\">9000</span>/tcp\ndocker_sample-web<span class=\"hljs-number\">-1</span>&nbsp;&nbsp;<span class=\"hljs-string\">\"/docker-entrypoint.…\"</span>&nbsp;&nbsp;web&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">running</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>:<span class=\"hljs-number\">8081</span>-&gt;<span class=\"hljs-number\">80</span>/tcp</code></pre><p><br>api（PHPのコンテナ）、web（nginxのコンテナ）の2つが起動できました。<br><br>またdocker_sample-web-1の <code>PORTS</code> が <code>0.0.0.0:8081-&gt;80/tcp</code> となっており、ホスト上の8081番ポートをコンテナの80番ポートへ割り当てられていることも確認できます。   <br></p><h3 id=\"h8f15037b6a\"> コンテナの動作確認</h3><p><br>nginxのバージョンを確認します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">docker-compose <span class=\"hljs-built_in\">exec</span> web nginx -v</span>\nnginx version: nginx/1.20.2</code></pre><p><br>コンテナの中に入ってみます。<br></p><pre><code class=\"hljs\">$ docker-compose <span class=\"hljs-keyword\">exec</span> web bash\nOCI runtime <span class=\"hljs-keyword\">exec</span> failed: <span class=\"hljs-keyword\">exec</span> failed: container_linux.go:<span class=\"hljs-number\">380</span>: starting <span class=\"hljs-keyword\">container</span> process caused: <span class=\"hljs-keyword\">exec</span>: <span class=\"hljs-string\">\"bash\"</span>: executable <span class=\"hljs-keyword\">file</span> not found <span class=\"hljs-keyword\">in</span> $PATH: unknown</code></pre><p><br>するとエラーになりました。<br>Alpineをベースとすると <code>bash</code> は使えず、 <code>ash</code> や <code>sh</code> は使えるようです。    <br></p><pre><code class=\"hljs\">$ docker-compose exec web ash\n[<span class=\"hljs-symbol\">web</span>]:<span class=\"hljs-link\">/ $ pwd</span>\n/</code></pre><p><br>無事コンテナの中に入れました。<br></p><h3 id=\"h88903227dd\"> webサーバーとしての動作確認</h3><p><br></p><ul><li> リクエストに対してファイルを返しブラウザで表示できる</li><li> nginxのコンテナからPHPのコンテナへphpを実行させることができる</li></ul><p><br>上記2点を確認します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> src/public</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">touch</span> src/public/test.php</span></code></pre><p><br>test.phpを以下のように編集します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-meta\">&lt;?php</span>&nbsp;\n\n<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">'test.phpです'</span>;\n<span class=\"hljs-title function_ invoke__\">phpinfo</span>();</code></pre><p><br><code>http://localhost:8081/test.php</code> にアクセスすると以下のように表示され、webサーバーが正しく動作していることが確認できます。  <br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/b84369391f704cafb9636049a0ac8e40/testphp.jpeg\" alt=\"\"><br>試しに作成したファイルは不要なので消しておきます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-variable\">$</span> <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">-rf</span> src/*</code></pre><p><br></p><h1 id=\"h92f102c3c7\"> MySQLのコンテナ（データベース）</h1><p>データベースのMySQLコンテナを作成します。<br><br>以下の流れで説明します。<br></p><ul><li> docker-compose.ymlへの記述</li><li> MySQLコンテナ用のDockerfile</li><li> MySQLコンテナ用の設定ファイル（my.conf）</li></ul><p><br></p><h2 id=\"h6d7ad88963\"> docker-compose.yml（MySQL）</h2><p>既に作成しているdocker-compose.ymlに、MySQLのコンテナについての部分を追記します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-attribute\">services</span><span class=\"hljs-punctuation\">:\n\t</span>\n// 中略\n\n&nbsp;db:&nbsp;&nbsp;// サービス名\n&nbsp;&nbsp;<span class=\"hljs-attribute\">build</span><span class=\"hljs-punctuation\">:</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">context</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">.</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">dockerfile</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">./docker/db/Dockerfile</span>\n&nbsp;&nbsp;<span class=\"hljs-attribute\">ports</span><span class=\"hljs-punctuation\">:</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">3306:3306</span>\n&nbsp;&nbsp;<span class=\"hljs-attribute\">environment</span><span class=\"hljs-punctuation\">:</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">MYSQL_DATABASE</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">database</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">MYSQL_USER</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">user</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">MYSQL_PASSWORD</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">password</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">MYSQL_ROOT_PASSWORD</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">password</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-attribute\">TZ</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">'Asia/Tokyo'</span>\n&nbsp;&nbsp;<span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">mysql-volume:/var/lib/mysql</span>\n&nbsp;&nbsp;&nbsp;&nbsp;\n<span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n&nbsp;<span class=\"hljs-attribute\">mysql-volume</span><span class=\"hljs-punctuation\">:</span></code></pre><p><br></p><ul><li> <code>build:</code> ・ <code>ports:</code>   </li></ul><p>&nbsp;&nbsp;既出の通りです。<br>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>enviroment:</code>  </li></ul><p>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;環境変数の設定です。<br>&nbsp;&nbsp;※名前やDB名・ユーザー名・パスワードは好きなものを設定します。<br>&nbsp;&nbsp;※実際のプロジェクト管理では、環境変数は <code>.env</code> に書いて <code>.gitignore</code> にするなどして、重要な情報が公開されないようにします。   <br>&nbsp;&nbsp;&nbsp;</p><ul><li> MYSQL_DATABASE：DB名</li><li> MYSQL_USER：ユーザー名</li><li> MYSQL_PASSWORD：パスワード</li><li> MYSQL_ROO<em>ROOT</em>WORD：ルート権限のパスワード</li><li> TZ：時間設定（Time Zone）</li></ul><p>&nbsp;&nbsp;&nbsp;</p><ul><li> <code>volumes:</code>  </li></ul><p>&nbsp;&nbsp;考え方はPHPやnginxのコンテナ同様ですが、先ほどまではホスト側のディレクトリを書いていたところに <code>mysql-volume</code> と書いています。  <br>&nbsp;&nbsp;これにより `mysql-colume` という名前で作成した<strong>名前付きボリューム</strong>とコンテナ内を紐づけています。 <br></p><h3 id=\"h755cef0747\"> Docker Volume</h3><p>&nbsp;<code>Volume</code>  とは、<strong>コンテナを破棄してもデータを永続的に保存できる</strong>ように、コンテナ外に提供されているデータの保存領域です。 <br>Dockerの管理下でホスト上にストレージ領域を確保しており、Linux なら <code>/var/lib/docker/volumes/</code>以下にあります。  <br>参考記事：<a href=\"unsafe:Volume\">Docker、ボリューム(Volume)について真面目に調べた - Qiita</a> <br><br>&nbsp;<strong>なぜVolumeが必要なのか？</strong> <br>コンテナが起動している間はDBのレコードは保存された状態が続きますが、例えば以下のようなコマンドでコンテナを新しく作り直したとするとデータベースの情報はゼロに戻ってしまいます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> コンテナ削除\n$ docker-compose down\n\n<span class=\"hljs-regexp\">//</span> コンテナ起動\n$ docker-compose up -d</code></pre><p><br>これでは困るのでコンテナを破棄してもデータを残したい、、、というときにVolumesを使ってデータの永続化を行います。<br><br>※ボリュームには名前付きボリュームと匿名ボリュームがありますが、通常は管理しやすい名前付きボリュームを使うと良いかと思います。<br><br>名前付きボリュームを作成する場合は、データの永続化対象のコンテナに対して <code>volumes:</code> オプションでバインドマウントを行うだけでなく、以下のようにdocker-compose.ymlのトップレベルでボリューム名を定義します。  <br></p><pre><code class=\"hljs\"><span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n&nbsp;<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">mysql-volume:</span></code></pre><p><br></p><h2 id=\"h7541a8019d\"> Dockerfile（MySQL）</h2><p>作成するDockerfileの全文はこちらです。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">FROM</span> mysql:<span class=\"hljs-number\">8.0</span>\n\n<span class=\"hljs-keyword\">COPY</span> .<span class=\"hljs-regexp\">/docker/</span>db<span class=\"hljs-regexp\">/my.cnf /</span>etc/my.cnf</code></pre><p><br>内容を簡単にまとめると、</p><ul><li> 公式のMySQLイメージをベースイメージに使用</li></ul><p>[Mysql - Official Image | Docker Hub](https://hub.docker.com/_/mysql)</p><ul><li> MySQLの設定ファイル（my.cnf）をコンテナ内にバインドマウント</li></ul><p><br>※ここで使用しているイメージではM1 Macでは動作しないという情報が見られました。どうやらOracleのMySQLチームがメンテしている <code>mysql/mysql-server</code> のイメージだと動作するようです。  <br><a href=\"https://hub.docker.com/r/mysql/mysql-server\" target=\"_blank\" rel=\"noopener noreferrer\">mysql-server&nbsp;| Docker Hub</a> <br></p><h2 id=\"h1fb4ed6e13\"> 設定ファイル（my.conf）</h2><p><code>./docker/db/my.cnf</code>を作成します。  <br><br>色んな記事で作成されているmy.cnfを参考にさせていただきながら書きました。<br>参考記事：<a href=\"https://it-blue-collar-dairy.com/mysqlondocker-compose/\" target=\"_blank\" rel=\"noopener noreferrer\">【Docker】docker-composeでmysqlのコンテナを立てる</a> <br></p><ul><li> 文字コード</li><li> タイムゾーン</li><li> ログ</li></ul><p><br>の設定を行っています。<br></p><pre><code class=\"hljs\"><span class=\"hljs-section\">[mysqld]</span>\n<span class=\"hljs-comment\"># character</span>\n<span class=\"hljs-attr\">character_set_server</span> = utf8mb4\n<span class=\"hljs-attr\">collation_server</span> = utf8mb<span class=\"hljs-number\">4_0900_</span>ai_ci\n\n<span class=\"hljs-comment\"># timezone</span>\n<span class=\"hljs-attr\">default-time-zone</span> = SYSTEM\n<span class=\"hljs-attr\">log_timestamps</span> = SYSTEM\n\n<span class=\"hljs-comment\"># Error Log</span>\n<span class=\"hljs-attr\">log-error</span> = mysql-error.log\n\n<span class=\"hljs-comment\"># Slow Query Log</span>\n<span class=\"hljs-attr\">slow_query_log</span> = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-attr\">slow_query_log_file</span> = mysql-slow.log\n<span class=\"hljs-attr\">long_query_time</span> = <span class=\"hljs-number\">1.0</span>\n<span class=\"hljs-attr\">log_queries_not_using_indexes</span> = <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-comment\"># General Log</span>\n<span class=\"hljs-attr\">general_log</span> = <span class=\"hljs-number\">1</span>\n<span class=\"hljs-attr\">general_log_file</span> = mysql-general.log\n\n<span class=\"hljs-section\">[mysql]</span>\n<span class=\"hljs-attr\">default-character-set</span> = utf8mb4\n\n<span class=\"hljs-section\">[client]</span>\n<span class=\"hljs-attr\">default-character-set</span> = utf8mb4</code></pre><p><br></p><h2 id=\"h067ee63297\"> MySQLコンテナを起動する</h2><p>MySQLのコンテナの準備が出来たので、また実際に起動してみます。<br><br>docker-sompose.ymlのあるディレクトリで以下のコマンドを実行します。</p><pre><code class=\"hljs\">$ docker-compose up -d <span class=\"hljs-comment\">--build</span>\n\n$ docker-compose ps\nNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SERVICE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STATUS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORTS\ndocker_sample-app<span class=\"hljs-number\">-1</span>&nbsp;&nbsp;<span class=\"hljs-string\">\"docker-php-entrypoi…\"</span>&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">running</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-number\">9000</span>/tcp\ndocker_sample-db<span class=\"hljs-number\">-1</span>&nbsp;&nbsp;<span class=\"hljs-string\">\"docker-entrypoint.s…\"</span>&nbsp;&nbsp;db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">running</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>:<span class=\"hljs-number\">3306</span>-&gt;<span class=\"hljs-number\">3306</span>/tcp\ndocker_sample-web<span class=\"hljs-number\">-1</span>&nbsp;&nbsp;<span class=\"hljs-string\">\"/docker-entrypoint.…\"</span>&nbsp;&nbsp;web&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">running</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>:<span class=\"hljs-number\">8081</span>-&gt;<span class=\"hljs-number\">80</span>/tcp</code></pre><p><br>api（PHPのコンテナ）、web（nginxのコンテナ）、db（MySQLのコンテナ）の3つが起動できました。<br></p><h3 id=\"h42e7c9d39f\">コンテナの動作確認</h3><p>MySQLのバージョンを確認します。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">$ docker compose exec db</span> <span class=\"hljs-comment\">mysql</span> <span class=\"hljs-literal\">-</span><span class=\"hljs-comment\">V</span>\n<span class=\"hljs-comment\">mysql&nbsp;Ver</span> <span class=\"hljs-comment\">8</span><span class=\"hljs-string\">.</span><span class=\"hljs-comment\">0</span><span class=\"hljs-string\">.</span><span class=\"hljs-comment\">28 for Linux on x86_64</span> <span class=\"hljs-comment\">(MySQL</span> <span class=\"hljs-comment\">Community</span> <span class=\"hljs-comment\">Server</span> <span class=\"hljs-literal\">-</span> <span class=\"hljs-comment\">GPL)</span></code></pre><p><br>※この後Laravelのプロジェクトを作成したら、このDBとLaravelを接続します。<br>そしてマイグレーションを行ってDBにテーブルを作成してから、MySQLにログインしてDBを使う動作確認をしたいと思います。<br></p><h1 id=\"hd865058a4e\"> Laravelのインストール</h1><h2 id=\"h6742e995c9\"> Laravelプロジェクトの作成</h2><p><br>LEMP環境が構築できたので、Laravelのアプリケーションを作っていきます。<br><br>appコンテナに入り、Laravelをインストールします。<br></p><pre><code class=\"hljs\">$ <span class=\"hljs-string\">docker</span> <span class=\"hljs-string\">compose</span> <span class=\"hljs-string\">exec</span> <span class=\"hljs-string\">app</span> <span class=\"hljs-string\">bash</span>\n[<span class=\"hljs-string\">app</span>]:/<span class=\"hljs-string\">app</span>$ <span class=\"hljs-string\">composer</span> <span class=\"hljs-built_in\">create-project</span> <span class=\"hljs-built_in\">--prefer-dist</span> <span class=\"hljs-string\">\"laravel/laravel=8.*\"</span> .\n[<span class=\"hljs-string\">app</span>]:/<span class=\"hljs-string\">app</span>$ <span class=\"hljs-string\">php</span> <span class=\"hljs-string\">artisan</span> -<span class=\"hljs-string\">v</span>\n<span class=\"hljs-string\">Laravel</span> <span class=\"hljs-string\">Framework</span> <span class=\"hljs-string\">8</span>.<span class=\"hljs-string\">81</span>.<span class=\"hljs-string\">0</span></code></pre><p><br>コンテナ内の/app配下にLaravelのプロジェクトが新規作成され、ホスト側の/src配下にも同じくLaravelのプロジェクトが出来ました。<br><br><code>localhost:8081</code>にアクセスして、ブラウザでもLaravelのウェルカムページが表示できることを確認します。  <br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/6328bcf6dfe64db7aff89f42adf30e00/laravel.jpeg\" alt=\"\"></p><h2 id=\"h33b0e81c46\"> DB接続</h2><p>appコンテナ（Laravel）からdbコンテナ（MySQL）へ接続する設定を行います。<br><br>Laravelではデータベースへの接続設定を <code>.env</code> ファイルに定義しているので、 <code>/src/.env</code> のDBの部分を以下のように修正します。   <br></p><pre><code class=\"hljs\"><span class=\"hljs-attr\">DB_CONNECTION</span>=mysql\n<span class=\"hljs-attr\">DB_HOST</span>=db&nbsp;&nbsp;// MySQLコンテナのサービス名\n<span class=\"hljs-attr\">DB_PORT</span>=<span class=\"hljs-number\">3306</span>\n<span class=\"hljs-attr\">DB_DATABASE</span>=database\n<span class=\"hljs-attr\">DB_USERNAME</span>=root\n<span class=\"hljs-attr\">DB_PASSWORD</span>=passwor</code></pre><p><br></p><ul><li>  <code>DB_HOST</code>はMySQLコンテナのサービス名を指定します。 </li><li> その他の項目もMySQLコンテナで設定した値（今回はdocker-compose.ymlのenviromentで定義）と同じ値を指定します。</li></ul><p><br>DBに接続出来ているか確認する為、以下のコマンドを実行してマイグレーションを行います。<br></p><pre><code class=\"hljs\">$ docker compose exec app bash\n<span class=\"hljs-section\">[app]:/app$ php artisan migrate</span>\nMigration table created successfully.\n<span class=\"hljs-section\">Migrating: 2014_10_12_000000_create_users_table</span>\n<span class=\"hljs-section\">Migrated:&nbsp;2014_10_12_000000_create_users_table (55.42ms)</span>\n<span class=\"hljs-section\">Migrating: 2014_10_12_100000_create_password_resets_table</span>\n<span class=\"hljs-section\">Migrated:&nbsp;2014_10_12_100000_create_password_resets_table (51.11ms)</span>\n<span class=\"hljs-section\">Migrating: 2019_08_19_000000_create_failed_jobs_table</span>\n<span class=\"hljs-section\">Migrated:&nbsp;2019_08_19_000000_create_failed_jobs_table (45.12ms)</span>\n<span class=\"hljs-section\">Migrating: 2019_12_14_000001_create_personal_access_tokens_table</span>\n<span class=\"hljs-section\">Migrated:&nbsp;2019_12_14_000001_create_personal_access_tokens_table (75.74ms)</span></code></pre><p><br></p><h2 id=\"hf98e955142\"> MySQLを使ってみる</h2><p>MySQLのコンテナに入ってDBを確認してみます。<br></p><pre><code class=\"hljs\">$ docker-compose exec db bash\n[db]:/$ mysql -u root -p\n<span class=\"hljs-comment\">// パスワードを求められるので入力</span>\n[db] mysql&gt; use database;\n[db] mysql&gt; show tables;\n<span class=\"hljs-code\">+------------------------+</span>\n<span class=\"hljs-section\">| Tables_in_database&nbsp;&nbsp;&nbsp;|\n+------------------------+</span>\n| failed<span class=\"hljs-emphasis\">_jobs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n| migrations&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n| password_resets&nbsp;&nbsp;&nbsp;&nbsp;|\n| personal_access_</span>tokens |\n<span class=\"hljs-section\">| users&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|\n+------------------------+</span>\n5 rows in set (0.00 sec)</code></pre><p><br>先ほどマイグレーションを実行したので、Laravelのデフォルトで用意されているマイグレーションファイル通りにテーブルが作成されていることが確認できました。<br></p><h2 id=\"h9b4c4b9dd7\"> 最後に</h2><p>これでDocker（Docker Compose）を使ったLEMP環境の構築が完了です。<br><br>今回作成した環境は非常にシンプルなものなので、業務で使うとなるともっと設定を細やかに行ったり、開発環境・ステージング環境・本番環境それぞれの設定ファイルを用意して設定を切り替えたりといった作業が必要になるかと思いますが、仕組みが分かればあとは全てこの延長にあるのかなと思います。<br><br>またいずれ環境ごとの設定ファイル切り替えだったり、あとはNodeのコンテナを使ってNext.jsの環境構築もやってみたいです。<br></p><h2 id=\"h3937880ed1\"> 参考記事</h2><p><br><a href=\"https://yutaro-blog.net/2021/04/29/docker-laravel-vuejs-2/\" target=\"_blank\" rel=\"noopener noreferrer\">https://yutaro-blog.net/2021/04/29/docker-laravel-vuejs-2/</a><br><br><a href=\"https://yutaro-blog.net/2021/04/30/docker-laravel-vuejs-3/#index_id11\" target=\"_blank\" rel=\"noopener noreferrer\">https://yutaro-blog.net/2021/04/30/docker-laravel-vuejs-3/#index_id11</a><br><br><a href=\"https://qiita.com/ucan-lab/items/56c9dc3cf2e6762672f4\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com/ucan-lab/items/56c9dc3cf2e6762672f4</a><br></p></body></html>"},"__N_SSG":true}
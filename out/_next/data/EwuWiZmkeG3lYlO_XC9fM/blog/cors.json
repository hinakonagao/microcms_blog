{"pageProps":{"blog":{"id":"cors","createdAt":"2022-02-12T11:27:21.400Z","updatedAt":"2022-02-12T11:40:40.611Z","publishedAt":"2021-12-29T11:27:21.000Z","revisedAt":"2022-02-12T11:40:40.611Z","title":"同一オリジンポリシーとCORS","body":"<h2 id=\"hd92040d0df\">きっかけ</h2><p>業務で、Next.jsのフロント側からLaravelのAPIを叩いた時に<strong>CORSエラー</strong>というのが出ました。<br><br>エラー解消法はすぐに見つかったものの、セキュリティやその対策の仕組みについてはきちんと理解して実装したいと思い、色々調べたのでまとめておきます。<br></p><h1 id=\"he84d5455fa\">同一オリジンポリシー</h1><p>CORSについて理解するためには、前提として「同一オリジンポリシー」について知る必要があります。<br></p><h3 id=\"h19b65993c4\">オリジンとは</h3><p>ドメイン＋プロトコル＋ポート番号 を合わせたもの。<br><br>【例】<br>・ドメイン (domain)：yahoo.co.jp<br>・オリジン (origin)：&nbsp;<a style=\"color:#4aac00\" href=\"https://yahoo.co.jp/\" target=\"_blank\" rel=\"noopener noreferrer\">https://yahoo.co.jp:443</a><br></p><h3 id=\"ha2aa5c29c6\">「同一オリジンである」とは</h3><p>ドメイン・プロトコル・ポート番号の全てが一致している場合のこと。<br></p><h3 id=\"h583e348ae7\">同一オリジンポリシー（Same-Origin Policy）とは</h3><p>MDNには以下のように書いてあります。<br></p><blockquote><strong>同一オリジンポリシー</strong>は重要なセキュリティの仕組みであり、ある<a style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Glossary/Origin\" target=\"_blank\" rel=\"noopener noreferrer\">オリジン</a>によって読み込まれた文書やスクリプトが、他のオリジンにあるリソースにアクセスできる方法を制限するものです。<br><a style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener noreferrer\">同一オリジンポリシー - ウェブセキュリティ | MDN</a><br><br></blockquote><p>要するに、別のオリジンへのアクセスに制限をかけることで、XSSやCSRFといった攻撃を防ぐことを目的とするセキュリティの仕組みです。<br><br>XSSとCSRFについてそれぞれの詳しい攻撃手法はここでは取り上げませんが、対策を講じる上での要点を挙げておきます。<br></p><h3 id=\"hafaeffc4cb\">XSS (Cross Site Scripting)</h3><p>ユーザーが 意図しない不正なスクリプトが&nbsp;Webサーバーに送られ、Webサーバーからのレスポンスを受け取ってしまった結果<strong>クライアント側 (Web ブラウザ)</strong>&nbsp;で実行される攻撃。<br><br>ブラウザ上で出来ることは何でも悪用対象になるので、CSRFより攻撃範囲が広い。<br></p><h3 id=\"hc9f9aae59b\"><strong>CSRF (Cross-Site Request Forgeries)</strong></h3><p>ユーザーが意図しない不正なスクリプトがWebサーバーに送られ、&nbsp;<strong>Web アプリケーション (Web サーバー)</strong>&nbsp;上で実行される攻撃。通称「しーさーふ」。<br><br>悪用内容はサーバー側で用意された処理に限定されるが、&nbsp;<strong>サーバーにリクエストが到達するだけで攻撃が成立する</strong>ので、XSS対策はできていてもCSRF対策は出来ていないということもあり得る。<br><br><br>JavaScript の組み込み API でありAjax 通信を実現する&nbsp;<code>XMLHttpRequest (XHR)</code>&nbsp;や&nbsp;<code>Fetch API</code>&nbsp;などは、これらの脆弱性を回避するため<strong>同一オリジンポリシー</strong>（別のオリジンへのアクセスに制限をかける仕組み）に従っています。<br>XSSとCSRFについての詳細は、以下の記事が分かりやすく勉強になりました。<br><a href=\"https://qiita.com/att55/items/a50ca43adde206017525\" target=\"_blank\" rel=\"noopener noreferrer\">XSS と CSRF って結局何が違うのか？ - Qiita</a><br></p><h1 id=\"h027a034520\">CORS</h1><p>同一オリジンポリシーについて抑えたところで、CORSについて見ていきます。<br></p><h2 id=\"hac1783c7e1\">CORSとは</h2><p>読み方：コルス or シーオーアールエス<br><strong>C</strong>ross-<strong>O</strong>rigin&nbsp;<strong>R</strong>esource&nbsp;<strong>S</strong>haring の略で、日本語訳すると「<strong>オリジン間リソース共有</strong>」。<br><br>CORSは、あるオリジンで動いているWebアプリケーションから別のオリジンのサーバーへのアクセスを許可する仕組みです。<br><br>同一オリジンポリシーにより別のオリジンにはアクセスが出来ないという規制があるが、Web開発・制作では異なるオリジンにアクセスしたいケースもある…　<br>そこで、同一オリジンポリシーの制約を回避・緩和してくれるのがCORSです。<br><br>歴史をたどるとCORSが必要になった経緯がさらによく分かります。<br></p><h3 id=\"h3aecdd16f5\">同一オリジンポリシーはあるが、CORSはない場合…（過去のブラウザ）</h3><p>出来たこと</p><ul><li>同一オリジンポリシーによりJavaScriptの安全性は確保される。</li></ul><p><br>生まれた課題</p><ul><li>Ajaxの普及・発展により、異なるオリジン（主に異なるホスト）のAPIを呼び出したいという動機が生まれた。</li><li>JSONPなど同一オリジンポリシーの範囲内で異なるオリジンのAPIを呼び出す方法が考案されたが、裏技のようなものであって安全性には課題が残っていた。</li></ul><p><br></p><h3 id=\"h510870a262\">そこで生まれたCORS</h3><p>上記のような課題を解決するため生まれたCORSは、以下の機能を提供します。<br></p><ul><li>クロスオリジンのアクセスを許可</li><li>オリジン単位でのアクセス制御が可能（例：オリジンA・オリジンBとの通信のみ許可する）</li><li>HTTPヘッダを用いてアクセス制御を行う</li></ul><p><br></p><h2 id=\"h922d87a02b\">CORSはどうやってクロスオリジン通信を許可するのか</h2><p>以下のように事前に通信を行う双方で設定を行っておくことで、クロスオリジンの通信が可能になります。<br></p><ul><li>クライアントサイド</li></ul><p>HTTPリクエストヘッダに<code>Originヘッダ</code>を付ける。<br><br>・XHRの場合：自動でOriginヘッダが付くので何もしなくて良い<br>・FetchAPIの場合：mode: cors を付与する<br></p><ul><li>サーバーサイド</li></ul><p>HTTPレスポンスヘッダに以下を付ける。<br>※レスポンスヘッダを付ける方法は環境によって様々です。<br>Laravelの場合は、Laravel7.0以降は<strong><code>config/cors.php</code></strong>&nbsp;を使ってCORSの設定ができます。<br><br><strong>＊必須＊</strong><br>・<code>Access-Control-Allow-Origin: アクセス元のオリジン</code><br><strong>＊必要な場合のみ＊</strong><br>・Access-Control-Allow-Credentials: true（Cookieを送信する場合は必要）<br>・Access-Control-Allow-Headers<br>・Access-Control-Request-Method<br>・Access-Control-Max-Age<br></p><h2 id=\"h6562eef876\">CORSによるアクセス制御の流れ</h2><p>実際にCORSがアクセス制御を行う流れを、ブラウザの検証ツールのネットワークを観察して確認します。<br><br>【前提】<br>・フロント側（Next.js）をlocalhost:3001、API（Laravel）をlocalhost:8080で開発中。<br>・localhost:3001のフロント側から、localhost:8080/logoutというURLにアクセスしてAPIをたたき、クロスオリジンの通信を発生させる。<br>・リクエストはXHRにより行うので、リクエストヘッダには自動的にOriginヘッダが付く。<br>・localhost:3001からのリクエストがあった場合は、レスポンスヘッダにAccess-Control-Allow-Originを載せるように、事前にAPI側で設定している。<br><br>【実際の流れ】<br>1.　ブラウザでlocalhost:3001にアクセスする。<br>2.　localhots:3001からlocalhost:8080/logoutへHTTPリクエストを送る。<br>　&lt;ポイント&gt; リクエストヘッダのOriginという項目に、リクエスト元のドメイン情報が載せられる。</p><pre><code>Origin: http://localhost:3001</code></pre><p>3.　レスポンスが返ってきたら、localhost:3001はlocalhost:8080からのレスポンスヘッダを見て、レスポンスを受け取るかどうか判断する。<br>　&lt;ポイント&gt;　レスポンスヘッダに&nbsp;<code>Access-Control-Allow-Origin</code>&nbsp;という項目があり、自分のドメイン情報（localhost:3001）が載せられていればレスポンスを受け取る。</p><pre><code>// レスポンスヘッダに以下の記載があれば、レスポンスを受け取る\nAccess-Control-Allow-Origin：http://localhost:3001</code></pre><h3 id=\"h5d7a611c3a\"><br>CORSエラーを起こしてみる</h3><p>上記の例では、事前にAPI側（Laravelのconfig/cors.php）でlocalhost:3001からのリクエストに対してAccess-Control-Allow-Originを返す設定をしていた為、クロスオリジンの通信が成立していました。<br><br>試しにAPI側で設定を行っている箇所を削除してみると、レスポンスヘッダに&nbsp;<code>Access-Control-Allow-Origin：http://localhost:3001</code>&nbsp;が無いので、CORSエラーが起こります。<br><br>ここでのエラーは、リクエスト自体は送っているけれど、レスポンスが返って来た時にそれを受け取らず<strong>レスポンスエラー</strong>ということになっています。<br></p><h2 id=\"h119f62b8ee\">プリフライトリクエスト</h2><h3 id=\"hf8c9fef3ec\">無条件でリクエストが飛んでも大丈夫なのか？</h3><p>CORSの設定をしていないとエラーが発生して通信は成立しませんでしたが、そのエラーはあくまで<strong>レスポンスを受け取らない</strong>というものでした。<br><br>しかし、そもそもリクエストが飛んで良いのか？という懸念が残ります。<br><br>代表的なリスクがCSRFです。<br>&nbsp;<strong>CSRFではレスポンスを受け取る必要は無く、リクエストが送信できれば攻撃できます。</strong><br><br>このようなリスク対策として、プリフライトリクエストが生まれました。<br></p><h3 id=\"hbcb48602bc\">プリフライトリクエストの考え方</h3><ul><li>元々CORSが無いときにできていたクロスオリジンのリクエストに対して、大幅なリスク増にならない条件であれば、XHR等で無条件にクロスオリジンのリクエストを送信できるようにした。</li><li>「大幅なリスク増にならない」条件を単純リクエストとして定義した。</li><li>単純リクエストの要件を超える場合は、実際のリクエストを送る前にプリフライトリクエストを送り、実際のリクエストを送信して問題無いか事前に確認する。</li><li>プリフライトリクエストを挟むことで、プリフライトリクエストを送信した結果Access-Control-Allow-OriginのHTTPヘッダがついたレスポンスが返されなければ、実際のリクエストは送信しない、というように悪意あるリクエストを防ぐ。</li></ul><p><br></p><h3 id=\"he303012d4a\">単純リクエスト（Simple Request）の要件</h3><p>以下の要件を全て満たす場合のみ、単純リクエストとなります。<br></p><ul><li>メソッドは「GET, POST, HEAD」のいずれか</li><li>設定できるリクエストヘッダは以下のいずれか<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type（条件付き）</li></ul></li><li>Content-Typeについては以下のいずれかを満たすこと<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data（ファイルアップロードに使う）</li></ul></li><li>text/plain（滅多に使わない）</li></ul><p><br></p><h2 id=\"ha214098e44\">まとめ</h2><ul><li>XSSやCSRFなどの対策として、他のオリジンへのアクセスを制限する「同一オリジンポリシー」という仕組みがある。</li><li>他のオリジンへアクセスしたい、でも安全性も保ちたい、、を叶えるためCORSが生まれた。</li><li>通常のCORSはレスポンスが届いたときにレスポンスを受け取るかどうかの制御を行うので、リクエスト自体は無条件に飛んでしまう。そこで不正なリクエストが送られてしまうリスク対策として、プリフライトリクエストが生まれた。</li></ul><p><br></p><h2 id=\"h3bcda3e6b0\">最後に</h2><p>エラーが解消されて動けばOKではなく、きちんと仕組みを調べてみてかなり理解が深まったかなと思います。（もし誤りがあれば是非ご指摘いただけると幸いです…！！）<br><br>これまでHTTPリクエストヘッダやレスポンスヘッダをまじまじと見たことも無かったので、Ajax通信を行っている箇所で検証ツールを確認してみると面白かったです。<br>確かにOriginやAccess-Control-Allow-Originがあったり、プリフライトリクエストが送られてレスポンスが返って来てから本番のリクエストが送られているのが確認できて、勉強になりました。<br>セキュリティ対策についてしっかり理解できていなくても動くアプリを作ることが出来てしまうというのは怖いことだなと思うので、これからもセキュリティの勉強はしていきたいと思います。<br></p><h2 id=\"he45680f0bc\">参考記事</h2><p><br><a href=\"https://developer.mozilla.org/ja/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener noreferrer\">オリジン間リソース共有 (CORS) - HTTP | MDN</a><br><br><a href=\"https://labor.ewigleere.net/2020/10/13/cors_preflight_request_verification/\" target=\"_blank\" rel=\"noopener noreferrer\">CORS の挙動の観察と preflight request の検証</a><br><br><a href=\"https://it-web-life.com/javascript_cors_preflight/\" target=\"_blank\" rel=\"noopener noreferrer\">【CORS】JavaScriptにおけるCORSやPreflightを理解する</a><br><br><a href=\"https://programmer-life.work/html_css/html-request\" target=\"_blank\" rel=\"noopener noreferrer\">HTTPリクエストとは？HTTPリクエストを目で確認したい | Programmer LifeHTTPリクエストとは？HTTPリクエストを目...</a><br><br><a href=\"https://qiita.com/att55/items/2154a8aad8bf1409db2b\" target=\"_blank\" rel=\"noopener noreferrer\">なんとなく CORS がわかる...はもう終わりにする。 - Qiita</a><br></p>","tags":[{"id":"web","createdAt":"2022-01-07T13:19:12.628Z","updatedAt":"2022-02-12T02:32:09.404Z","publishedAt":"2022-01-07T13:19:12.628Z","revisedAt":"2022-01-07T13:19:12.628Z","tag":"Web"}],"image":"other"},"highlightedBody":"<html><head></head><body><h2 id=\"hd92040d0df\">きっかけ</h2><p>業務で、Next.jsのフロント側からLaravelのAPIを叩いた時に<strong>CORSエラー</strong>というのが出ました。<br><br>エラー解消法はすぐに見つかったものの、セキュリティやその対策の仕組みについてはきちんと理解して実装したいと思い、色々調べたのでまとめておきます。<br></p><h1 id=\"he84d5455fa\">同一オリジンポリシー</h1><p>CORSについて理解するためには、前提として「同一オリジンポリシー」について知る必要があります。<br></p><h3 id=\"h19b65993c4\">オリジンとは</h3><p>ドメイン＋プロトコル＋ポート番号 を合わせたもの。<br><br>【例】<br>・ドメイン (domain)：yahoo.co.jp<br>・オリジン (origin)：&nbsp;<a style=\"color:#4aac00\" href=\"https://yahoo.co.jp/\" target=\"_blank\" rel=\"noopener noreferrer\">https://yahoo.co.jp:443</a><br></p><h3 id=\"ha2aa5c29c6\">「同一オリジンである」とは</h3><p>ドメイン・プロトコル・ポート番号の全てが一致している場合のこと。<br></p><h3 id=\"h583e348ae7\">同一オリジンポリシー（Same-Origin Policy）とは</h3><p>MDNには以下のように書いてあります。<br></p><blockquote><strong>同一オリジンポリシー</strong>は重要なセキュリティの仕組みであり、ある<a style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Glossary/Origin\" target=\"_blank\" rel=\"noopener noreferrer\">オリジン</a>によって読み込まれた文書やスクリプトが、他のオリジンにあるリソースにアクセスできる方法を制限するものです。<br><a style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener noreferrer\">同一オリジンポリシー - ウェブセキュリティ | MDN</a><br><br></blockquote><p>要するに、別のオリジンへのアクセスに制限をかけることで、XSSやCSRFといった攻撃を防ぐことを目的とするセキュリティの仕組みです。<br><br>XSSとCSRFについてそれぞれの詳しい攻撃手法はここでは取り上げませんが、対策を講じる上での要点を挙げておきます。<br></p><h3 id=\"hafaeffc4cb\">XSS (Cross Site Scripting)</h3><p>ユーザーが 意図しない不正なスクリプトが&nbsp;Webサーバーに送られ、Webサーバーからのレスポンスを受け取ってしまった結果<strong>クライアント側 (Web ブラウザ)</strong>&nbsp;で実行される攻撃。<br><br>ブラウザ上で出来ることは何でも悪用対象になるので、CSRFより攻撃範囲が広い。<br></p><h3 id=\"hc9f9aae59b\"><strong>CSRF (Cross-Site Request Forgeries)</strong></h3><p>ユーザーが意図しない不正なスクリプトがWebサーバーに送られ、&nbsp;<strong>Web アプリケーション (Web サーバー)</strong>&nbsp;上で実行される攻撃。通称「しーさーふ」。<br><br>悪用内容はサーバー側で用意された処理に限定されるが、&nbsp;<strong>サーバーにリクエストが到達するだけで攻撃が成立する</strong>ので、XSS対策はできていてもCSRF対策は出来ていないということもあり得る。<br><br><br>JavaScript の組み込み API でありAjax 通信を実現する&nbsp;<code>XMLHttpRequest (XHR)</code>&nbsp;や&nbsp;<code>Fetch API</code>&nbsp;などは、これらの脆弱性を回避するため<strong>同一オリジンポリシー</strong>（別のオリジンへのアクセスに制限をかける仕組み）に従っています。<br>XSSとCSRFについての詳細は、以下の記事が分かりやすく勉強になりました。<br><a href=\"https://qiita.com/att55/items/a50ca43adde206017525\" target=\"_blank\" rel=\"noopener noreferrer\">XSS と CSRF って結局何が違うのか？ - Qiita</a><br></p><h1 id=\"h027a034520\">CORS</h1><p>同一オリジンポリシーについて抑えたところで、CORSについて見ていきます。<br></p><h2 id=\"hac1783c7e1\">CORSとは</h2><p>読み方：コルス or シーオーアールエス<br><strong>C</strong>ross-<strong>O</strong>rigin&nbsp;<strong>R</strong>esource&nbsp;<strong>S</strong>haring の略で、日本語訳すると「<strong>オリジン間リソース共有</strong>」。<br><br>CORSは、あるオリジンで動いているWebアプリケーションから別のオリジンのサーバーへのアクセスを許可する仕組みです。<br><br>同一オリジンポリシーにより別のオリジンにはアクセスが出来ないという規制があるが、Web開発・制作では異なるオリジンにアクセスしたいケースもある…　<br>そこで、同一オリジンポリシーの制約を回避・緩和してくれるのがCORSです。<br><br>歴史をたどるとCORSが必要になった経緯がさらによく分かります。<br></p><h3 id=\"h3aecdd16f5\">同一オリジンポリシーはあるが、CORSはない場合…（過去のブラウザ）</h3><p>出来たこと</p><ul><li>同一オリジンポリシーによりJavaScriptの安全性は確保される。</li></ul><p><br>生まれた課題</p><ul><li>Ajaxの普及・発展により、異なるオリジン（主に異なるホスト）のAPIを呼び出したいという動機が生まれた。</li><li>JSONPなど同一オリジンポリシーの範囲内で異なるオリジンのAPIを呼び出す方法が考案されたが、裏技のようなものであって安全性には課題が残っていた。</li></ul><p><br></p><h3 id=\"h510870a262\">そこで生まれたCORS</h3><p>上記のような課題を解決するため生まれたCORSは、以下の機能を提供します。<br></p><ul><li>クロスオリジンのアクセスを許可</li><li>オリジン単位でのアクセス制御が可能（例：オリジンA・オリジンBとの通信のみ許可する）</li><li>HTTPヘッダを用いてアクセス制御を行う</li></ul><p><br></p><h2 id=\"h922d87a02b\">CORSはどうやってクロスオリジン通信を許可するのか</h2><p>以下のように事前に通信を行う双方で設定を行っておくことで、クロスオリジンの通信が可能になります。<br></p><ul><li>クライアントサイド</li></ul><p>HTTPリクエストヘッダに<code>Originヘッダ</code>を付ける。<br><br>・XHRの場合：自動でOriginヘッダが付くので何もしなくて良い<br>・FetchAPIの場合：mode: cors を付与する<br></p><ul><li>サーバーサイド</li></ul><p>HTTPレスポンスヘッダに以下を付ける。<br>※レスポンスヘッダを付ける方法は環境によって様々です。<br>Laravelの場合は、Laravel7.0以降は<strong><code>config/cors.php</code></strong>&nbsp;を使ってCORSの設定ができます。<br><br><strong>＊必須＊</strong><br>・<code>Access-Control-Allow-Origin: アクセス元のオリジン</code><br><strong>＊必要な場合のみ＊</strong><br>・Access-Control-Allow-Credentials: true（Cookieを送信する場合は必要）<br>・Access-Control-Allow-Headers<br>・Access-Control-Request-Method<br>・Access-Control-Max-Age<br></p><h2 id=\"h6562eef876\">CORSによるアクセス制御の流れ</h2><p>実際にCORSがアクセス制御を行う流れを、ブラウザの検証ツールのネットワークを観察して確認します。<br><br>【前提】<br>・フロント側（Next.js）をlocalhost:3001、API（Laravel）をlocalhost:8080で開発中。<br>・localhost:3001のフロント側から、localhost:8080/logoutというURLにアクセスしてAPIをたたき、クロスオリジンの通信を発生させる。<br>・リクエストはXHRにより行うので、リクエストヘッダには自動的にOriginヘッダが付く。<br>・localhost:3001からのリクエストがあった場合は、レスポンスヘッダにAccess-Control-Allow-Originを載せるように、事前にAPI側で設定している。<br><br>【実際の流れ】<br>1.　ブラウザでlocalhost:3001にアクセスする。<br>2.　localhots:3001からlocalhost:8080/logoutへHTTPリクエストを送る。<br>　&lt;ポイント&gt; リクエストヘッダのOriginという項目に、リクエスト元のドメイン情報が載せられる。</p><pre><code class=\"hljs\">Origin: http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">3001</span></code></pre><p>3.　レスポンスが返ってきたら、localhost:3001はlocalhost:8080からのレスポンスヘッダを見て、レスポンスを受け取るかどうか判断する。<br>　&lt;ポイント&gt;　レスポンスヘッダに&nbsp;<code>Access-Control-Allow-Origin</code>&nbsp;という項目があり、自分のドメイン情報（localhost:3001）が載せられていればレスポンスを受け取る。</p><pre><code class=\"hljs\"><span class=\"hljs-regexp\">//</span> レスポンスヘッダに以下の記載があれば、レスポンスを受け取る\nAccess-Control-Allow-Origin：http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">3001</span></code></pre><h3 id=\"h5d7a611c3a\"><br>CORSエラーを起こしてみる</h3><p>上記の例では、事前にAPI側（Laravelのconfig/cors.php）でlocalhost:3001からのリクエストに対してAccess-Control-Allow-Originを返す設定をしていた為、クロスオリジンの通信が成立していました。<br><br>試しにAPI側で設定を行っている箇所を削除してみると、レスポンスヘッダに&nbsp;<code>Access-Control-Allow-Origin：http://localhost:3001</code>&nbsp;が無いので、CORSエラーが起こります。<br><br>ここでのエラーは、リクエスト自体は送っているけれど、レスポンスが返って来た時にそれを受け取らず<strong>レスポンスエラー</strong>ということになっています。<br></p><h2 id=\"h119f62b8ee\">プリフライトリクエスト</h2><h3 id=\"hf8c9fef3ec\">無条件でリクエストが飛んでも大丈夫なのか？</h3><p>CORSの設定をしていないとエラーが発生して通信は成立しませんでしたが、そのエラーはあくまで<strong>レスポンスを受け取らない</strong>というものでした。<br><br>しかし、そもそもリクエストが飛んで良いのか？という懸念が残ります。<br><br>代表的なリスクがCSRFです。<br>&nbsp;<strong>CSRFではレスポンスを受け取る必要は無く、リクエストが送信できれば攻撃できます。</strong><br><br>このようなリスク対策として、プリフライトリクエストが生まれました。<br></p><h3 id=\"hbcb48602bc\">プリフライトリクエストの考え方</h3><ul><li>元々CORSが無いときにできていたクロスオリジンのリクエストに対して、大幅なリスク増にならない条件であれば、XHR等で無条件にクロスオリジンのリクエストを送信できるようにした。</li><li>「大幅なリスク増にならない」条件を単純リクエストとして定義した。</li><li>単純リクエストの要件を超える場合は、実際のリクエストを送る前にプリフライトリクエストを送り、実際のリクエストを送信して問題無いか事前に確認する。</li><li>プリフライトリクエストを挟むことで、プリフライトリクエストを送信した結果Access-Control-Allow-OriginのHTTPヘッダがついたレスポンスが返されなければ、実際のリクエストは送信しない、というように悪意あるリクエストを防ぐ。</li></ul><p><br></p><h3 id=\"he303012d4a\">単純リクエスト（Simple Request）の要件</h3><p>以下の要件を全て満たす場合のみ、単純リクエストとなります。<br></p><ul><li>メソッドは「GET, POST, HEAD」のいずれか</li><li>設定できるリクエストヘッダは以下のいずれか<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type（条件付き）</li></ul></li><li>Content-Typeについては以下のいずれかを満たすこと<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data（ファイルアップロードに使う）</li></ul></li><li>text/plain（滅多に使わない）</li></ul><p><br></p><h2 id=\"ha214098e44\">まとめ</h2><ul><li>XSSやCSRFなどの対策として、他のオリジンへのアクセスを制限する「同一オリジンポリシー」という仕組みがある。</li><li>他のオリジンへアクセスしたい、でも安全性も保ちたい、、を叶えるためCORSが生まれた。</li><li>通常のCORSはレスポンスが届いたときにレスポンスを受け取るかどうかの制御を行うので、リクエスト自体は無条件に飛んでしまう。そこで不正なリクエストが送られてしまうリスク対策として、プリフライトリクエストが生まれた。</li></ul><p><br></p><h2 id=\"h3bcda3e6b0\">最後に</h2><p>エラーが解消されて動けばOKではなく、きちんと仕組みを調べてみてかなり理解が深まったかなと思います。（もし誤りがあれば是非ご指摘いただけると幸いです…！！）<br><br>これまでHTTPリクエストヘッダやレスポンスヘッダをまじまじと見たことも無かったので、Ajax通信を行っている箇所で検証ツールを確認してみると面白かったです。<br>確かにOriginやAccess-Control-Allow-Originがあったり、プリフライトリクエストが送られてレスポンスが返って来てから本番のリクエストが送られているのが確認できて、勉強になりました。<br>セキュリティ対策についてしっかり理解できていなくても動くアプリを作ることが出来てしまうというのは怖いことだなと思うので、これからもセキュリティの勉強はしていきたいと思います。<br></p><h2 id=\"he45680f0bc\">参考記事</h2><p><br><a href=\"https://developer.mozilla.org/ja/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener noreferrer\">オリジン間リソース共有 (CORS) - HTTP | MDN</a><br><br><a href=\"https://labor.ewigleere.net/2020/10/13/cors_preflight_request_verification/\" target=\"_blank\" rel=\"noopener noreferrer\">CORS の挙動の観察と preflight request の検証</a><br><br><a href=\"https://it-web-life.com/javascript_cors_preflight/\" target=\"_blank\" rel=\"noopener noreferrer\">【CORS】JavaScriptにおけるCORSやPreflightを理解する</a><br><br><a href=\"https://programmer-life.work/html_css/html-request\" target=\"_blank\" rel=\"noopener noreferrer\">HTTPリクエストとは？HTTPリクエストを目で確認したい | Programmer LifeHTTPリクエストとは？HTTPリクエストを目...</a><br><br><a href=\"https://qiita.com/att55/items/2154a8aad8bf1409db2b\" target=\"_blank\" rel=\"noopener noreferrer\">なんとなく CORS がわかる...はもう終わりにする。 - Qiita</a><br></p></body></html>"},"__N_SSG":true}
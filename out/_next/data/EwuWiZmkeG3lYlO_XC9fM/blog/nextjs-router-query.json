{"pageProps":{"blog":{"id":"nextjs-router-query","createdAt":"2022-02-12T10:12:00.712Z","updatedAt":"2022-02-12T10:24:05.297Z","publishedAt":"2022-01-25T10:12:00.000Z","revisedAt":"2022-02-12T10:21:40.124Z","title":"Next.jsのrouter.queryでURLの動的パラメータを取得するときの注意","body":"<p>業務で、useEffect内でNext.jsのuseRouterを使ってクエリパラメータを取得しようとした際、意図する通りの挙動をしておらず戸惑ったので備忘録としてまとめておきます。<br><br>通常<strong>pages/blogs/[id].tsx</strong>のようなファイルにおいてAPIからデータを取得したい場合、<code>getStaticPaths</code>・<code>getStaticProps</code>を使うかと思いますが、今回は画面描画してからバックグラウンドでAPIリクエストを行ってデータ取得する必要があり、そこで見つけたのが<code>useRouter</code>の<code>router.query</code>でした。 <br></p><h2 id=\"h5752334b14\"> useRouterとは</h2><p>そもそもuseRouterとは、Next.jsが用意しているhooksの一つで、routeに関する色んな情報を持つrouterオブジェクトへのアクセスを提供するものです。<br></p><blockquote> アプリの関数コンポーネント内の<code>router</code>オブジェクトにアクセスする場合は、<code>useRouter</code>フックを使用できます。   <br><code>useRouter</code>はReactフックです。  <br>&nbsp;<a href=\"https://nextjs.org/docs/api-reference/next/router#userouter\" target=\"_blank\" rel=\"noopener noreferrer\">https://nextjs.org/docs/api-reference/next/router#userouter</a> </blockquote><p><br>routerオブジェクトはいくつもの便利なメソッドやプロパティを持ちますが、その中のひとつにqueryがあります。<br></p><h2 id=\"h6a9e501b40\"> router.queryの使い方</h2><p>&nbsp;<code>router.query</code> とするだけで、オブジェクト形式で動的ルーティングの中身を取得できます。  <br><br>ちなみに以下の例のようにクエリパラメータが数字の場合も、string型で取得されます。<br> </p><pre><code>import { useRouter } from 'next/router'\n\n// 関数コンポーネント内にて\n&nbsp;const router = useRouter()\n&nbsp;console.log(router.query)\n&nbsp;console.log(router.query.id)\n\n// 出力結果(localhost:3000/blogs/1 の場合)\n// { id: '1' }\n// 1</code></pre><p><br></p><h2 id=\"h970271505b\"> useEffect内でrouter.queryを使ってみる</h2><p><code>pages/blogs/[id].tsx</code>の<code>useEffect</code>内で<code>router.query</code>を使ってみます。<br></p><pre><code>const router = useRouter()\n\nuseEffect(() =&gt; {\n&nbsp;const routeId = router.query.id\n&nbsp;console.log(routeId)\n}, [])\n\n// undefined </code></pre><p><br>出力されたのは <code>undefinde</code> でした。  <br><br>どうやら、router.queryの取得は<code>useEffect</code>の発火タイミングより後のようです。<br><br>【注】ただし、チームの中には上記のコードでもundefindeにならずqueryが取れている方もいましたし、私の環境でも時によってはqueryが取れることもありました。いずれにせよ不安定なものと思われるので、以下の対処をしておくのが無難なのかなと思います。<br>（ご存じの方はぜひご指導・ご指摘ください…！）<br></p><h3 id=\"hc1efd68684\"> useEffectの依存配列にrouterを指定する</h3><p>依存配列に<code>router</code>を入れてみました。<br></p><pre><code>const router = useRouter()&nbsp;\n\nuseEffect(() =&gt; {\n&nbsp;const routeId = router.query.id\n&nbsp;console.log(routeId)\n}, [router])\n\n// 出力結果(localhost:3000/blogs/1 の場合)\n// undefined\n// 1</code></pre><p><br>すると、一度<code>undefinde</code>と出た後に<code>query</code>が取れてコンソールに出力されました。<br><br>これで目的を果たせる場合もあるかもしれません。<br><br>しかし今回私が実装したかった要件は、取得したルートパラメーターを使ったパスでAPIへリクエストを送るというものです。<br>undefinedを取得してしまうと <code>'/api/blogs/undefined'</code>のパスにリクエストを送ってしまい、これは不都合でした。  <br></p><h3 id=\"h2f530575d0\"> isReadyを使ってrouter情報が準備されているか判別する</h3><p>辿り着いたコードは以下の通りです。<br> </p><pre><code>const router = useRouter()\n\nuseEffect(() =&gt; {\n&nbsp;if (router.isReady) {\n&nbsp;&nbsp;const routeId = router.query.id\n&nbsp;&nbsp;console.log(routeId)\n&nbsp;}\n}, [router])\n\n// 出力結果(localhost:3000/blogs/1 の場合)\n// 1</code></pre><p><br>routerオブジェクトの持つ <code>isReady</code> というboolean値が最適でした。  <br></p><blockquote> <code>isReady</code>：<code>boolean</code>　ルーターフィールドがクライアント側で更新され、使用できる状態になっているかどうか。<code>useEffect</code>メソッド内でのみ使用する必要があり、サーバーで条件付きでレンダリングするためには使用しないでください。    <br>&nbsp;<a href=\"https://nextjs.org/docs/api-reference/next/router#router-object\" target=\"_blank\" rel=\"noopener noreferrer\">https://nextjs.org/docs/api-reference/next/router#router-object</a> </blockquote><p><br></p><h2 id=\"hf6e0a9e212\"> なぜundefindeが取得されていたのか</h2><p>queryの取得タイミングはuseEffectの発火よりも後なのだということは何となく察しましたが、どういう仕組みなのか気になります。<br><br>Next.jsのドキュメントのダイナミックルーティングについての箇所に、以下のように書かれていました。<br></p><blockquote> Pages that are statically optimized by [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimizat<a href=\"https://nextjs.org/docs/advanced-features/automatic-static-optimization\" target=\"_blank\" rel=\"noopener noreferrer\">Automatic Static Optimization</a> <br> After hydration, Next.js will trigger an update to your application to provide the route parameters in the <code>query</code> object.  </blockquote><p><br>Pre-renderingの間はqueryは空のオブジェクトであり、hydrationのプロセスが終わった段階でqueryオブジェクトが提供されると書いてあります。<br><br>getStaticPropsやgetSererSidePropsの処理が終わるまでは、queryは空なのですね。<br><br>hydrationという単語は初めて知りましたが、Next.jsの公式の図を見るとイメージは湧きました。<br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/a9c4b88b0bb24532bb598719b0bf4137/pre-rendering.png\" alt=\"\"><br><br></p><h2 id=\"h3937880ed1\"> 参考記事</h2><p><a href=\"https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a\" target=\"_blank\" rel=\"noopener noreferrer\">https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a</a><br><br><a href=\"https://zenn.dev/luvmini511/articles/1523113e0dec58\" target=\"_blank\" rel=\"noopener noreferrer\">https://zenn.dev/luvmini511/articles/1523113e0dec58</a><br></p>","tags":[{"id":"nextjs","createdAt":"2022-01-07T13:18:14.144Z","updatedAt":"2022-02-12T02:31:58.832Z","publishedAt":"2022-01-07T13:18:14.144Z","revisedAt":"2022-01-07T13:18:14.144Z","tag":"Next.js"},{"id":"react","createdAt":"2022-01-07T13:17:54.189Z","updatedAt":"2022-02-12T02:31:51.382Z","publishedAt":"2022-01-07T13:17:54.189Z","revisedAt":"2022-01-07T13:17:54.189Z","tag":"React"}],"image":"react"},"highlightedBody":"<html><head></head><body><p>業務で、useEffect内でNext.jsのuseRouterを使ってクエリパラメータを取得しようとした際、意図する通りの挙動をしておらず戸惑ったので備忘録としてまとめておきます。<br><br>通常<strong>pages/blogs/[id].tsx</strong>のようなファイルにおいてAPIからデータを取得したい場合、<code>getStaticPaths</code>・<code>getStaticProps</code>を使うかと思いますが、今回は画面描画してからバックグラウンドでAPIリクエストを行ってデータ取得する必要があり、そこで見つけたのが<code>useRouter</code>の<code>router.query</code>でした。 <br></p><h2 id=\"h5752334b14\"> useRouterとは</h2><p>そもそもuseRouterとは、Next.jsが用意しているhooksの一つで、routeに関する色んな情報を持つrouterオブジェクトへのアクセスを提供するものです。<br></p><blockquote> アプリの関数コンポーネント内の<code>router</code>オブジェクトにアクセスする場合は、<code>useRouter</code>フックを使用できます。   <br><code>useRouter</code>はReactフックです。  <br>&nbsp;<a href=\"https://nextjs.org/docs/api-reference/next/router#userouter\" target=\"_blank\" rel=\"noopener noreferrer\">https://nextjs.org/docs/api-reference/next/router#userouter</a> </blockquote><p><br>routerオブジェクトはいくつもの便利なメソッドやプロパティを持ちますが、その中のひとつにqueryがあります。<br></p><h2 id=\"h6a9e501b40\"> router.queryの使い方</h2><p>&nbsp;<code>router.query</code> とするだけで、オブジェクト形式で動的ルーティングの中身を取得できます。  <br><br>ちなみに以下の例のようにクエリパラメータが数字の場合も、string型で取得されます。<br> </p><pre><code class=\"hljs\">import { useRouter } from <span class=\"hljs-string\">'next/router'</span>\n\n<span class=\"hljs-regexp\">//</span> 関数コンポーネント内にて\n&nbsp;const router = useRouter()\n&nbsp;console.log(router.query)\n&nbsp;console.log(router.query.id)\n\n<span class=\"hljs-regexp\">//</span> 出力結果(localhost:<span class=\"hljs-number\">3000</span><span class=\"hljs-regexp\">/blogs/</span><span class=\"hljs-number\">1</span> の場合)\n<span class=\"hljs-regexp\">//</span> { id: <span class=\"hljs-string\">'1'</span> }\n<span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">1</span></code></pre><p><br></p><h2 id=\"h970271505b\"> useEffect内でrouter.queryを使ってみる</h2><p><code>pages/blogs/[id].tsx</code>の<code>useEffect</code>内で<code>router.query</code>を使ってみます。<br></p><pre><code class=\"hljs\">const router = <span class=\"hljs-built_in\">useRouter</span>()\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">useEffect</span><span class=\"hljs-params\">(()</span></span> =&gt; {\n&nbsp;const routeId = router<span class=\"hljs-selector-class\">.query</span><span class=\"hljs-selector-class\">.id</span>\n&nbsp;console<span class=\"hljs-selector-class\">.log</span>(routeId)\n}, <span class=\"hljs-selector-attr\">[]</span>)\n\n<span class=\"hljs-comment\">// undefined </span></code></pre><p><br>出力されたのは <code>undefinde</code> でした。  <br><br>どうやら、router.queryの取得は<code>useEffect</code>の発火タイミングより後のようです。<br><br>【注】ただし、チームの中には上記のコードでもundefindeにならずqueryが取れている方もいましたし、私の環境でも時によってはqueryが取れることもありました。いずれにせよ不安定なものと思われるので、以下の対処をしておくのが無難なのかなと思います。<br>（ご存じの方はぜひご指導・ご指摘ください…！）<br></p><h3 id=\"hc1efd68684\"> useEffectの依存配列にrouterを指定する</h3><p>依存配列に<code>router</code>を入れてみました。<br></p><pre><code class=\"hljs\">const router = <span class=\"hljs-built_in\">useRouter</span>()&nbsp;\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">useEffect</span><span class=\"hljs-params\">(()</span></span> =&gt; {\n&nbsp;const routeId = router<span class=\"hljs-selector-class\">.query</span><span class=\"hljs-selector-class\">.id</span>\n&nbsp;console<span class=\"hljs-selector-class\">.log</span>(routeId)\n}, <span class=\"hljs-selector-attr\">[router]</span>)\n\n<span class=\"hljs-comment\">// 出力結果(localhost:3000/blogs/1 の場合)</span>\n<span class=\"hljs-comment\">// undefined</span>\n<span class=\"hljs-comment\">// 1</span></code></pre><p><br>すると、一度<code>undefinde</code>と出た後に<code>query</code>が取れてコンソールに出力されました。<br><br>これで目的を果たせる場合もあるかもしれません。<br><br>しかし今回私が実装したかった要件は、取得したルートパラメーターを使ったパスでAPIへリクエストを送るというものです。<br>undefinedを取得してしまうと <code>'/api/blogs/undefined'</code>のパスにリクエストを送ってしまい、これは不都合でした。  <br></p><h3 id=\"h2f530575d0\"> isReadyを使ってrouter情報が準備されているか判別する</h3><p>辿り着いたコードは以下の通りです。<br> </p><pre><code class=\"hljs\">const router = <span class=\"hljs-built_in\">useRouter</span>()\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">useEffect</span><span class=\"hljs-params\">(()</span></span> =&gt; {\n&nbsp;<span class=\"hljs-keyword\">if</span> (router.isReady) {\n&nbsp;&nbsp;const routeId = router<span class=\"hljs-selector-class\">.query</span><span class=\"hljs-selector-class\">.id</span>\n&nbsp;&nbsp;console<span class=\"hljs-selector-class\">.log</span>(routeId)\n&nbsp;}\n}, <span class=\"hljs-selector-attr\">[router]</span>)\n\n<span class=\"hljs-comment\">// 出力結果(localhost:3000/blogs/1 の場合)</span>\n<span class=\"hljs-comment\">// 1</span></code></pre><p><br>routerオブジェクトの持つ <code>isReady</code> というboolean値が最適でした。  <br></p><blockquote> <code>isReady</code>：<code>boolean</code>　ルーターフィールドがクライアント側で更新され、使用できる状態になっているかどうか。<code>useEffect</code>メソッド内でのみ使用する必要があり、サーバーで条件付きでレンダリングするためには使用しないでください。    <br>&nbsp;<a href=\"https://nextjs.org/docs/api-reference/next/router#router-object\" target=\"_blank\" rel=\"noopener noreferrer\">https://nextjs.org/docs/api-reference/next/router#router-object</a> </blockquote><p><br></p><h2 id=\"hf6e0a9e212\"> なぜundefindeが取得されていたのか</h2><p>queryの取得タイミングはuseEffectの発火よりも後なのだということは何となく察しましたが、どういう仕組みなのか気になります。<br><br>Next.jsのドキュメントのダイナミックルーティングについての箇所に、以下のように書かれていました。<br></p><blockquote> Pages that are statically optimized by [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimizat<a href=\"https://nextjs.org/docs/advanced-features/automatic-static-optimization\" target=\"_blank\" rel=\"noopener noreferrer\">Automatic Static Optimization</a> <br> After hydration, Next.js will trigger an update to your application to provide the route parameters in the <code>query</code> object.  </blockquote><p><br>Pre-renderingの間はqueryは空のオブジェクトであり、hydrationのプロセスが終わった段階でqueryオブジェクトが提供されると書いてあります。<br><br>getStaticPropsやgetSererSidePropsの処理が終わるまでは、queryは空なのですね。<br><br>hydrationという単語は初めて知りましたが、Next.jsの公式の図を見るとイメージは湧きました。<br><img src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/a9c4b88b0bb24532bb598719b0bf4137/pre-rendering.png\" alt=\"\"><br><br></p><h2 id=\"h3937880ed1\"> 参考記事</h2><p><a href=\"https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a\" target=\"_blank\" rel=\"noopener noreferrer\">https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a</a><br><br><a href=\"https://zenn.dev/luvmini511/articles/1523113e0dec58\" target=\"_blank\" rel=\"noopener noreferrer\">https://zenn.dev/luvmini511/articles/1523113e0dec58</a><br></p></body></html>"},"__N_SSG":true}
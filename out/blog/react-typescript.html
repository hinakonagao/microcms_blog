<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4bc12c1be68739c7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4bc12c1be68739c7.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d58b9228ffac9a6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d58b9228ffac9a6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-101cfeaa18eb0e64.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5a602b05d6a5b45c.js" defer=""></script><script src="/_next/static/chunks/451-8446afed8f2a81ca.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-7b5e07e6b1c54b77.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_buildManifest.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_ssgManifest.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style data-emotion="css a6by8m">.css-a6by8m{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;margin:auto;}</style><div class="MuiGrid-root MuiGrid-container css-a6by8m"><style data-emotion="css d0aeej">.css-d0aeej{background-color:#FFF;color:#222;margin:30px auto;padding:36px;}.css-d0aeej h1,.css-d0aeej h2,.css-d0aeej h3{font-weight:550;}</style><style data-emotion="css vx8k43">.css-vx8k43{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:91.666667%;-ms-flex-preferred-size:91.666667%;flex-basis:91.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:91.666667%;background-color:#FFF;color:#222;margin:30px auto;padding:36px;}@media (min-width:600px){.css-vx8k43{-webkit-flex-basis:91.666667%;-ms-flex-preferred-size:91.666667%;flex-basis:91.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:91.666667%;}}@media (min-width:900px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1200px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1536px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}.css-vx8k43 h1,.css-vx8k43 h2,.css-vx8k43 h3{font-weight:550;}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-11 MuiGrid-grid-md-9 css-vx8k43"><style data-emotion="css tph460">.css-tph460{padding:15px 0px;border-bottom:1px solid #4682B4;}</style><div class="css-tph460"><style data-emotion="css 1x4m838">.css-1x4m838{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;font-size:26px;font-weight:540;padding-bottom:16px;}</style><p class="MuiTypography-root MuiTypography-body1 css-1x4m838">React×TypeScript　基本の型定義</p><style data-emotion="css q5vujz">.css-q5vujz{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;display:inline-block;padding-right:32px;}</style><p class="MuiTypography-root MuiTypography-body2 css-q5vujz"><style data-emotion="css 1eipbkb">.css-1eipbkb{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;font-size:15px;margin-right:4px;vertical-align:middle;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1eipbkb" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="AccessTimeIcon"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path><path d="M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></svg>投稿日 <!-- -->2022/1/16</p><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1eipbkb" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LocalOfferIcon"><path d="m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z"></path></svg><style data-emotion="css 1lc4u9f">.css-1lc4u9f{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;display:inline-block;padding-right:8px;}</style><p class="MuiTypography-root MuiTypography-body2 css-1lc4u9f">#<!-- -->TypeScript</p><p class="MuiTypography-root MuiTypography-body2 css-1lc4u9f">#<!-- -->React</p></div><style data-emotion="css il3arz">.css-il3arz{margin-top:40px;}.css-il3arz a{color:#639bb7;}.css-il3arz a:hover{color:#0b7eb8;-webkit-text-decoration:underline;text-decoration:underline;}</style><div class="css-il3arz"><html><head></head><body><h2 id="h04bc4be39a"> はじめに</h2><p>業務でフロント側はReact（Next.js）, TypeScriptを使っているのですが、配属当初の私はReactにもTypeScriptにも触れたことが無く、何が分からないのか分からない状態でした。<br><br>TypeScriptの基礎を学んでもReact特有の型定義があり戸惑いましたが、ようやく理解して書けるようになって来たな…ということで、辞書代わりにまとめておきます。<br>（誤りのご指摘・アドバイスがあればぜひお願いします！）<br></p><h1 id="h2e4995e418"> 基礎編</h1><p>まずは基本の型定義を一通り挙げます。<br></p><h2 id="hd817cee2b9"> 関数コンポーネント</h2><p>関数コンポーネントでは、普通の関数と同じように引数（props）に型付けします。<br><br>戻り値はJSX要素を返せば型推論されるので、明らかな場合は型付けしなくてOKです。<br><br>※以下の例では、propsは分割代入の書き方で受け取るものとします。<br></p><h3 id="h480940b7cc"> 引数（props）なしの場合</h3><p>propsを受け取らない場合は、JavaScriptで記述するときと変わりません。<br></p><pre><code class="hljs"><span class="hljs-comment">// ノーマルの関数コンポーネント（引数なしの場合）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>なまえ<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p><br></p><h3 id="h40e5e6f6fd"> ひとつのpropsを受け取る</h3><pre><code class="hljs"><span class="hljs-comment">// 引数に型付けする</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params">{ name }: { name: <span class="hljs-built_in">string</span> }</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>

<span class="hljs-comment">// 型エイリアスを使っても良い</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Props</span> = { <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params">{ name }: Props</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p><br>型注釈を直接つけても、型エイリアスを使ってもOKです。<br><br>プロジェクト内で合わせておけば良いかと思います。<br></p><h3 id="h2ac392abf5"> 複数のpropsを受け取る</h3><p>propsを複数受け取る場合は、型注釈を直接つけるよりも型エイリアスを付けた方が分かりやすいでしょう。<br></p><pre><code class="hljs"><span class="hljs-comment">// 引数が複数なら、型エイリアスを使う方が見やすい</span>
type Props = {
&nbsp;<span class="hljs-attr">name</span>: srting
&nbsp;onClick: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>
&nbsp;children: ReactNode
}</code></pre><p><br></p><h3 id="h5f171d61d9"> propsの型いろいろ</h3><p>以下のように色々な型の値をpropsとして受け取ることができます。<br>ここはほとんどTypeScriptの基本通りです。<br></p><pre><code class="hljs"><span class="hljs-comment">// propsとして受け取る値の型定義色々</span>
type P<span class="hljs-attr">rops</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">{</span>
<span class="hljs-symbol">&nbsp;str:</span> string&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// 文字列</span>
<span class="hljs-symbol">&nbsp;num:</span> number&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// 数値</span>
<span class="hljs-symbol">&nbsp;bool:</span> boolean&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// 真偽値</span>
<span class="hljs-symbol">&nbsp;strArr:</span> string[]&nbsp;&nbsp;<span class="hljs-comment">// 配列</span>
<span class="hljs-symbol">&nbsp;obj:</span> <span class="hljs-punctuation">{</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// オブジェクト</span>
<span class="hljs-symbol">&nbsp;&nbsp;str:</span> string
&nbsp;<span class="hljs-punctuation">}</span>
<span class="hljs-symbol">&nbsp;objArr:</span> <span class="hljs-punctuation">{</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// オブジェクトの配列</span>
<span class="hljs-symbol">&nbsp;&nbsp;str:</span> string
<span class="hljs-symbol">&nbsp;&nbsp;num:</span> number
&nbsp;<span class="hljs-punctuation">}</span>[]
<span class="hljs-symbol">&nbsp;func:</span> () =&gt; void&nbsp;&nbsp;<span class="hljs-comment">// 関数</span>
<span class="hljs-punctuation">}</span></code></pre><p><br></p><h3 id="ha7733746f8"> children</h3><p>childrenはコンポーネントのタグで囲った子要素をpropsとして受け取るときに使います。<br><br>よく使うのはReactNodeで、これはコンポーネントタグで囲ったJSX要素をまるっと受け取る場合に使います。<br></p><pre><code class="hljs"><span class="hljs-comment">// 共通レイアウトのコンポーネント</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">MainLayout</span> = (<span class="hljs-params">{ children }: { children: React.ReactNode }</span>) =&gt; {
&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;<span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;{children}
&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/&gt;</span></span>
&nbsp;)
}

<span class="hljs-comment">// 呼び出し側</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">MenuPage</span> = (<span class="hljs-params"></span>) =&gt; {
&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MainLayout</span>&gt;</span>
&nbsp;&nbsp;&nbsp;// この中にページの内容を書く
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">MainLayout</span>&gt;</span></span>
&nbsp;)
}</code></pre><p><br>もし特定の文字列や数値しか受け取らないというような場合は、ReactNodeではなく特定の型に制限することもできます。<br></p><pre><code class="hljs"><span class="hljs-comment">// Buttonコンポーネント</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Button</span> = (<span class="hljs-params">{ children }: { children: <span class="hljs-built_in">string</span> }</span>) =&gt; {
&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&nbsp;)
}

<span class="hljs-comment">// 呼び出し側</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) =&gt; {
&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;<span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
// フォームの記述があるとする

&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>送信<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>戻る<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/&gt;</span></span>
&nbsp;)
}</code></pre><p><br>ちなみにReactNodeは以下の通りのUnion型で定義されています。<br></p><pre><code class="hljs">type ReactNode = ReactChild | <span class="hljs-type">ReactFragment</span> | <span class="hljs-type">ReactPortal</span> | <span class="hljs-type">boolean</span> | <span class="hljs-type">null</span> | <span class="hljs-type">undefined</span>;</code></pre><p><br></p><h3 id="h31df23c0b3"> propsのデフォルト値を指定する</h3><p>コンポーネントの利用箇所ごとにpropsに渡す値を指定してもよいのですが、デフォルト値を指定することもできます。<br>よく指定される値がある時や、値が無かった場合の値を決めておきたい場合に有効です。<br></p><pre><code class="hljs"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Name</span> = (<span class="hljs-params">{ name = <span class="hljs-string">"ゲスト"</span> }: { name?: <span class="hljs-built_in">string</span> }</span>) =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{name}さん<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p><br></p><h3 id="h5be2f009d7"> オプショナルなprops（undefined許容）</h3><p><code>?</code> を付けることでオプショナルな型定義が出来ます。  <br>以下のように書いた場合、name・emailの型は<code>string | undefined</code>となります。  <br></p><pre><code class="hljs">type Props = {
&nbsp;<span class="hljs-built_in">name</span>?: <span class="hljs-built_in">string</span>
&nbsp;email?: <span class="hljs-built_in">string</span>
}</code></pre><p><br>この場合はundefinedの可能性を考慮してpropsの初期値を設定するか、値の有無による条件分岐を行います。<br></p><pre><code class="hljs"><span class="hljs-comment">// nameは初期値を設定、emailはpropsの値が渡された場合のみ表示する</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Button</span> = (<span class="hljs-params">{ name = <span class="hljs-string">'ゲスト'</span>, email }: Props</span>) =&gt; {
&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{name}さん<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
&nbsp;&nbsp;&nbsp;{email &amp;&amp; (
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>email:{email}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
&nbsp;&nbsp;&nbsp;)}
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&nbsp;)
}</code></pre><p><br></p><h3 id="h61a1261837"> 戻り値の型付け</h3><p>JSX要素を返せば型を指定していなくても推論してくれますが、明示しておけば正しい値が返されなかった場合エラーを表示してくれます。<br></p><pre><code class="hljs">const App = ({<span class="hljs-built_in"> name</span> }: {<span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span> }): JSX.Element =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xquery"><span class="hljs-built_in">{name</span>}</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;</code></pre><p><br></p><h3 id="h40fc68507d"> React.FC / VFC</h3><p>React.FC / VFC については、TypeSctriptを導入するのであれば不要と考えられるのでここでは取り上げません。（今の私の業務では使っていないのですが、もしなにか誤りやアドバイスがあれば是非ご教授ください…！）<br>参考記事：<a href="https://kray.jp/blog/dont-have-to-use-react-fc-and-react-vfc/" target="_blank" rel="noopener noreferrer">【検証】React.FC と React.VFC はべつに使わなくていい説</a> <br></p><h2 id="h2e72b92d37"> useState　状態変数の型</h2><h3 id="hde697c111e"> 型推論に任せる</h3><p>useStateフックでは初期値を与えれば状態変数の型を推論してくれます。<br>なので極力初期値を与えて、推論させるようにします。<br></p><pre><code class="hljs"><span class="hljs-comment">// プリミティブ値</span>
const <span class="hljs-selector-attr">[name, setName]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-string">""</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// string型</span>
const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// number型</span>
const <span class="hljs-selector-attr">[isChecked, setIsCheked]</span> = <span class="hljs-built_in">useState</span>(false)&nbsp;&nbsp;<span class="hljs-comment">// boolean型</span>

<span class="hljs-comment">// 配列</span>
const <span class="hljs-selector-attr">[colors, setColors]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-selector-attr">[<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>]</span>)&nbsp;&nbsp;<span class="hljs-comment">// string型の配列</span>
const <span class="hljs-selector-attr">[numbers, setNumbers]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-selector-attr">[1, 2, 3]</span>)&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// number型の配列</span></code></pre><p><br></p><h3 id="h6b88d1350c"> ジェネリック型で指定する</h3><ul><li> 基本の指定方法</li></ul><p>useStateの状態変数に対して明示的に型を指定する場合は、ジェネリック型 <code>&lt;T&gt;</code> を使います。  <br></p><pre><code class="hljs"><span class="hljs-comment">// useStateのジェネリック型&lt;T&gt;に明示的に型を指定する</span>
<span class="hljs-keyword">const</span> [name, setName] = useState&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">""</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// string型</span>
<span class="hljs-keyword">const</span> [count, setCount] = useState&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">0</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// number型</span>
<span class="hljs-keyword">const</span> [isChecked, setIsChecked] = useState&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>)&nbsp;&nbsp;<span class="hljs-comment">// boolean型</span></code></pre><p><br></p><ul><li> 別途定義した型をジェネリック型で指定する</li></ul><p>別途定義したオブジェクトを初期値にしたり、別途定義した型をジェネリック型で指定することもできます。<br>（型や初期値を複数のコンポーネントで使い回す場合や情報量が多くなる場合は、別ファイルに切り出しても良いかと思います。）<br></p><pre><code class="hljs">const initialUser = {
<span class="hljs-built_in">&nbsp;number</span>: <span class="hljs-number">1</span>,
<span class="hljs-built_in">&nbsp;name</span>: <span class="hljs-string">'名前'</span>,
&nbsp;email: <span class="hljs-string">'test@mail.com'</span>
}

type User = {
<span class="hljs-built_in">&nbsp;number</span>:<span class="hljs-built_in"> number</span>
<span class="hljs-built_in">&nbsp;name</span>:<span class="hljs-built_in"> string</span>
&nbsp;email:<span class="hljs-built_in"> string</span>
}

const [user, setUser] = useState<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span>&gt;</span>(initialUser)</span></code></pre><p><br></p><ul><li> ユニオン型でnullを含める </li></ul><p>値がnullの可能性があるときや、型は定めておきたいが初期値は後から決まるといった場合は、ユニオン型でnullを含めます。<br></p><pre><code class="hljs">// <span class="hljs-literal">null</span>を含む場合はユニオン型を用いる
<span class="hljs-keyword">const</span> [count, setCount] = useState&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)&nbsp;&nbsp;// <span class="hljs-built_in">number</span>型もしくは<span class="hljs-literal">null</span>型</code></pre><p><br></p><ul><li> 型アサーションを使う</li></ul><p>状態変数の初期値が決まらないけれどnullは許可しないという場合には、型アサーションを使うことができます。<br><br>まず、以下の書き方ではエラーが出ます。<br></p><pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> = {
&nbsp;number: number
&nbsp;<span class="hljs-type">name</span>: string
&nbsp;email: string
}

const [<span class="hljs-keyword">user</span>, setUser] = useState&lt;<span class="hljs-keyword">User</span>&gt;({})
<span class="hljs-keyword">user</span>[<span class="hljs-type">name</span>] = <span class="hljs-string">'ゲスト'</span>

// <span class="hljs-keyword">user</span>は「空のオブジェクト型」とTypeScriptは認識するのでコンパイルエラーになる</code></pre><p><br>そこで有効なのが型アサーションです。<br></p><pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">= {
&nbsp;number</span>: <span class="hljs-keyword">number</span>
&nbsp;name: <span class="hljs-keyword">string</span>
&nbsp;email: <span class="hljs-keyword">string</span>
}

const [user, setUser] = useState<span class="hljs-tag">&lt;User&gt;</span>({} as User)

// 型アサーションを使えばコンパイルエラーが出ない</code></pre><p><br>ただし型アサーションはTypeScriptに型を偽っているだけなので、もし必要なプロパティを忘れていてもコンパイラエラーが指摘してくれないので、なるべく初期値を設定して型アサーションを使わずに済む実装にした方がベターです。<br><br>もし全てのプロパティが任意ならば、初期値に空オブジェクトを与えても問題ないので型アサーションは必要ありません。<br></p><pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">= {&nbsp;
&nbsp;name</span>?: <span class="hljs-keyword">string</span>
&nbsp;email?: <span class="hljs-keyword">string</span>
&nbsp;age?: <span class="hljs-keyword">number</span>
}

const [user, setUser] = useState<span class="hljs-tag">&lt;User&gt;</span>({})

// userはUser型のうち任意のプロパティを持つ（空オブジェクトの可能性もある）</code></pre><p><br></p><h2 id="h6553d2c03c"> useEffect</h2><p>useEffectの戻り値は <code>undefined</code> もしくはクリーンアップ関数と決められており、戻り値を処理しないため型は必要ありません。  <br><br>ただし関数や値を返してしまうとエラーになるので、アロー関数の書き方に注意が必要です。<br><br>以下の書き方では、アロー関数式<code>=&gt;</code>の本体に波括弧<code>{}</code>なしに1行で書いた文が戻り値になってしまいます。   <br></p><pre><code class="hljs">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&nbsp;
&nbsp;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&nbsp;
&nbsp;&nbsp;<span class="hljs-regexp">//</span> 処理
&nbsp;, <span class="hljs-number">1000</span>);
, []);</code></pre><p><br>以下のように、本体を <code>{}</code> で囲むようにしてください。  <br></p><pre><code class="hljs">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
&nbsp;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-regexp">//</span> 処理
&nbsp;}, <span class="hljs-number">1000</span>);
}, []);</code></pre><p><br></p><h2 id="h7cf02dc148"> イベントオブジェクトの型</h2><p>onClickやonChangeといったイベントハンドラで扱うイベントにも型があります。<br><br>イベントオブジェクトの型を知りたいときは、VSCodeがヒントをくれます。<br><br>例えばonClickなら、以下の状態でonClickの上にマウスをホバーさせると型情報を表示してくれます。<br></p><pre><code class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><p><br>以下のように要素のイベント属性に直接イベントハンドラを書く場合は、引数のイベントの型は推論されるので注釈が要りません。<br></p><pre><code class="hljs"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(event)</span> =&gt;</span> //処理 }&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><p><br>イベントハンドラの関数を別途定義する場合は、通常の関数と同様に型付けが必要になります。<br></p><h3 id="h745a3f474e"> onClickイベント</h3><p>引数のイベントと戻り値に型付けをします。（戻り値は推論させてもOKです）<br></p><pre><code class="hljs"><span class="hljs-comment">// Buttonクリックの場合</span>
<span class="hljs-keyword">const</span> onClickButton = ( <span class="hljs-keyword">event</span>: React.MouseEvent&lt;HTMLButtonElement, MouseEvent&gt; ):<span class="hljs-keyword">void</span> =&gt; {
&nbsp;<span class="hljs-comment">// 処理</span>
}</code></pre><p><br></p><h3 id="hc860cddeda"> onChangeイベント</h3><pre><code class="hljs"><span class="hljs-comment">// Inputの場合</span>
<span class="hljs-keyword">const</span> onChangeInput = ( <span class="hljs-keyword">event</span>: React.ChangeEvent&lt;HTMLInputElement&gt;):<span class="hljs-keyword">void</span> =&gt; {
&nbsp;<span class="hljs-comment">// 処理</span>
}</code></pre><p><br></p><h3 id="h0591b223f6"> 複数種類の要素にイベントを適用する</h3><p>上記の例を見ると、ジェネリック型の部分に <code>HTMLButtonElement</code> <code>HTMLInputElement</code> とあるように特定のHTML要素のための型であることがわかります。   <br><br>もしDivタグ・Buttonタグ・Inputタグなどに同じイベントハンドラ関数を指定したい場合、通常は <code>HTMLButtonElement | HTMLInputElement | 続く...</code> と使いたい要素分の型を記述する必要があります。  <br><br>そんな時は、色んなHTML要素に共通して使える <code>HTMLElement</code> 型を使うこともできます。  <br></p><pre><code class="hljs"><span class="hljs-keyword">type</span> <span class="hljs-type">Props</span> = {
&nbsp;onClick: (event: <span class="hljs-type">React</span>.<span class="hljs-type">MouseEvent</span>&lt;<span class="hljs-type">HTMLElement</span>, <span class="hljs-type">MouseEvent</span>&gt;) =&gt; void
}</code></pre><p><br>以下の記事に詳しくまとめられており、非常に分かりやすかったです。<br><br>個人的には、精度を高めるためには面倒でも使う要素分だけ指定する方が良いのかな…？とも思いますが、 <code>HTMLButtonElem ent</code>  も<code> HTMLInputElement</code> も<code>HTMLElement</code> 型を継承しているんだと知り、勉強になりました。<br><a href="https://qiita.com/Takepepe/items/f1ba99a7ca7e66290f24" target="_blank" rel="noopener noreferrer">any型で諦めない React.EventCallback - Qiita</a> <br></p><h2 id="hadc4cddfcc"> 【番外編】Axios</h2><p>Axiosを使って非同期通信を行う際に返されるレスポンスやエラーにも型があります。<br></p><pre><code class="hljs"><span class="hljs-keyword">import</span> { AxiosError, AxiosResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>

axios
&nbsp;.get(<span class="hljs-string">'/url'</span>)
&nbsp;.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(response: AxiosResponse)</span> =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-regexp">//</span> 成功時の処理
&nbsp;})
&nbsp;.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(error: AxiosError)</span> =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-regexp">//</span> エラー時の処理
&nbsp;})</code></pre><p><br></p><h2 id="h691cb018bd"> おわりに</h2><p>正直はじめは、何か書くたびにエラーが出るしコード量が増えて余計にわけわからんと思いました。<br><br>でも慣れてくると、型が明示してあると処理の流れを追わなくてもどういう値が入って来るのかパッと見でも分かりやすいし、エディタの補完が効くのは便利で間違いがあれば気付けてTypeScript良いなと思うようになりました。<br><br>今後もより実用的でスマートな型の活用法を学んでいきたいと思います。<br></p><h2 id="h3937880ed1"> 参考記事</h2><p><a href="https://github.com/typescript-cheatsheets/react" target="_blank" rel="noopener noreferrer">https://github.com/typescript-cheatsheets/react</a><br><br><a href="https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB" target="_blank" rel="noopener noreferrer">https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB</a><br><br><a href="https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF" target="_blank" rel="noopener noreferrer">https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF</a><br><br><br><br><br></p></body></html></div></div></div><style data-emotion="css 2sbw87">.css-2sbw87{background-color:#494949;margin:0 auto;padding-top:30px;padding-bottom:30px;color:#f2f2f2;letter-spacing:0.08rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-around;-ms-flex-pack:space-around;-webkit-justify-content:space-around;justify-content:space-around;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style><div class="css-2sbw87"><style data-emotion="css kta5xp">.css-kta5xp{box-sizing:border-box;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:83.333333%;-ms-flex-preferred-size:83.333333%;flex-basis:83.333333%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:83.333333%;}@media (min-width:600px){.css-kta5xp{-webkit-flex-basis:83.333333%;-ms-flex-preferred-size:83.333333%;flex-basis:83.333333%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:83.333333%;}}@media (min-width:900px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}@media (min-width:1200px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}@media (min-width:1536px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}</style><div class="MuiGrid-root MuiGrid-grid-xs-10 MuiGrid-grid-md-8 css-kta5xp"><style data-emotion="css 1lx0lai">.css-1lx0lai{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;text-align:center;}</style><div class="MuiGrid-root MuiGrid-item css-1lx0lai"><a href="https://twitter.com/napi_nami"><style data-emotion="css 1ea777n">.css-1ea777n{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;margin:8px;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1ea777n" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="TwitterIcon"><path d="M22.46 6c-.77.35-1.6.58-2.46.69.88-.53 1.56-1.37 1.88-2.38-.83.5-1.75.85-2.72 1.05C18.37 4.5 17.26 4 16 4c-2.35 0-4.27 1.92-4.27 4.29 0 .34.04.67.11.98C8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15 0 1.49.75 2.81 1.91 3.56-.71 0-1.37-.2-1.95-.5v.03c0 2.08 1.48 3.82 3.44 4.21a4.22 4.22 0 0 1-1.93.07 4.28 4.28 0 0 0 4 2.98 8.521 8.521 0 0 1-5.33 1.84c-.34 0-.68-.02-1.02-.06C3.44 20.29 5.7 21 8.12 21 16 21 20.33 14.46 20.33 8.79c0-.19 0-.37-.01-.56.84-.6 1.56-1.36 2.14-2.23z"></path></svg></a><a href="https://github.com/hinakonagao"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1ea777n" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></div><style data-emotion="css 198jr53">.css-198jr53{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;text-align:center;font-weight:200;}</style><p class="MuiTypography-root MuiTypography-body2 css-198jr53">© 2022 hinako blog</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"id":"react-typescript","createdAt":"2022-02-12T10:20:56.912Z","updatedAt":"2022-02-17T13:33:23.975Z","publishedAt":"2022-01-16T10:20:56.000Z","revisedAt":"2022-02-12T10:21:12.181Z","title":"React×TypeScript　基本の型定義","body":"\u003ch2 id=\"h04bc4be39a\"\u003e はじめに\u003c/h2\u003e\u003cp\u003e業務でフロント側はReact（Next.js）, TypeScriptを使っているのですが、配属当初の私はReactにもTypeScriptにも触れたことが無く、何が分からないのか分からない状態でした。\u003cbr\u003e\u003cbr\u003eTypeScriptの基礎を学んでもReact特有の型定義があり戸惑いましたが、ようやく理解して書けるようになって来たな…ということで、辞書代わりにまとめておきます。\u003cbr\u003e（誤りのご指摘・アドバイスがあればぜひお願いします！）\u003cbr\u003e\u003c/p\u003e\u003ch1 id=\"h2e4995e418\"\u003e 基礎編\u003c/h1\u003e\u003cp\u003eまずは基本の型定義を一通り挙げます。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hd817cee2b9\"\u003e 関数コンポーネント\u003c/h2\u003e\u003cp\u003e関数コンポーネントでは、普通の関数と同じように引数（props）に型付けします。\u003cbr\u003e\u003cbr\u003e戻り値はJSX要素を返せば型推論されるので、明らかな場合は型付けしなくてOKです。\u003cbr\u003e\u003cbr\u003e※以下の例では、propsは分割代入の書き方で受け取るものとします。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h480940b7cc\"\u003e 引数（props）なしの場合\u003c/h3\u003e\u003cp\u003epropsを受け取らない場合は、JavaScriptで記述するときと変わりません。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// ノーマルの関数コンポーネント（引数なしの場合）\nconst App = () =\u0026gt; \u0026lt;div\u0026gt;なまえ\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h40e5e6f6fd\"\u003e ひとつのpropsを受け取る\u003c/h3\u003e\u003cpre\u003e\u003ccode\u003e// 引数に型付けする\nconst App = ({ name }: { name: string }) =\u0026gt; \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt;\n\n// 型エイリアスを使っても良い\ntype Props = { name: string }\nconst App = ({ name }: Props) =\u0026gt; \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e型注釈を直接つけても、型エイリアスを使ってもOKです。\u003cbr\u003e\u003cbr\u003eプロジェクト内で合わせておけば良いかと思います。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h2ac392abf5\"\u003e 複数のpropsを受け取る\u003c/h3\u003e\u003cp\u003epropsを複数受け取る場合は、型注釈を直接つけるよりも型エイリアスを付けた方が分かりやすいでしょう。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// 引数が複数なら、型エイリアスを使う方が見やすい\ntype Props = {\n\u0026nbsp;name: srting\n\u0026nbsp;onClick: () =\u0026gt; void\n\u0026nbsp;children: ReactNode\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h5f171d61d9\"\u003e propsの型いろいろ\u003c/h3\u003e\u003cp\u003e以下のように色々な型の値をpropsとして受け取ることができます。\u003cbr\u003eここはほとんどTypeScriptの基本通りです。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// propsとして受け取る値の型定義色々\ntype Props = {\n\u0026nbsp;str: string\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// 文字列\n\u0026nbsp;num: number\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// 数値\n\u0026nbsp;bool: boolean\u0026nbsp;\u0026nbsp;\u0026nbsp;// 真偽値\n\u0026nbsp;strArr: string[]\u0026nbsp;\u0026nbsp;// 配列\n\u0026nbsp;obj: {\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// オブジェクト\n\u0026nbsp;\u0026nbsp;str: string\n\u0026nbsp;}\n\u0026nbsp;objArr: {\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// オブジェクトの配列\n\u0026nbsp;\u0026nbsp;str: string\n\u0026nbsp;\u0026nbsp;num: number\n\u0026nbsp;}[]\n\u0026nbsp;func: () =\u0026gt; void\u0026nbsp;\u0026nbsp;// 関数\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"ha7733746f8\"\u003e children\u003c/h3\u003e\u003cp\u003echildrenはコンポーネントのタグで囲った子要素をpropsとして受け取るときに使います。\u003cbr\u003e\u003cbr\u003eよく使うのはReactNodeで、これはコンポーネントタグで囲ったJSX要素をまるっと受け取る場合に使います。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// 共通レイアウトのコンポーネント\nconst MainLayout = ({ children }: { children: React.ReactNode }) =\u0026gt; {\n\u0026nbsp;return (\n\u0026nbsp;\u0026nbsp;\u0026lt;\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;Header /\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;div\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{children}\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;/div\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;Footer /\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026lt;/\u0026gt;\n\u0026nbsp;)\n}\n\n// 呼び出し側\nconst MenuPage = () =\u0026gt; {\n\u0026nbsp;return (\n\u0026nbsp;\u0026nbsp;\u0026lt;MainLayout\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;// この中にページの内容を書く\n\u0026nbsp;\u0026nbsp;\u0026lt;/MainLayout\u0026gt;\n\u0026nbsp;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eもし特定の文字列や数値しか受け取らないというような場合は、ReactNodeではなく特定の型に制限することもできます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Buttonコンポーネント\nconst Button = ({ children }: { children: string }) =\u0026gt; {\n\u0026nbsp;return (\n\u0026nbsp;\u0026nbsp;\u0026lt;button\u0026gt;{children}\u0026lt;/button\u0026gt;\n\u0026nbsp;)\n}\n\n// 呼び出し側\nconst App = () =\u0026gt; {\n\u0026nbsp;return (\n\u0026nbsp;\u0026nbsp;\u0026lt;\u0026gt;\n// フォームの記述があるとする\n\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;Button\u0026gt;送信\u0026lt;/Button\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;Button\u0026gt;戻る\u0026lt;/Button\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026lt;/\u0026gt;\n\u0026nbsp;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eちなみにReactNodeは以下の通りのUnion型で定義されています。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h31df23c0b3\"\u003e propsのデフォルト値を指定する\u003c/h3\u003e\u003cp\u003eコンポーネントの利用箇所ごとにpropsに渡す値を指定してもよいのですが、デフォルト値を指定することもできます。\u003cbr\u003eよく指定される値がある時や、値が無かった場合の値を決めておきたい場合に有効です。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst Name = ({ name = \"ゲスト\" }: { name?: string }) =\u0026gt; \u0026lt;div\u0026gt;{name}さん\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h5be2f009d7\"\u003e オプショナルなprops（undefined許容）\u003c/h3\u003e\u003cp\u003e\u003ccode\u003e?\u003c/code\u003e を付けることでオプショナルな型定義が出来ます。  \u003cbr\u003e以下のように書いた場合、name・emailの型は\u003ccode\u003estring | undefined\u003c/code\u003eとなります。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etype Props = {\n\u0026nbsp;name?: string\n\u0026nbsp;email?: string\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eこの場合はundefinedの可能性を考慮してpropsの初期値を設定するか、値の有無による条件分岐を行います。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// nameは初期値を設定、emailはpropsの値が渡された場合のみ表示する\nconst Button = ({ name = 'ゲスト', email }: Props) =\u0026gt; {\n\u0026nbsp;return (\n\u0026nbsp;\u0026nbsp;\u0026lt;div\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;p\u0026gt;{name}さん\u0026lt;/p\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;{email \u0026amp;\u0026amp; (\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026lt;p\u0026gt;email:{email}\u0026lt;/p\u0026gt;\n\u0026nbsp;\u0026nbsp;\u0026nbsp;)}\n\u0026nbsp;\u0026nbsp;\u0026lt;/div\u0026gt;\n\u0026nbsp;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h61a1261837\"\u003e 戻り値の型付け\u003c/h3\u003e\u003cp\u003eJSX要素を返せば型を指定していなくても推論してくれますが、明示しておけば正しい値が返されなかった場合エラーを表示してくれます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst App = ({ name }: { name: string }): JSX.Element =\u0026gt; \u0026lt;div\u0026gt;{name}\u0026lt;/div\u0026gt;;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h40fc68507d\"\u003e React.FC / VFC\u003c/h3\u003e\u003cp\u003eReact.FC / VFC については、TypeSctriptを導入するのであれば不要と考えられるのでここでは取り上げません。（今の私の業務では使っていないのですが、もしなにか誤りやアドバイスがあれば是非ご教授ください…！）\u003cbr\u003e参考記事：\u003ca href=\"https://kray.jp/blog/dont-have-to-use-react-fc-and-react-vfc/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e【検証】React.FC と React.VFC はべつに使わなくていい説\u003c/a\u003e \u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h2e72b92d37\"\u003e useState　状態変数の型\u003c/h2\u003e\u003ch3 id=\"hde697c111e\"\u003e 型推論に任せる\u003c/h3\u003e\u003cp\u003euseStateフックでは初期値を与えれば状態変数の型を推論してくれます。\u003cbr\u003eなので極力初期値を与えて、推論させるようにします。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// プリミティブ値\nconst [name, setName] = useState(\"\")\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// string型\nconst [count, setCount] = useState(0)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// number型\nconst [isChecked, setIsCheked] = useState(false)\u0026nbsp;\u0026nbsp;// boolean型\n\n// 配列\nconst [colors, setColors] = useState([\"red\", \"blue\"])\u0026nbsp;\u0026nbsp;// string型の配列\nconst [numbers, setNumbers] = useState([1, 2, 3])\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// number型の配列\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h6b88d1350c\"\u003e ジェネリック型で指定する\u003c/h3\u003e\u003cul\u003e\u003cli\u003e 基本の指定方法\u003c/li\u003e\u003c/ul\u003e\u003cp\u003euseStateの状態変数に対して明示的に型を指定する場合は、ジェネリック型 \u003ccode\u003e\u0026lt;T\u0026gt;\u003c/code\u003e を使います。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// useStateのジェネリック型\u0026lt;T\u0026gt;に明示的に型を指定する\nconst [name, setName] = useState\u0026lt;string\u0026gt;(\"\")\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// string型\nconst [count, setCount] = useState\u0026lt;number\u0026gt;(0)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;// number型\nconst [isChecked, setIsChecked] = useState\u0026lt;boolean\u0026gt;(false)\u0026nbsp;\u0026nbsp;// boolean型\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e 別途定義した型をジェネリック型で指定する\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e別途定義したオブジェクトを初期値にしたり、別途定義した型をジェネリック型で指定することもできます。\u003cbr\u003e（型や初期値を複数のコンポーネントで使い回す場合や情報量が多くなる場合は、別ファイルに切り出しても良いかと思います。）\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst initialUser = {\n\u0026nbsp;number: 1,\n\u0026nbsp;name: '名前',\n\u0026nbsp;email: 'test@mail.com'\n}\n\ntype User = {\n\u0026nbsp;number: number\n\u0026nbsp;name: string\n\u0026nbsp;email: string\n}\n\nconst [user, setUser] = useState\u0026lt;User\u0026gt;(initialUser)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e ユニオン型でnullを含める \u003c/li\u003e\u003c/ul\u003e\u003cp\u003e値がnullの可能性があるときや、型は定めておきたいが初期値は後から決まるといった場合は、ユニオン型でnullを含めます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// nullを含む場合はユニオン型を用いる\nconst [count, setCount] = useState\u0026lt;number | null\u0026gt;(null)\u0026nbsp;\u0026nbsp;// number型もしくはnull型\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e 型アサーションを使う\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e状態変数の初期値が決まらないけれどnullは許可しないという場合には、型アサーションを使うことができます。\u003cbr\u003e\u003cbr\u003eまず、以下の書き方ではエラーが出ます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etype User = {\n\u0026nbsp;number: number\n\u0026nbsp;name: string\n\u0026nbsp;email: string\n}\n\nconst [user, setUser] = useState\u0026lt;User\u0026gt;({})\nuser[name] = 'ゲスト'\n\n// userは「空のオブジェクト型」とTypeScriptは認識するのでコンパイルエラーになる\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eそこで有効なのが型アサーションです。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etype User = {\n\u0026nbsp;number: number\n\u0026nbsp;name: string\n\u0026nbsp;email: string\n}\n\nconst [user, setUser] = useState\u0026lt;User\u0026gt;({} as User)\n\n// 型アサーションを使えばコンパイルエラーが出ない\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eただし型アサーションはTypeScriptに型を偽っているだけなので、もし必要なプロパティを忘れていてもコンパイラエラーが指摘してくれないので、なるべく初期値を設定して型アサーションを使わずに済む実装にした方がベターです。\u003cbr\u003e\u003cbr\u003eもし全てのプロパティが任意ならば、初期値に空オブジェクトを与えても問題ないので型アサーションは必要ありません。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etype User = {\u0026nbsp;\n\u0026nbsp;name?: string\n\u0026nbsp;email?: string\n\u0026nbsp;age?: number\n}\n\nconst [user, setUser] = useState\u0026lt;User\u0026gt;({})\n\n// userはUser型のうち任意のプロパティを持つ（空オブジェクトの可能性もある）\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h6553d2c03c\"\u003e useEffect\u003c/h2\u003e\u003cp\u003euseEffectの戻り値は \u003ccode\u003eundefined\u003c/code\u003e もしくはクリーンアップ関数と決められており、戻り値を処理しないため型は必要ありません。  \u003cbr\u003e\u003cbr\u003eただし関数や値を返してしまうとエラーになるので、アロー関数の書き方に注意が必要です。\u003cbr\u003e\u003cbr\u003e以下の書き方では、アロー関数式\u003ccode\u003e=\u0026gt;\u003c/code\u003eの本体に波括弧\u003ccode\u003e{}\u003c/code\u003eなしに1行で書いた文が戻り値になってしまいます。   \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003euseEffect(() =\u0026gt;\u0026nbsp;\n\u0026nbsp;setTimeout(() =\u0026gt;\u0026nbsp;\n\u0026nbsp;\u0026nbsp;// 処理\n\u0026nbsp;, 1000);\n, []);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e以下のように、本体を \u003ccode\u003e{}\u003c/code\u003e で囲むようにしてください。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003euseEffect(() =\u0026gt; {\n\u0026nbsp;setTimeout(() =\u0026gt; {\n\u0026nbsp;\u0026nbsp;// 処理\n\u0026nbsp;}, 1000);\n}, []);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h7cf02dc148\"\u003e イベントオブジェクトの型\u003c/h2\u003e\u003cp\u003eonClickやonChangeといったイベントハンドラで扱うイベントにも型があります。\u003cbr\u003e\u003cbr\u003eイベントオブジェクトの型を知りたいときは、VSCodeがヒントをくれます。\u003cbr\u003e\u003cbr\u003e例えばonClickなら、以下の状態でonClickの上にマウスをホバーさせると型情報を表示してくれます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;button onClick={}\u0026gt;\u0026lt;/button\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e以下のように要素のイベント属性に直接イベントハンドラを書く場合は、引数のイベントの型は推論されるので注釈が要りません。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;button onClick={(event) =\u0026gt; //処理 }\u0026gt;\u0026lt;/button\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eイベントハンドラの関数を別途定義する場合は、通常の関数と同様に型付けが必要になります。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h745a3f474e\"\u003e onClickイベント\u003c/h3\u003e\u003cp\u003e引数のイベントと戻り値に型付けをします。（戻り値は推論させてもOKです）\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Buttonクリックの場合\nconst onClickButton = ( event: React.MouseEvent\u0026lt;HTMLButtonElement, MouseEvent\u0026gt; ):void =\u0026gt; {\n\u0026nbsp;// 処理\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hc860cddeda\"\u003e onChangeイベント\u003c/h3\u003e\u003cpre\u003e\u003ccode\u003e// Inputの場合\nconst onChangeInput = ( event: React.ChangeEvent\u0026lt;HTMLInputElement\u0026gt;):void =\u0026gt; {\n\u0026nbsp;// 処理\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h0591b223f6\"\u003e 複数種類の要素にイベントを適用する\u003c/h3\u003e\u003cp\u003e上記の例を見ると、ジェネリック型の部分に \u003ccode\u003eHTMLButtonElement\u003c/code\u003e \u003ccode\u003eHTMLInputElement\u003c/code\u003e とあるように特定のHTML要素のための型であることがわかります。   \u003cbr\u003e\u003cbr\u003eもしDivタグ・Buttonタグ・Inputタグなどに同じイベントハンドラ関数を指定したい場合、通常は \u003ccode\u003eHTMLButtonElement | HTMLInputElement | 続く...\u003c/code\u003e と使いたい要素分の型を記述する必要があります。  \u003cbr\u003e\u003cbr\u003eそんな時は、色んなHTML要素に共通して使える \u003ccode\u003eHTMLElement\u003c/code\u003e 型を使うこともできます。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etype Props = {\n\u0026nbsp;onClick: (event: React.MouseEvent\u0026lt;HTMLElement, MouseEvent\u0026gt;) =\u0026gt; void\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e以下の記事に詳しくまとめられており、非常に分かりやすかったです。\u003cbr\u003e\u003cbr\u003e個人的には、精度を高めるためには面倒でも使う要素分だけ指定する方が良いのかな…？とも思いますが、 \u003ccode\u003eHTMLButtonElem ent\u003c/code\u003e  も\u003ccode\u003e HTMLInputElement\u003c/code\u003e も\u003ccode\u003eHTMLElement\u003c/code\u003e 型を継承しているんだと知り、勉強になりました。\u003cbr\u003e\u003ca href=\"https://qiita.com/Takepepe/items/f1ba99a7ca7e66290f24\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eany型で諦めない React.EventCallback - Qiita\u003c/a\u003e \u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hadc4cddfcc\"\u003e 【番外編】Axios\u003c/h2\u003e\u003cp\u003eAxiosを使って非同期通信を行う際に返されるレスポンスやエラーにも型があります。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport { AxiosError, AxiosResponse } from 'axios'\n\naxios\n\u0026nbsp;.get('/url')\n\u0026nbsp;.then((response: AxiosResponse) =\u0026gt; {\n\u0026nbsp;\u0026nbsp;// 成功時の処理\n\u0026nbsp;})\n\u0026nbsp;.catch((error: AxiosError) =\u0026gt; {\n\u0026nbsp;\u0026nbsp;// エラー時の処理\n\u0026nbsp;})\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h691cb018bd\"\u003e おわりに\u003c/h2\u003e\u003cp\u003e正直はじめは、何か書くたびにエラーが出るしコード量が増えて余計にわけわからんと思いました。\u003cbr\u003e\u003cbr\u003eでも慣れてくると、型が明示してあると処理の流れを追わなくてもどういう値が入って来るのかパッと見でも分かりやすいし、エディタの補完が効くのは便利で間違いがあれば気付けてTypeScript良いなと思うようになりました。\u003cbr\u003e\u003cbr\u003e今後もより実用的でスマートな型の活用法を学んでいきたいと思います。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h3937880ed1\"\u003e 参考記事\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://github.com/typescript-cheatsheets/react\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://github.com/typescript-cheatsheets/react\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e","tags":[{"id":"typescript","createdAt":"2022-01-07T13:18:58.358Z","updatedAt":"2022-02-17T03:22:47.524Z","publishedAt":"2022-01-07T13:18:58.358Z","revisedAt":"2022-02-17T03:22:47.524Z","tag":"TypeScript"},{"id":"react","createdAt":"2022-01-07T13:17:54.189Z","updatedAt":"2022-02-12T02:31:51.382Z","publishedAt":"2022-01-07T13:17:54.189Z","revisedAt":"2022-01-07T13:17:54.189Z","tag":"React"}],"image":"typescript"},"highlightedBody":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003ch2 id=\"h04bc4be39a\"\u003e はじめに\u003c/h2\u003e\u003cp\u003e業務でフロント側はReact（Next.js）, TypeScriptを使っているのですが、配属当初の私はReactにもTypeScriptにも触れたことが無く、何が分からないのか分からない状態でした。\u003cbr\u003e\u003cbr\u003eTypeScriptの基礎を学んでもReact特有の型定義があり戸惑いましたが、ようやく理解して書けるようになって来たな…ということで、辞書代わりにまとめておきます。\u003cbr\u003e（誤りのご指摘・アドバイスがあればぜひお願いします！）\u003cbr\u003e\u003c/p\u003e\u003ch1 id=\"h2e4995e418\"\u003e 基礎編\u003c/h1\u003e\u003cp\u003eまずは基本の型定義を一通り挙げます。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hd817cee2b9\"\u003e 関数コンポーネント\u003c/h2\u003e\u003cp\u003e関数コンポーネントでは、普通の関数と同じように引数（props）に型付けします。\u003cbr\u003e\u003cbr\u003e戻り値はJSX要素を返せば型推論されるので、明らかな場合は型付けしなくてOKです。\u003cbr\u003e\u003cbr\u003e※以下の例では、propsは分割代入の書き方で受け取るものとします。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h480940b7cc\"\u003e 引数（props）なしの場合\u003c/h3\u003e\u003cp\u003epropsを受け取らない場合は、JavaScriptで記述するときと変わりません。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ノーマルの関数コンポーネント（引数なしの場合）\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003eなまえ\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h40e5e6f6fd\"\u003e ひとつのpropsを受け取る\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 引数に型付けする\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ name }: { name: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e }\u003c/span\u003e) =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e{name}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 型エイリアスを使っても良い\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e }\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ name }: Props\u003c/span\u003e) =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e{name}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e型注釈を直接つけても、型エイリアスを使ってもOKです。\u003cbr\u003e\u003cbr\u003eプロジェクト内で合わせておけば良いかと思います。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h2ac392abf5\"\u003e 複数のpropsを受け取る\u003c/h3\u003e\u003cp\u003epropsを複数受け取る場合は、型注釈を直接つけるよりも型エイリアスを付けた方が分かりやすいでしょう。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 引数が複数なら、型エイリアスを使う方が見やすい\u003c/span\u003e\ntype Props = {\n\u0026nbsp;\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: srting\n\u0026nbsp;onClick: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\n\u0026nbsp;children: ReactNode\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h5f171d61d9\"\u003e propsの型いろいろ\u003c/h3\u003e\u003cp\u003e以下のように色々な型の値をpropsとして受け取ることができます。\u003cbr\u003eここはほとんどTypeScriptの基本通りです。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// propsとして受け取る値の型定義色々\u003c/span\u003e\ntype P\u003cspan class=\"hljs-attr\"\u003erops\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;str:\u003c/span\u003e string\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 文字列\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;num:\u003c/span\u003e number\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 数値\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;bool:\u003c/span\u003e boolean\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 真偽値\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;strArr:\u003c/span\u003e string[]\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 配列\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;obj:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// オブジェクト\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;\u0026nbsp;str:\u003c/span\u003e string\n\u0026nbsp;\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;objArr:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// オブジェクトの配列\u003c/span\u003e\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;\u0026nbsp;str:\u003c/span\u003e string\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;\u0026nbsp;num:\u003c/span\u003e number\n\u0026nbsp;\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e[]\n\u003cspan class=\"hljs-symbol\"\u003e\u0026nbsp;func:\u003c/span\u003e () =\u0026gt; void\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 関数\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"ha7733746f8\"\u003e children\u003c/h3\u003e\u003cp\u003echildrenはコンポーネントのタグで囲った子要素をpropsとして受け取るときに使います。\u003cbr\u003e\u003cbr\u003eよく使うのはReactNodeで、これはコンポーネントタグで囲ったJSX要素をまるっと受け取る場合に使います。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 共通レイアウトのコンポーネント\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMainLayout\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ children }: { children: React.ReactNode }\u003c/span\u003e) =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eHeader\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{children}\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eFooter\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026nbsp;)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 呼び出し側\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMenuPage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eMainLayout\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;// この中にページの内容を書く\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eMainLayout\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026nbsp;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eもし特定の文字列や数値しか受け取らないというような場合は、ReactNodeではなく特定の型に制限することもできます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Buttonコンポーネント\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eButton\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ children }: { children: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e }\u003c/span\u003e) =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026nbsp;)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 呼び出し側\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u0026gt;\u003c/span\u003e\n// フォームの記述があるとする\n\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u0026gt;\u003c/span\u003e送信\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u0026gt;\u003c/span\u003e戻る\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026nbsp;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eちなみにReactNodeは以下の通りのUnion型で定義されています。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003etype ReactNode = ReactChild | \u003cspan class=\"hljs-type\"\u003eReactFragment\u003c/span\u003e | \u003cspan class=\"hljs-type\"\u003eReactPortal\u003c/span\u003e | \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e | \u003cspan class=\"hljs-type\"\u003enull\u003c/span\u003e | \u003cspan class=\"hljs-type\"\u003eundefined\u003c/span\u003e;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h31df23c0b3\"\u003e propsのデフォルト値を指定する\u003c/h3\u003e\u003cp\u003eコンポーネントの利用箇所ごとにpropsに渡す値を指定してもよいのですが、デフォルト値を指定することもできます。\u003cbr\u003eよく指定される値がある時や、値が無かった場合の値を決めておきたい場合に有効です。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eName\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ name = \u003cspan class=\"hljs-string\"\u003e\"ゲスト\"\u003c/span\u003e }: { name?: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e }\u003c/span\u003e) =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e{name}さん\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h5be2f009d7\"\u003e オプショナルなprops（undefined許容）\u003c/h3\u003e\u003cp\u003e\u003ccode\u003e?\u003c/code\u003e を付けることでオプショナルな型定義が出来ます。  \u003cbr\u003e以下のように書いた場合、name・emailの型は\u003ccode\u003estring | undefined\u003c/code\u003eとなります。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003etype Props = {\n\u0026nbsp;\u003cspan class=\"hljs-built_in\"\u003ename\u003c/span\u003e?: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n\u0026nbsp;email?: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eこの場合はundefinedの可能性を考慮してpropsの初期値を設定するか、値の有無による条件分岐を行います。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// nameは初期値を設定、emailはpropsの値が渡された場合のみ表示する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eButton\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ name = \u003cspan class=\"hljs-string\"\u003e'ゲスト'\u003c/span\u003e, email }: Props\u003c/span\u003e) =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e{name}さん\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;{email \u0026amp;\u0026amp; (\n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003eemail:{email}\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;\u0026nbsp;)}\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u0026nbsp;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h61a1261837\"\u003e 戻り値の型付け\u003c/h3\u003e\u003cp\u003eJSX要素を返せば型を指定していなくても推論してくれますが、明示しておけば正しい値が返されなかった場合エラーを表示してくれます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003econst App = ({\u003cspan class=\"hljs-built_in\"\u003e name\u003c/span\u003e }: {\u003cspan class=\"hljs-built_in\"\u003e name\u003c/span\u003e:\u003cspan class=\"hljs-built_in\"\u003e string\u003c/span\u003e }): JSX.Element =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"language-xquery\"\u003e\u003cspan class=\"hljs-built_in\"\u003e{name\u003c/span\u003e}\u003c/span\u003e\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h40fc68507d\"\u003e React.FC / VFC\u003c/h3\u003e\u003cp\u003eReact.FC / VFC については、TypeSctriptを導入するのであれば不要と考えられるのでここでは取り上げません。（今の私の業務では使っていないのですが、もしなにか誤りやアドバイスがあれば是非ご教授ください…！）\u003cbr\u003e参考記事：\u003ca href=\"https://kray.jp/blog/dont-have-to-use-react-fc-and-react-vfc/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e【検証】React.FC と React.VFC はべつに使わなくていい説\u003c/a\u003e \u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h2e72b92d37\"\u003e useState　状態変数の型\u003c/h2\u003e\u003ch3 id=\"hde697c111e\"\u003e 型推論に任せる\u003c/h3\u003e\u003cp\u003euseStateフックでは初期値を与えれば状態変数の型を推論してくれます。\u003cbr\u003eなので極力初期値を与えて、推論させるようにします。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// プリミティブ値\u003c/span\u003e\nconst \u003cspan class=\"hljs-selector-attr\"\u003e[name, setName]\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// string型\u003c/span\u003e\nconst \u003cspan class=\"hljs-selector-attr\"\u003e[count, setCount]\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// number型\u003c/span\u003e\nconst \u003cspan class=\"hljs-selector-attr\"\u003e[isChecked, setIsCheked]\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003euseState\u003c/span\u003e(false)\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// boolean型\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 配列\u003c/span\u003e\nconst \u003cspan class=\"hljs-selector-attr\"\u003e[colors, setColors]\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-selector-attr\"\u003e[\u003cspan class=\"hljs-string\"\u003e\"red\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"blue\"\u003c/span\u003e]\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// string型の配列\u003c/span\u003e\nconst \u003cspan class=\"hljs-selector-attr\"\u003e[numbers, setNumbers]\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-selector-attr\"\u003e[1, 2, 3]\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// number型の配列\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h6b88d1350c\"\u003e ジェネリック型で指定する\u003c/h3\u003e\u003cul\u003e\u003cli\u003e 基本の指定方法\u003c/li\u003e\u003c/ul\u003e\u003cp\u003euseStateの状態変数に対して明示的に型を指定する場合は、ジェネリック型 \u003ccode\u003e\u0026lt;T\u0026gt;\u003c/code\u003e を使います。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// useStateのジェネリック型\u0026lt;T\u0026gt;に明示的に型を指定する\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [name, setName] = useState\u0026lt;\u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e\u0026gt;(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// string型\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = useState\u0026lt;\u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\u0026gt;(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// number型\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [isChecked, setIsChecked] = useState\u0026lt;\u003cspan class=\"hljs-built_in\"\u003eboolean\u003c/span\u003e\u0026gt;(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// boolean型\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e 別途定義した型をジェネリック型で指定する\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e別途定義したオブジェクトを初期値にしたり、別途定義した型をジェネリック型で指定することもできます。\u003cbr\u003e（型や初期値を複数のコンポーネントで使い回す場合や情報量が多くなる場合は、別ファイルに切り出しても良いかと思います。）\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003econst initialUser = {\n\u003cspan class=\"hljs-built_in\"\u003e\u0026nbsp;number\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n\u003cspan class=\"hljs-built_in\"\u003e\u0026nbsp;name\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'名前'\u003c/span\u003e,\n\u0026nbsp;email: \u003cspan class=\"hljs-string\"\u003e'test@mail.com'\u003c/span\u003e\n}\n\ntype User = {\n\u003cspan class=\"hljs-built_in\"\u003e\u0026nbsp;number\u003c/span\u003e:\u003cspan class=\"hljs-built_in\"\u003e number\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003e\u0026nbsp;name\u003c/span\u003e:\u003cspan class=\"hljs-built_in\"\u003e string\u003c/span\u003e\n\u0026nbsp;email:\u003cspan class=\"hljs-built_in\"\u003e string\u003c/span\u003e\n}\n\nconst [user, setUser] = useState\u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eUser\u003c/span\u003e\u0026gt;\u003c/span\u003e(initialUser)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e ユニオン型でnullを含める \u003c/li\u003e\u003c/ul\u003e\u003cp\u003e値がnullの可能性があるときや、型は定めておきたいが初期値は後から決まるといった場合は、ユニオン型でnullを含めます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e// \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003eを含む場合はユニオン型を用いる\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = useState\u0026lt;\u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\u0026gt;(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e)\u0026nbsp;\u0026nbsp;// \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e型もしくは\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e型\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e 型アサーションを使う\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e状態変数の初期値が決まらないけれどnullは許可しないという場合には、型アサーションを使うことができます。\u003cbr\u003e\u003cbr\u003eまず、以下の書き方ではエラーが出ます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eUser\u003c/span\u003e = {\n\u0026nbsp;number: number\n\u0026nbsp;\u003cspan class=\"hljs-type\"\u003ename\u003c/span\u003e: string\n\u0026nbsp;email: string\n}\n\nconst [\u003cspan class=\"hljs-keyword\"\u003euser\u003c/span\u003e, setUser] = useState\u0026lt;\u003cspan class=\"hljs-keyword\"\u003eUser\u003c/span\u003e\u0026gt;({})\n\u003cspan class=\"hljs-keyword\"\u003euser\u003c/span\u003e[\u003cspan class=\"hljs-type\"\u003ename\u003c/span\u003e] = \u003cspan class=\"hljs-string\"\u003e'ゲスト'\u003c/span\u003e\n\n// \u003cspan class=\"hljs-keyword\"\u003euser\u003c/span\u003eは「空のオブジェクト型」とTypeScriptは認識するのでコンパイルエラーになる\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eそこで有効なのが型アサーションです。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003e= {\n\u0026nbsp;number\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enumber\u003c/span\u003e\n\u0026nbsp;name: \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e\n\u0026nbsp;email: \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e\n}\n\nconst [user, setUser] = useState\u003cspan class=\"hljs-tag\"\u003e\u0026lt;User\u0026gt;\u003c/span\u003e({} as User)\n\n// 型アサーションを使えばコンパイルエラーが出ない\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eただし型アサーションはTypeScriptに型を偽っているだけなので、もし必要なプロパティを忘れていてもコンパイラエラーが指摘してくれないので、なるべく初期値を設定して型アサーションを使わずに済む実装にした方がベターです。\u003cbr\u003e\u003cbr\u003eもし全てのプロパティが任意ならば、初期値に空オブジェクトを与えても問題ないので型アサーションは必要ありません。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003e= {\u0026nbsp;\n\u0026nbsp;name\u003c/span\u003e?: \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e\n\u0026nbsp;email?: \u003cspan class=\"hljs-keyword\"\u003estring\u003c/span\u003e\n\u0026nbsp;age?: \u003cspan class=\"hljs-keyword\"\u003enumber\u003c/span\u003e\n}\n\nconst [user, setUser] = useState\u003cspan class=\"hljs-tag\"\u003e\u0026lt;User\u0026gt;\u003c/span\u003e({})\n\n// userはUser型のうち任意のプロパティを持つ（空オブジェクトの可能性もある）\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h6553d2c03c\"\u003e useEffect\u003c/h2\u003e\u003cp\u003euseEffectの戻り値は \u003ccode\u003eundefined\u003c/code\u003e もしくはクリーンアップ関数と決められており、戻り値を処理しないため型は必要ありません。  \u003cbr\u003e\u003cbr\u003eただし関数や値を返してしまうとエラーになるので、アロー関数の書き方に注意が必要です。\u003cbr\u003e\u003cbr\u003e以下の書き方では、アロー関数式\u003ccode\u003e=\u0026gt;\u003c/code\u003eの本体に波括弧\u003ccode\u003e{}\u003c/code\u003eなしに1行で書いた文が戻り値になってしまいます。   \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003euseEffect(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e\u0026nbsp;\n\u0026nbsp;\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e\u0026nbsp;\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e 処理\n\u0026nbsp;, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n, []);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e以下のように、本体を \u003ccode\u003e{}\u003c/code\u003e で囲むようにしてください。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003euseEffect(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n\u0026nbsp;\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e 処理\n\u0026nbsp;}, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n}, []);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h7cf02dc148\"\u003e イベントオブジェクトの型\u003c/h2\u003e\u003cp\u003eonClickやonChangeといったイベントハンドラで扱うイベントにも型があります。\u003cbr\u003e\u003cbr\u003eイベントオブジェクトの型を知りたいときは、VSCodeがヒントをくれます。\u003cbr\u003e\u003cbr\u003e例えばonClickなら、以下の状態でonClickの上にマウスをホバーさせると型情報を表示してくれます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{}\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e以下のように要素のイベント属性に直接イベントハンドラを書く場合は、引数のイベントの型は推論されるので注釈が要りません。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(event)\u003c/span\u003e =\u0026gt;\u003c/span\u003e //処理 }\u0026gt;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eイベントハンドラの関数を別途定義する場合は、通常の関数と同様に型付けが必要になります。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h745a3f474e\"\u003e onClickイベント\u003c/h3\u003e\u003cp\u003e引数のイベントと戻り値に型付けをします。（戻り値は推論させてもOKです）\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Buttonクリックの場合\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e onClickButton = ( \u003cspan class=\"hljs-keyword\"\u003eevent\u003c/span\u003e: React.MouseEvent\u0026lt;HTMLButtonElement, MouseEvent\u0026gt; ):\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 処理\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hc860cddeda\"\u003e onChangeイベント\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Inputの場合\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e onChangeInput = ( \u003cspan class=\"hljs-keyword\"\u003eevent\u003c/span\u003e: React.ChangeEvent\u0026lt;HTMLInputElement\u0026gt;):\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-comment\"\u003e// 処理\u003c/span\u003e\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h0591b223f6\"\u003e 複数種類の要素にイベントを適用する\u003c/h3\u003e\u003cp\u003e上記の例を見ると、ジェネリック型の部分に \u003ccode\u003eHTMLButtonElement\u003c/code\u003e \u003ccode\u003eHTMLInputElement\u003c/code\u003e とあるように特定のHTML要素のための型であることがわかります。   \u003cbr\u003e\u003cbr\u003eもしDivタグ・Buttonタグ・Inputタグなどに同じイベントハンドラ関数を指定したい場合、通常は \u003ccode\u003eHTMLButtonElement | HTMLInputElement | 続く...\u003c/code\u003e と使いたい要素分の型を記述する必要があります。  \u003cbr\u003e\u003cbr\u003eそんな時は、色んなHTML要素に共通して使える \u003ccode\u003eHTMLElement\u003c/code\u003e 型を使うこともできます。  \u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eProps\u003c/span\u003e = {\n\u0026nbsp;onClick: (event: \u003cspan class=\"hljs-type\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-type\"\u003eMouseEvent\u003c/span\u003e\u0026lt;\u003cspan class=\"hljs-type\"\u003eHTMLElement\u003c/span\u003e, \u003cspan class=\"hljs-type\"\u003eMouseEvent\u003c/span\u003e\u0026gt;) =\u0026gt; void\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e以下の記事に詳しくまとめられており、非常に分かりやすかったです。\u003cbr\u003e\u003cbr\u003e個人的には、精度を高めるためには面倒でも使う要素分だけ指定する方が良いのかな…？とも思いますが、 \u003ccode\u003eHTMLButtonElem ent\u003c/code\u003e  も\u003ccode\u003e HTMLInputElement\u003c/code\u003e も\u003ccode\u003eHTMLElement\u003c/code\u003e 型を継承しているんだと知り、勉強になりました。\u003cbr\u003e\u003ca href=\"https://qiita.com/Takepepe/items/f1ba99a7ca7e66290f24\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eany型で諦めない React.EventCallback - Qiita\u003c/a\u003e \u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hadc4cddfcc\"\u003e 【番外編】Axios\u003c/h2\u003e\u003cp\u003eAxiosを使って非同期通信を行う際に返されるレスポンスやエラーにも型があります。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { AxiosError, AxiosResponse } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'axios'\u003c/span\u003e\n\naxios\n\u0026nbsp;.get(\u003cspan class=\"hljs-string\"\u003e'/url'\u003c/span\u003e)\n\u0026nbsp;.\u003cspan class=\"hljs-keyword\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e(response: AxiosResponse)\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e 成功時の処理\n\u0026nbsp;})\n\u0026nbsp;.\u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e(error: AxiosError)\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n\u0026nbsp;\u0026nbsp;\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e エラー時の処理\n\u0026nbsp;})\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h691cb018bd\"\u003e おわりに\u003c/h2\u003e\u003cp\u003e正直はじめは、何か書くたびにエラーが出るしコード量が増えて余計にわけわからんと思いました。\u003cbr\u003e\u003cbr\u003eでも慣れてくると、型が明示してあると処理の流れを追わなくてもどういう値が入って来るのかパッと見でも分かりやすいし、エディタの補完が効くのは便利で間違いがあれば気付けてTypeScript良いなと思うようになりました。\u003cbr\u003e\u003cbr\u003e今後もより実用的でスマートな型の活用法を学んでいきたいと思います。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h3937880ed1\"\u003e 参考記事\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://github.com/typescript-cheatsheets/react\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://github.com/typescript-cheatsheets/react\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e"},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"react-typescript"},"buildId":"EwuWiZmkeG3lYlO_XC9fM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
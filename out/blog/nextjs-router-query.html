<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4bc12c1be68739c7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4bc12c1be68739c7.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d58b9228ffac9a6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d58b9228ffac9a6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-101cfeaa18eb0e64.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5a602b05d6a5b45c.js" defer=""></script><script src="/_next/static/chunks/451-8446afed8f2a81ca.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-7b5e07e6b1c54b77.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_buildManifest.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_ssgManifest.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style data-emotion="css a6by8m">.css-a6by8m{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;margin:auto;}</style><div class="MuiGrid-root MuiGrid-container css-a6by8m"><style data-emotion="css d0aeej">.css-d0aeej{background-color:#FFF;color:#222;margin:30px auto;padding:36px;}.css-d0aeej h1,.css-d0aeej h2,.css-d0aeej h3{font-weight:550;}</style><style data-emotion="css vx8k43">.css-vx8k43{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:91.666667%;-ms-flex-preferred-size:91.666667%;flex-basis:91.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:91.666667%;background-color:#FFF;color:#222;margin:30px auto;padding:36px;}@media (min-width:600px){.css-vx8k43{-webkit-flex-basis:91.666667%;-ms-flex-preferred-size:91.666667%;flex-basis:91.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:91.666667%;}}@media (min-width:900px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1200px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1536px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}.css-vx8k43 h1,.css-vx8k43 h2,.css-vx8k43 h3{font-weight:550;}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-11 MuiGrid-grid-md-9 css-vx8k43"><style data-emotion="css tph460">.css-tph460{padding:15px 0px;border-bottom:1px solid #4682B4;}</style><div class="css-tph460"><style data-emotion="css 1x4m838">.css-1x4m838{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;font-size:26px;font-weight:540;padding-bottom:16px;}</style><p class="MuiTypography-root MuiTypography-body1 css-1x4m838">Next.jsのrouter.queryでURLの動的パラメータを取得するときの注意</p><style data-emotion="css q5vujz">.css-q5vujz{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;display:inline-block;padding-right:32px;}</style><p class="MuiTypography-root MuiTypography-body2 css-q5vujz"><style data-emotion="css 1eipbkb">.css-1eipbkb{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;font-size:15px;margin-right:4px;vertical-align:middle;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1eipbkb" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="AccessTimeIcon"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path><path d="M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></svg>投稿日 <!-- -->2022/1/25</p><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1eipbkb" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LocalOfferIcon"><path d="m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z"></path></svg><style data-emotion="css 1lc4u9f">.css-1lc4u9f{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;display:inline-block;padding-right:8px;}</style><p class="MuiTypography-root MuiTypography-body2 css-1lc4u9f">#<!-- -->Next.js</p><p class="MuiTypography-root MuiTypography-body2 css-1lc4u9f">#<!-- -->React</p></div><style data-emotion="css il3arz">.css-il3arz{margin-top:40px;}.css-il3arz a{color:#639bb7;}.css-il3arz a:hover{color:#0b7eb8;-webkit-text-decoration:underline;text-decoration:underline;}</style><div class="css-il3arz"><html><head></head><body><p>業務で、useEffect内でNext.jsのuseRouterを使ってクエリパラメータを取得しようとした際、意図する通りの挙動をしておらず戸惑ったので備忘録としてまとめておきます。<br><br>通常<strong>pages/blogs/[id].tsx</strong>のようなファイルにおいてAPIからデータを取得したい場合、<code>getStaticPaths</code>・<code>getStaticProps</code>を使うかと思いますが、今回は画面描画してからバックグラウンドでAPIリクエストを行ってデータ取得する必要があり、そこで見つけたのが<code>useRouter</code>の<code>router.query</code>でした。 <br></p><h2 id="h5752334b14"> useRouterとは</h2><p>そもそもuseRouterとは、Next.jsが用意しているhooksの一つで、routeに関する色んな情報を持つrouterオブジェクトへのアクセスを提供するものです。<br></p><blockquote> アプリの関数コンポーネント内の<code>router</code>オブジェクトにアクセスする場合は、<code>useRouter</code>フックを使用できます。   <br><code>useRouter</code>はReactフックです。  <br>&nbsp;<a href="https://nextjs.org/docs/api-reference/next/router#userouter" target="_blank" rel="noopener noreferrer">https://nextjs.org/docs/api-reference/next/router#userouter</a> </blockquote><p><br>routerオブジェクトはいくつもの便利なメソッドやプロパティを持ちますが、その中のひとつにqueryがあります。<br></p><h2 id="h6a9e501b40"> router.queryの使い方</h2><p>&nbsp;<code>router.query</code> とするだけで、オブジェクト形式で動的ルーティングの中身を取得できます。  <br><br>ちなみに以下の例のようにクエリパラメータが数字の場合も、string型で取得されます。<br> </p><pre><code class="hljs">import { useRouter } from <span class="hljs-string">'next/router'</span>

<span class="hljs-regexp">//</span> 関数コンポーネント内にて
&nbsp;const router = useRouter()
&nbsp;console.log(router.query)
&nbsp;console.log(router.query.id)

<span class="hljs-regexp">//</span> 出力結果(localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/blogs/</span><span class="hljs-number">1</span> の場合)
<span class="hljs-regexp">//</span> { id: <span class="hljs-string">'1'</span> }
<span class="hljs-regexp">//</span> <span class="hljs-number">1</span></code></pre><p><br></p><h2 id="h970271505b"> useEffect内でrouter.queryを使ってみる</h2><p><code>pages/blogs/[id].tsx</code>の<code>useEffect</code>内で<code>router.query</code>を使ってみます。<br></p><pre><code class="hljs">const router = <span class="hljs-built_in">useRouter</span>()

<span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span> =&gt; {
&nbsp;const routeId = router<span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.id</span>
&nbsp;console<span class="hljs-selector-class">.log</span>(routeId)
}, <span class="hljs-selector-attr">[]</span>)

<span class="hljs-comment">// undefined </span></code></pre><p><br>出力されたのは <code>undefinde</code> でした。  <br><br>どうやら、router.queryの取得は<code>useEffect</code>の発火タイミングより後のようです。<br><br>【注】ただし、チームの中には上記のコードでもundefindeにならずqueryが取れている方もいましたし、私の環境でも時によってはqueryが取れることもありました。いずれにせよ不安定なものと思われるので、以下の対処をしておくのが無難なのかなと思います。<br>（ご存じの方はぜひご指導・ご指摘ください…！）<br></p><h3 id="hc1efd68684"> useEffectの依存配列にrouterを指定する</h3><p>依存配列に<code>router</code>を入れてみました。<br></p><pre><code class="hljs">const router = <span class="hljs-built_in">useRouter</span>()&nbsp;

<span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span> =&gt; {
&nbsp;const routeId = router<span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.id</span>
&nbsp;console<span class="hljs-selector-class">.log</span>(routeId)
}, <span class="hljs-selector-attr">[router]</span>)

<span class="hljs-comment">// 出力結果(localhost:3000/blogs/1 の場合)</span>
<span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// 1</span></code></pre><p><br>すると、一度<code>undefinde</code>と出た後に<code>query</code>が取れてコンソールに出力されました。<br><br>これで目的を果たせる場合もあるかもしれません。<br><br>しかし今回私が実装したかった要件は、取得したルートパラメーターを使ったパスでAPIへリクエストを送るというものです。<br>undefinedを取得してしまうと <code>'/api/blogs/undefined'</code>のパスにリクエストを送ってしまい、これは不都合でした。  <br></p><h3 id="h2f530575d0"> isReadyを使ってrouter情報が準備されているか判別する</h3><p>辿り着いたコードは以下の通りです。<br> </p><pre><code class="hljs">const router = <span class="hljs-built_in">useRouter</span>()

<span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span> =&gt; {
&nbsp;<span class="hljs-keyword">if</span> (router.isReady) {
&nbsp;&nbsp;const routeId = router<span class="hljs-selector-class">.query</span><span class="hljs-selector-class">.id</span>
&nbsp;&nbsp;console<span class="hljs-selector-class">.log</span>(routeId)
&nbsp;}
}, <span class="hljs-selector-attr">[router]</span>)

<span class="hljs-comment">// 出力結果(localhost:3000/blogs/1 の場合)</span>
<span class="hljs-comment">// 1</span></code></pre><p><br>routerオブジェクトの持つ <code>isReady</code> というboolean値が最適でした。  <br></p><blockquote> <code>isReady</code>：<code>boolean</code>　ルーターフィールドがクライアント側で更新され、使用できる状態になっているかどうか。<code>useEffect</code>メソッド内でのみ使用する必要があり、サーバーで条件付きでレンダリングするためには使用しないでください。    <br>&nbsp;<a href="https://nextjs.org/docs/api-reference/next/router#router-object" target="_blank" rel="noopener noreferrer">https://nextjs.org/docs/api-reference/next/router#router-object</a> </blockquote><p><br></p><h2 id="hf6e0a9e212"> なぜundefindeが取得されていたのか</h2><p>queryの取得タイミングはuseEffectの発火よりも後なのだということは何となく察しましたが、どういう仕組みなのか気になります。<br><br>Next.jsのドキュメントのダイナミックルーティングについての箇所に、以下のように書かれていました。<br></p><blockquote> Pages that are statically optimized by [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimizat<a href="https://nextjs.org/docs/advanced-features/automatic-static-optimization" target="_blank" rel="noopener noreferrer">Automatic Static Optimization</a> <br> After hydration, Next.js will trigger an update to your application to provide the route parameters in the <code>query</code> object.  </blockquote><p><br>Pre-renderingの間はqueryは空のオブジェクトであり、hydrationのプロセスが終わった段階でqueryオブジェクトが提供されると書いてあります。<br><br>getStaticPropsやgetSererSidePropsの処理が終わるまでは、queryは空なのですね。<br><br>hydrationという単語は初めて知りましたが、Next.jsの公式の図を見るとイメージは湧きました。<br><img src="https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/a9c4b88b0bb24532bb598719b0bf4137/pre-rendering.png" alt=""><br><br></p><h2 id="h3937880ed1"> 参考記事</h2><p><a href="https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a" target="_blank" rel="noopener noreferrer">https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a</a><br><br><a href="https://zenn.dev/luvmini511/articles/1523113e0dec58" target="_blank" rel="noopener noreferrer">https://zenn.dev/luvmini511/articles/1523113e0dec58</a><br></p></body></html></div></div></div><style data-emotion="css 2sbw87">.css-2sbw87{background-color:#494949;margin:0 auto;padding-top:30px;padding-bottom:30px;color:#f2f2f2;letter-spacing:0.08rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-around;-ms-flex-pack:space-around;-webkit-justify-content:space-around;justify-content:space-around;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style><div class="css-2sbw87"><style data-emotion="css kta5xp">.css-kta5xp{box-sizing:border-box;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:83.333333%;-ms-flex-preferred-size:83.333333%;flex-basis:83.333333%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:83.333333%;}@media (min-width:600px){.css-kta5xp{-webkit-flex-basis:83.333333%;-ms-flex-preferred-size:83.333333%;flex-basis:83.333333%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:83.333333%;}}@media (min-width:900px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}@media (min-width:1200px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}@media (min-width:1536px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}</style><div class="MuiGrid-root MuiGrid-grid-xs-10 MuiGrid-grid-md-8 css-kta5xp"><style data-emotion="css 1lx0lai">.css-1lx0lai{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;text-align:center;}</style><div class="MuiGrid-root MuiGrid-item css-1lx0lai"><a href="https://twitter.com/napi_nami"><style data-emotion="css 1ea777n">.css-1ea777n{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;margin:8px;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1ea777n" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="TwitterIcon"><path d="M22.46 6c-.77.35-1.6.58-2.46.69.88-.53 1.56-1.37 1.88-2.38-.83.5-1.75.85-2.72 1.05C18.37 4.5 17.26 4 16 4c-2.35 0-4.27 1.92-4.27 4.29 0 .34.04.67.11.98C8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15 0 1.49.75 2.81 1.91 3.56-.71 0-1.37-.2-1.95-.5v.03c0 2.08 1.48 3.82 3.44 4.21a4.22 4.22 0 0 1-1.93.07 4.28 4.28 0 0 0 4 2.98 8.521 8.521 0 0 1-5.33 1.84c-.34 0-.68-.02-1.02-.06C3.44 20.29 5.7 21 8.12 21 16 21 20.33 14.46 20.33 8.79c0-.19 0-.37-.01-.56.84-.6 1.56-1.36 2.14-2.23z"></path></svg></a><a href="https://github.com/hinakonagao"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1ea777n" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></div><style data-emotion="css 198jr53">.css-198jr53{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;text-align:center;font-weight:200;}</style><p class="MuiTypography-root MuiTypography-body2 css-198jr53">© 2022 hinako blog</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"id":"nextjs-router-query","createdAt":"2022-02-12T10:12:00.712Z","updatedAt":"2022-02-12T10:24:05.297Z","publishedAt":"2022-01-25T10:12:00.000Z","revisedAt":"2022-02-12T10:21:40.124Z","title":"Next.jsのrouter.queryでURLの動的パラメータを取得するときの注意","body":"\u003cp\u003e業務で、useEffect内でNext.jsのuseRouterを使ってクエリパラメータを取得しようとした際、意図する通りの挙動をしておらず戸惑ったので備忘録としてまとめておきます。\u003cbr\u003e\u003cbr\u003e通常\u003cstrong\u003epages/blogs/[id].tsx\u003c/strong\u003eのようなファイルにおいてAPIからデータを取得したい場合、\u003ccode\u003egetStaticPaths\u003c/code\u003e・\u003ccode\u003egetStaticProps\u003c/code\u003eを使うかと思いますが、今回は画面描画してからバックグラウンドでAPIリクエストを行ってデータ取得する必要があり、そこで見つけたのが\u003ccode\u003euseRouter\u003c/code\u003eの\u003ccode\u003erouter.query\u003c/code\u003eでした。 \u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h5752334b14\"\u003e useRouterとは\u003c/h2\u003e\u003cp\u003eそもそもuseRouterとは、Next.jsが用意しているhooksの一つで、routeに関する色んな情報を持つrouterオブジェクトへのアクセスを提供するものです。\u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e アプリの関数コンポーネント内の\u003ccode\u003erouter\u003c/code\u003eオブジェクトにアクセスする場合は、\u003ccode\u003euseRouter\u003c/code\u003eフックを使用できます。   \u003cbr\u003e\u003ccode\u003euseRouter\u003c/code\u003eはReactフックです。  \u003cbr\u003e\u0026nbsp;\u003ca href=\"https://nextjs.org/docs/api-reference/next/router#userouter\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://nextjs.org/docs/api-reference/next/router#userouter\u003c/a\u003e \u003c/blockquote\u003e\u003cp\u003e\u003cbr\u003erouterオブジェクトはいくつもの便利なメソッドやプロパティを持ちますが、その中のひとつにqueryがあります。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h6a9e501b40\"\u003e router.queryの使い方\u003c/h2\u003e\u003cp\u003e\u0026nbsp;\u003ccode\u003erouter.query\u003c/code\u003e とするだけで、オブジェクト形式で動的ルーティングの中身を取得できます。  \u003cbr\u003e\u003cbr\u003eちなみに以下の例のようにクエリパラメータが数字の場合も、string型で取得されます。\u003cbr\u003e \u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport { useRouter } from 'next/router'\n\n// 関数コンポーネント内にて\n\u0026nbsp;const router = useRouter()\n\u0026nbsp;console.log(router.query)\n\u0026nbsp;console.log(router.query.id)\n\n// 出力結果(localhost:3000/blogs/1 の場合)\n// { id: '1' }\n// 1\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h970271505b\"\u003e useEffect内でrouter.queryを使ってみる\u003c/h2\u003e\u003cp\u003e\u003ccode\u003epages/blogs/[id].tsx\u003c/code\u003eの\u003ccode\u003euseEffect\u003c/code\u003e内で\u003ccode\u003erouter.query\u003c/code\u003eを使ってみます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst router = useRouter()\n\nuseEffect(() =\u0026gt; {\n\u0026nbsp;const routeId = router.query.id\n\u0026nbsp;console.log(routeId)\n}, [])\n\n// undefined \u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e出力されたのは \u003ccode\u003eundefinde\u003c/code\u003e でした。  \u003cbr\u003e\u003cbr\u003eどうやら、router.queryの取得は\u003ccode\u003euseEffect\u003c/code\u003eの発火タイミングより後のようです。\u003cbr\u003e\u003cbr\u003e【注】ただし、チームの中には上記のコードでもundefindeにならずqueryが取れている方もいましたし、私の環境でも時によってはqueryが取れることもありました。いずれにせよ不安定なものと思われるので、以下の対処をしておくのが無難なのかなと思います。\u003cbr\u003e（ご存じの方はぜひご指導・ご指摘ください…！）\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hc1efd68684\"\u003e useEffectの依存配列にrouterを指定する\u003c/h3\u003e\u003cp\u003e依存配列に\u003ccode\u003erouter\u003c/code\u003eを入れてみました。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst router = useRouter()\u0026nbsp;\n\nuseEffect(() =\u0026gt; {\n\u0026nbsp;const routeId = router.query.id\n\u0026nbsp;console.log(routeId)\n}, [router])\n\n// 出力結果(localhost:3000/blogs/1 の場合)\n// undefined\n// 1\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eすると、一度\u003ccode\u003eundefinde\u003c/code\u003eと出た後に\u003ccode\u003equery\u003c/code\u003eが取れてコンソールに出力されました。\u003cbr\u003e\u003cbr\u003eこれで目的を果たせる場合もあるかもしれません。\u003cbr\u003e\u003cbr\u003eしかし今回私が実装したかった要件は、取得したルートパラメーターを使ったパスでAPIへリクエストを送るというものです。\u003cbr\u003eundefinedを取得してしまうと \u003ccode\u003e'/api/blogs/undefined'\u003c/code\u003eのパスにリクエストを送ってしまい、これは不都合でした。  \u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h2f530575d0\"\u003e isReadyを使ってrouter情報が準備されているか判別する\u003c/h3\u003e\u003cp\u003e辿り着いたコードは以下の通りです。\u003cbr\u003e \u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst router = useRouter()\n\nuseEffect(() =\u0026gt; {\n\u0026nbsp;if (router.isReady) {\n\u0026nbsp;\u0026nbsp;const routeId = router.query.id\n\u0026nbsp;\u0026nbsp;console.log(routeId)\n\u0026nbsp;}\n}, [router])\n\n// 出力結果(localhost:3000/blogs/1 の場合)\n// 1\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003erouterオブジェクトの持つ \u003ccode\u003eisReady\u003c/code\u003e というboolean値が最適でした。  \u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e \u003ccode\u003eisReady\u003c/code\u003e：\u003ccode\u003eboolean\u003c/code\u003e　ルーターフィールドがクライアント側で更新され、使用できる状態になっているかどうか。\u003ccode\u003euseEffect\u003c/code\u003eメソッド内でのみ使用する必要があり、サーバーで条件付きでレンダリングするためには使用しないでください。    \u003cbr\u003e\u0026nbsp;\u003ca href=\"https://nextjs.org/docs/api-reference/next/router#router-object\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://nextjs.org/docs/api-reference/next/router#router-object\u003c/a\u003e \u003c/blockquote\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hf6e0a9e212\"\u003e なぜundefindeが取得されていたのか\u003c/h2\u003e\u003cp\u003equeryの取得タイミングはuseEffectの発火よりも後なのだということは何となく察しましたが、どういう仕組みなのか気になります。\u003cbr\u003e\u003cbr\u003eNext.jsのドキュメントのダイナミックルーティングについての箇所に、以下のように書かれていました。\u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e Pages that are statically optimized by [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimizat\u003ca href=\"https://nextjs.org/docs/advanced-features/automatic-static-optimization\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eAutomatic Static Optimization\u003c/a\u003e \u003cbr\u003e After hydration, Next.js will trigger an update to your application to provide the route parameters in the \u003ccode\u003equery\u003c/code\u003e object.  \u003c/blockquote\u003e\u003cp\u003e\u003cbr\u003ePre-renderingの間はqueryは空のオブジェクトであり、hydrationのプロセスが終わった段階でqueryオブジェクトが提供されると書いてあります。\u003cbr\u003e\u003cbr\u003egetStaticPropsやgetSererSidePropsの処理が終わるまでは、queryは空なのですね。\u003cbr\u003e\u003cbr\u003ehydrationという単語は初めて知りましたが、Next.jsの公式の図を見るとイメージは湧きました。\u003cbr\u003e\u003cimg src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/a9c4b88b0bb24532bb598719b0bf4137/pre-rendering.png\" alt=\"\"\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h3937880ed1\"\u003e 参考記事\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://zenn.dev/kiyokiyoabc/articles/d3a8464367094a\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://zenn.dev/luvmini511/articles/1523113e0dec58\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://zenn.dev/luvmini511/articles/1523113e0dec58\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e","tags":[{"id":"nextjs","createdAt":"2022-01-07T13:18:14.144Z","updatedAt":"2022-02-12T02:31:58.832Z","publishedAt":"2022-01-07T13:18:14.144Z","revisedAt":"2022-01-07T13:18:14.144Z","tag":"Next.js"},{"id":"react","createdAt":"2022-01-07T13:17:54.189Z","updatedAt":"2022-02-12T02:31:51.382Z","publishedAt":"2022-01-07T13:17:54.189Z","revisedAt":"2022-01-07T13:17:54.189Z","tag":"React"}],"image":"react"},"highlightedBody":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003cp\u003e業務で、useEffect内でNext.jsのuseRouterを使ってクエリパラメータを取得しようとした際、意図する通りの挙動をしておらず戸惑ったので備忘録としてまとめておきます。\u003cbr\u003e\u003cbr\u003e通常\u003cstrong\u003epages/blogs/[id].tsx\u003c/strong\u003eのようなファイルにおいてAPIからデータを取得したい場合、\u003ccode\u003egetStaticPaths\u003c/code\u003e・\u003ccode\u003egetStaticProps\u003c/code\u003eを使うかと思いますが、今回は画面描画してからバックグラウンドでAPIリクエストを行ってデータ取得する必要があり、そこで見つけたのが\u003ccode\u003euseRouter\u003c/code\u003eの\u003ccode\u003erouter.query\u003c/code\u003eでした。 \u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h5752334b14\"\u003e useRouterとは\u003c/h2\u003e\u003cp\u003eそもそもuseRouterとは、Next.jsが用意しているhooksの一つで、routeに関する色んな情報を持つrouterオブジェクトへのアクセスを提供するものです。\u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e アプリの関数コンポーネント内の\u003ccode\u003erouter\u003c/code\u003eオブジェクトにアクセスする場合は、\u003ccode\u003euseRouter\u003c/code\u003eフックを使用できます。   \u003cbr\u003e\u003ccode\u003euseRouter\u003c/code\u003eはReactフックです。  \u003cbr\u003e\u0026nbsp;\u003ca href=\"https://nextjs.org/docs/api-reference/next/router#userouter\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://nextjs.org/docs/api-reference/next/router#userouter\u003c/a\u003e \u003c/blockquote\u003e\u003cp\u003e\u003cbr\u003erouterオブジェクトはいくつもの便利なメソッドやプロパティを持ちますが、その中のひとつにqueryがあります。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h6a9e501b40\"\u003e router.queryの使い方\u003c/h2\u003e\u003cp\u003e\u0026nbsp;\u003ccode\u003erouter.query\u003c/code\u003e とするだけで、オブジェクト形式で動的ルーティングの中身を取得できます。  \u003cbr\u003e\u003cbr\u003eちなみに以下の例のようにクエリパラメータが数字の場合も、string型で取得されます。\u003cbr\u003e \u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003eimport { useRouter } from \u003cspan class=\"hljs-string\"\u003e'next/router'\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e 関数コンポーネント内にて\n\u0026nbsp;const router = useRouter()\n\u0026nbsp;console.log(router.query)\n\u0026nbsp;console.log(router.query.id)\n\n\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e 出力結果(localhost:\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/blogs/\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e の場合)\n\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e { id: \u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e }\n\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h970271505b\"\u003e useEffect内でrouter.queryを使ってみる\u003c/h2\u003e\u003cp\u003e\u003ccode\u003epages/blogs/[id].tsx\u003c/code\u003eの\u003ccode\u003euseEffect\u003c/code\u003e内で\u003ccode\u003erouter.query\u003c/code\u003eを使ってみます。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003econst router = \u003cspan class=\"hljs-built_in\"\u003euseRouter\u003c/span\u003e()\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(()\u003c/span\u003e\u003c/span\u003e =\u0026gt; {\n\u0026nbsp;const routeId = router\u003cspan class=\"hljs-selector-class\"\u003e.query\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.id\u003c/span\u003e\n\u0026nbsp;console\u003cspan class=\"hljs-selector-class\"\u003e.log\u003c/span\u003e(routeId)\n}, \u003cspan class=\"hljs-selector-attr\"\u003e[]\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// undefined \u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003e出力されたのは \u003ccode\u003eundefinde\u003c/code\u003e でした。  \u003cbr\u003e\u003cbr\u003eどうやら、router.queryの取得は\u003ccode\u003euseEffect\u003c/code\u003eの発火タイミングより後のようです。\u003cbr\u003e\u003cbr\u003e【注】ただし、チームの中には上記のコードでもundefindeにならずqueryが取れている方もいましたし、私の環境でも時によってはqueryが取れることもありました。いずれにせよ不安定なものと思われるので、以下の対処をしておくのが無難なのかなと思います。\u003cbr\u003e（ご存じの方はぜひご指導・ご指摘ください…！）\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hc1efd68684\"\u003e useEffectの依存配列にrouterを指定する\u003c/h3\u003e\u003cp\u003e依存配列に\u003ccode\u003erouter\u003c/code\u003eを入れてみました。\u003cbr\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003econst router = \u003cspan class=\"hljs-built_in\"\u003euseRouter\u003c/span\u003e()\u0026nbsp;\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(()\u003c/span\u003e\u003c/span\u003e =\u0026gt; {\n\u0026nbsp;const routeId = router\u003cspan class=\"hljs-selector-class\"\u003e.query\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.id\u003c/span\u003e\n\u0026nbsp;console\u003cspan class=\"hljs-selector-class\"\u003e.log\u003c/span\u003e(routeId)\n}, \u003cspan class=\"hljs-selector-attr\"\u003e[router]\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 出力結果(localhost:3000/blogs/1 の場合)\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003eすると、一度\u003ccode\u003eundefinde\u003c/code\u003eと出た後に\u003ccode\u003equery\u003c/code\u003eが取れてコンソールに出力されました。\u003cbr\u003e\u003cbr\u003eこれで目的を果たせる場合もあるかもしれません。\u003cbr\u003e\u003cbr\u003eしかし今回私が実装したかった要件は、取得したルートパラメーターを使ったパスでAPIへリクエストを送るというものです。\u003cbr\u003eundefinedを取得してしまうと \u003ccode\u003e'/api/blogs/undefined'\u003c/code\u003eのパスにリクエストを送ってしまい、これは不都合でした。  \u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h2f530575d0\"\u003e isReadyを使ってrouter情報が準備されているか判別する\u003c/h3\u003e\u003cp\u003e辿り着いたコードは以下の通りです。\u003cbr\u003e \u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003econst router = \u003cspan class=\"hljs-built_in\"\u003euseRouter\u003c/span\u003e()\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-title\"\u003euseEffect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(()\u003c/span\u003e\u003c/span\u003e =\u0026gt; {\n\u0026nbsp;\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (router.isReady) {\n\u0026nbsp;\u0026nbsp;const routeId = router\u003cspan class=\"hljs-selector-class\"\u003e.query\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.id\u003c/span\u003e\n\u0026nbsp;\u0026nbsp;console\u003cspan class=\"hljs-selector-class\"\u003e.log\u003c/span\u003e(routeId)\n\u0026nbsp;}\n}, \u003cspan class=\"hljs-selector-attr\"\u003e[router]\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 出力結果(localhost:3000/blogs/1 の場合)\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cbr\u003erouterオブジェクトの持つ \u003ccode\u003eisReady\u003c/code\u003e というboolean値が最適でした。  \u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e \u003ccode\u003eisReady\u003c/code\u003e：\u003ccode\u003eboolean\u003c/code\u003e　ルーターフィールドがクライアント側で更新され、使用できる状態になっているかどうか。\u003ccode\u003euseEffect\u003c/code\u003eメソッド内でのみ使用する必要があり、サーバーで条件付きでレンダリングするためには使用しないでください。    \u003cbr\u003e\u0026nbsp;\u003ca href=\"https://nextjs.org/docs/api-reference/next/router#router-object\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://nextjs.org/docs/api-reference/next/router#router-object\u003c/a\u003e \u003c/blockquote\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hf6e0a9e212\"\u003e なぜundefindeが取得されていたのか\u003c/h2\u003e\u003cp\u003equeryの取得タイミングはuseEffectの発火よりも後なのだということは何となく察しましたが、どういう仕組みなのか気になります。\u003cbr\u003e\u003cbr\u003eNext.jsのドキュメントのダイナミックルーティングについての箇所に、以下のように書かれていました。\u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e Pages that are statically optimized by [Automatic Static Optimization](https://nextjs.org/docs/advanced-features/automatic-static-optimizat\u003ca href=\"https://nextjs.org/docs/advanced-features/automatic-static-optimization\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eAutomatic Static Optimization\u003c/a\u003e \u003cbr\u003e After hydration, Next.js will trigger an update to your application to provide the route parameters in the \u003ccode\u003equery\u003c/code\u003e object.  \u003c/blockquote\u003e\u003cp\u003e\u003cbr\u003ePre-renderingの間はqueryは空のオブジェクトであり、hydrationのプロセスが終わった段階でqueryオブジェクトが提供されると書いてあります。\u003cbr\u003e\u003cbr\u003egetStaticPropsやgetSererSidePropsの処理が終わるまでは、queryは空なのですね。\u003cbr\u003e\u003cbr\u003ehydrationという単語は初めて知りましたが、Next.jsの公式の図を見るとイメージは湧きました。\u003cbr\u003e\u003cimg src=\"https://images.microcms-assets.io/assets/bb9889e81cb24134954870eb1f2ba680/a9c4b88b0bb24532bb598719b0bf4137/pre-rendering.png\" alt=\"\"\u003e\u003cbr\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h3937880ed1\"\u003e 参考記事\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://zenn.dev/kiyokiyoabc/articles/d3a8464367094a\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://zenn.dev/kiyokiyoabc/articles/d3a8464367094a\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://zenn.dev/luvmini511/articles/1523113e0dec58\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://zenn.dev/luvmini511/articles/1523113e0dec58\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e"},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"nextjs-router-query"},"buildId":"EwuWiZmkeG3lYlO_XC9fM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
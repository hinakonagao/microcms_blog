<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/4bc12c1be68739c7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4bc12c1be68739c7.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8d58b9228ffac9a6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8d58b9228ffac9a6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-101cfeaa18eb0e64.js" defer=""></script><script src="/_next/static/chunks/pages/_app-5a602b05d6a5b45c.js" defer=""></script><script src="/_next/static/chunks/451-8446afed8f2a81ca.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bid%5D-7b5e07e6b1c54b77.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_buildManifest.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_ssgManifest.js" defer=""></script><script src="/_next/static/EwuWiZmkeG3lYlO_XC9fM/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><style data-emotion="css a6by8m">.css-a6by8m{box-sizing:border-box;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;margin:auto;}</style><div class="MuiGrid-root MuiGrid-container css-a6by8m"><style data-emotion="css d0aeej">.css-d0aeej{background-color:#FFF;color:#222;margin:30px auto;padding:36px;}.css-d0aeej h1,.css-d0aeej h2,.css-d0aeej h3{font-weight:550;}</style><style data-emotion="css vx8k43">.css-vx8k43{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:91.666667%;-ms-flex-preferred-size:91.666667%;flex-basis:91.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:91.666667%;background-color:#FFF;color:#222;margin:30px auto;padding:36px;}@media (min-width:600px){.css-vx8k43{-webkit-flex-basis:91.666667%;-ms-flex-preferred-size:91.666667%;flex-basis:91.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:91.666667%;}}@media (min-width:900px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1200px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}@media (min-width:1536px){.css-vx8k43{-webkit-flex-basis:75%;-ms-flex-preferred-size:75%;flex-basis:75%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:75%;}}.css-vx8k43 h1,.css-vx8k43 h2,.css-vx8k43 h3{font-weight:550;}</style><div class="MuiGrid-root MuiGrid-item MuiGrid-grid-xs-11 MuiGrid-grid-md-9 css-vx8k43"><style data-emotion="css tph460">.css-tph460{padding:15px 0px;border-bottom:1px solid #4682B4;}</style><div class="css-tph460"><style data-emotion="css 1x4m838">.css-1x4m838{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:1rem;line-height:1.5;letter-spacing:0.00938em;font-size:26px;font-weight:540;padding-bottom:16px;}</style><p class="MuiTypography-root MuiTypography-body1 css-1x4m838">同一オリジンポリシーとCORS</p><style data-emotion="css q5vujz">.css-q5vujz{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;display:inline-block;padding-right:32px;}</style><p class="MuiTypography-root MuiTypography-body2 css-q5vujz"><style data-emotion="css 1eipbkb">.css-1eipbkb{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;font-size:15px;margin-right:4px;vertical-align:middle;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1eipbkb" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="AccessTimeIcon"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path><path d="M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></svg>投稿日 <!-- -->2021/12/29</p><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1eipbkb" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="LocalOfferIcon"><path d="m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z"></path></svg><style data-emotion="css 1lc4u9f">.css-1lc4u9f{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;display:inline-block;padding-right:8px;}</style><p class="MuiTypography-root MuiTypography-body2 css-1lc4u9f">#<!-- -->Web</p></div><style data-emotion="css il3arz">.css-il3arz{margin-top:40px;}.css-il3arz a{color:#639bb7;}.css-il3arz a:hover{color:#0b7eb8;-webkit-text-decoration:underline;text-decoration:underline;}</style><div class="css-il3arz"><html><head></head><body><h2 id="hd92040d0df">きっかけ</h2><p>業務で、Next.jsのフロント側からLaravelのAPIを叩いた時に<strong>CORSエラー</strong>というのが出ました。<br><br>エラー解消法はすぐに見つかったものの、セキュリティやその対策の仕組みについてはきちんと理解して実装したいと思い、色々調べたのでまとめておきます。<br></p><h1 id="he84d5455fa">同一オリジンポリシー</h1><p>CORSについて理解するためには、前提として「同一オリジンポリシー」について知る必要があります。<br></p><h3 id="h19b65993c4">オリジンとは</h3><p>ドメイン＋プロトコル＋ポート番号 を合わせたもの。<br><br>【例】<br>・ドメイン (domain)：yahoo.co.jp<br>・オリジン (origin)：&nbsp;<a style="color:#4aac00" href="https://yahoo.co.jp/" target="_blank" rel="noopener noreferrer">https://yahoo.co.jp:443</a><br></p><h3 id="ha2aa5c29c6">「同一オリジンである」とは</h3><p>ドメイン・プロトコル・ポート番号の全てが一致している場合のこと。<br></p><h3 id="h583e348ae7">同一オリジンポリシー（Same-Origin Policy）とは</h3><p>MDNには以下のように書いてあります。<br></p><blockquote><strong>同一オリジンポリシー</strong>は重要なセキュリティの仕組みであり、ある<a style="color:#4aac00" href="https://developer.mozilla.org/ja/docs/Glossary/Origin" target="_blank" rel="noopener noreferrer">オリジン</a>によって読み込まれた文書やスクリプトが、他のオリジンにあるリソースにアクセスできる方法を制限するものです。<br><a style="color:#4aac00" href="https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer">同一オリジンポリシー - ウェブセキュリティ | MDN</a><br><br></blockquote><p>要するに、別のオリジンへのアクセスに制限をかけることで、XSSやCSRFといった攻撃を防ぐことを目的とするセキュリティの仕組みです。<br><br>XSSとCSRFについてそれぞれの詳しい攻撃手法はここでは取り上げませんが、対策を講じる上での要点を挙げておきます。<br></p><h3 id="hafaeffc4cb">XSS (Cross Site Scripting)</h3><p>ユーザーが 意図しない不正なスクリプトが&nbsp;Webサーバーに送られ、Webサーバーからのレスポンスを受け取ってしまった結果<strong>クライアント側 (Web ブラウザ)</strong>&nbsp;で実行される攻撃。<br><br>ブラウザ上で出来ることは何でも悪用対象になるので、CSRFより攻撃範囲が広い。<br></p><h3 id="hc9f9aae59b"><strong>CSRF (Cross-Site Request Forgeries)</strong></h3><p>ユーザーが意図しない不正なスクリプトがWebサーバーに送られ、&nbsp;<strong>Web アプリケーション (Web サーバー)</strong>&nbsp;上で実行される攻撃。通称「しーさーふ」。<br><br>悪用内容はサーバー側で用意された処理に限定されるが、&nbsp;<strong>サーバーにリクエストが到達するだけで攻撃が成立する</strong>ので、XSS対策はできていてもCSRF対策は出来ていないということもあり得る。<br><br><br>JavaScript の組み込み API でありAjax 通信を実現する&nbsp;<code>XMLHttpRequest (XHR)</code>&nbsp;や&nbsp;<code>Fetch API</code>&nbsp;などは、これらの脆弱性を回避するため<strong>同一オリジンポリシー</strong>（別のオリジンへのアクセスに制限をかける仕組み）に従っています。<br>XSSとCSRFについての詳細は、以下の記事が分かりやすく勉強になりました。<br><a href="https://qiita.com/att55/items/a50ca43adde206017525" target="_blank" rel="noopener noreferrer">XSS と CSRF って結局何が違うのか？ - Qiita</a><br></p><h1 id="h027a034520">CORS</h1><p>同一オリジンポリシーについて抑えたところで、CORSについて見ていきます。<br></p><h2 id="hac1783c7e1">CORSとは</h2><p>読み方：コルス or シーオーアールエス<br><strong>C</strong>ross-<strong>O</strong>rigin&nbsp;<strong>R</strong>esource&nbsp;<strong>S</strong>haring の略で、日本語訳すると「<strong>オリジン間リソース共有</strong>」。<br><br>CORSは、あるオリジンで動いているWebアプリケーションから別のオリジンのサーバーへのアクセスを許可する仕組みです。<br><br>同一オリジンポリシーにより別のオリジンにはアクセスが出来ないという規制があるが、Web開発・制作では異なるオリジンにアクセスしたいケースもある…　<br>そこで、同一オリジンポリシーの制約を回避・緩和してくれるのがCORSです。<br><br>歴史をたどるとCORSが必要になった経緯がさらによく分かります。<br></p><h3 id="h3aecdd16f5">同一オリジンポリシーはあるが、CORSはない場合…（過去のブラウザ）</h3><p>出来たこと</p><ul><li>同一オリジンポリシーによりJavaScriptの安全性は確保される。</li></ul><p><br>生まれた課題</p><ul><li>Ajaxの普及・発展により、異なるオリジン（主に異なるホスト）のAPIを呼び出したいという動機が生まれた。</li><li>JSONPなど同一オリジンポリシーの範囲内で異なるオリジンのAPIを呼び出す方法が考案されたが、裏技のようなものであって安全性には課題が残っていた。</li></ul><p><br></p><h3 id="h510870a262">そこで生まれたCORS</h3><p>上記のような課題を解決するため生まれたCORSは、以下の機能を提供します。<br></p><ul><li>クロスオリジンのアクセスを許可</li><li>オリジン単位でのアクセス制御が可能（例：オリジンA・オリジンBとの通信のみ許可する）</li><li>HTTPヘッダを用いてアクセス制御を行う</li></ul><p><br></p><h2 id="h922d87a02b">CORSはどうやってクロスオリジン通信を許可するのか</h2><p>以下のように事前に通信を行う双方で設定を行っておくことで、クロスオリジンの通信が可能になります。<br></p><ul><li>クライアントサイド</li></ul><p>HTTPリクエストヘッダに<code>Originヘッダ</code>を付ける。<br><br>・XHRの場合：自動でOriginヘッダが付くので何もしなくて良い<br>・FetchAPIの場合：mode: cors を付与する<br></p><ul><li>サーバーサイド</li></ul><p>HTTPレスポンスヘッダに以下を付ける。<br>※レスポンスヘッダを付ける方法は環境によって様々です。<br>Laravelの場合は、Laravel7.0以降は<strong><code>config/cors.php</code></strong>&nbsp;を使ってCORSの設定ができます。<br><br><strong>＊必須＊</strong><br>・<code>Access-Control-Allow-Origin: アクセス元のオリジン</code><br><strong>＊必要な場合のみ＊</strong><br>・Access-Control-Allow-Credentials: true（Cookieを送信する場合は必要）<br>・Access-Control-Allow-Headers<br>・Access-Control-Request-Method<br>・Access-Control-Max-Age<br></p><h2 id="h6562eef876">CORSによるアクセス制御の流れ</h2><p>実際にCORSがアクセス制御を行う流れを、ブラウザの検証ツールのネットワークを観察して確認します。<br><br>【前提】<br>・フロント側（Next.js）をlocalhost:3001、API（Laravel）をlocalhost:8080で開発中。<br>・localhost:3001のフロント側から、localhost:8080/logoutというURLにアクセスしてAPIをたたき、クロスオリジンの通信を発生させる。<br>・リクエストはXHRにより行うので、リクエストヘッダには自動的にOriginヘッダが付く。<br>・localhost:3001からのリクエストがあった場合は、レスポンスヘッダにAccess-Control-Allow-Originを載せるように、事前にAPI側で設定している。<br><br>【実際の流れ】<br>1.　ブラウザでlocalhost:3001にアクセスする。<br>2.　localhots:3001からlocalhost:8080/logoutへHTTPリクエストを送る。<br>　&lt;ポイント&gt; リクエストヘッダのOriginという項目に、リクエスト元のドメイン情報が載せられる。</p><pre><code class="hljs">Origin: http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3001</span></code></pre><p>3.　レスポンスが返ってきたら、localhost:3001はlocalhost:8080からのレスポンスヘッダを見て、レスポンスを受け取るかどうか判断する。<br>　&lt;ポイント&gt;　レスポンスヘッダに&nbsp;<code>Access-Control-Allow-Origin</code>&nbsp;という項目があり、自分のドメイン情報（localhost:3001）が載せられていればレスポンスを受け取る。</p><pre><code class="hljs"><span class="hljs-regexp">//</span> レスポンスヘッダに以下の記載があれば、レスポンスを受け取る
Access-Control-Allow-Origin：http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3001</span></code></pre><h3 id="h5d7a611c3a"><br>CORSエラーを起こしてみる</h3><p>上記の例では、事前にAPI側（Laravelのconfig/cors.php）でlocalhost:3001からのリクエストに対してAccess-Control-Allow-Originを返す設定をしていた為、クロスオリジンの通信が成立していました。<br><br>試しにAPI側で設定を行っている箇所を削除してみると、レスポンスヘッダに&nbsp;<code>Access-Control-Allow-Origin：http://localhost:3001</code>&nbsp;が無いので、CORSエラーが起こります。<br><br>ここでのエラーは、リクエスト自体は送っているけれど、レスポンスが返って来た時にそれを受け取らず<strong>レスポンスエラー</strong>ということになっています。<br></p><h2 id="h119f62b8ee">プリフライトリクエスト</h2><h3 id="hf8c9fef3ec">無条件でリクエストが飛んでも大丈夫なのか？</h3><p>CORSの設定をしていないとエラーが発生して通信は成立しませんでしたが、そのエラーはあくまで<strong>レスポンスを受け取らない</strong>というものでした。<br><br>しかし、そもそもリクエストが飛んで良いのか？という懸念が残ります。<br><br>代表的なリスクがCSRFです。<br>&nbsp;<strong>CSRFではレスポンスを受け取る必要は無く、リクエストが送信できれば攻撃できます。</strong><br><br>このようなリスク対策として、プリフライトリクエストが生まれました。<br></p><h3 id="hbcb48602bc">プリフライトリクエストの考え方</h3><ul><li>元々CORSが無いときにできていたクロスオリジンのリクエストに対して、大幅なリスク増にならない条件であれば、XHR等で無条件にクロスオリジンのリクエストを送信できるようにした。</li><li>「大幅なリスク増にならない」条件を単純リクエストとして定義した。</li><li>単純リクエストの要件を超える場合は、実際のリクエストを送る前にプリフライトリクエストを送り、実際のリクエストを送信して問題無いか事前に確認する。</li><li>プリフライトリクエストを挟むことで、プリフライトリクエストを送信した結果Access-Control-Allow-OriginのHTTPヘッダがついたレスポンスが返されなければ、実際のリクエストは送信しない、というように悪意あるリクエストを防ぐ。</li></ul><p><br></p><h3 id="he303012d4a">単純リクエスト（Simple Request）の要件</h3><p>以下の要件を全て満たす場合のみ、単純リクエストとなります。<br></p><ul><li>メソッドは「GET, POST, HEAD」のいずれか</li><li>設定できるリクエストヘッダは以下のいずれか<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type（条件付き）</li></ul></li><li>Content-Typeについては以下のいずれかを満たすこと<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data（ファイルアップロードに使う）</li></ul></li><li>text/plain（滅多に使わない）</li></ul><p><br></p><h2 id="ha214098e44">まとめ</h2><ul><li>XSSやCSRFなどの対策として、他のオリジンへのアクセスを制限する「同一オリジンポリシー」という仕組みがある。</li><li>他のオリジンへアクセスしたい、でも安全性も保ちたい、、を叶えるためCORSが生まれた。</li><li>通常のCORSはレスポンスが届いたときにレスポンスを受け取るかどうかの制御を行うので、リクエスト自体は無条件に飛んでしまう。そこで不正なリクエストが送られてしまうリスク対策として、プリフライトリクエストが生まれた。</li></ul><p><br></p><h2 id="h3bcda3e6b0">最後に</h2><p>エラーが解消されて動けばOKではなく、きちんと仕組みを調べてみてかなり理解が深まったかなと思います。（もし誤りがあれば是非ご指摘いただけると幸いです…！！）<br><br>これまでHTTPリクエストヘッダやレスポンスヘッダをまじまじと見たことも無かったので、Ajax通信を行っている箇所で検証ツールを確認してみると面白かったです。<br>確かにOriginやAccess-Control-Allow-Originがあったり、プリフライトリクエストが送られてレスポンスが返って来てから本番のリクエストが送られているのが確認できて、勉強になりました。<br>セキュリティ対策についてしっかり理解できていなくても動くアプリを作ることが出来てしまうというのは怖いことだなと思うので、これからもセキュリティの勉強はしていきたいと思います。<br></p><h2 id="he45680f0bc">参考記事</h2><p><br><a href="https://developer.mozilla.org/ja/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">オリジン間リソース共有 (CORS) - HTTP | MDN</a><br><br><a href="https://labor.ewigleere.net/2020/10/13/cors_preflight_request_verification/" target="_blank" rel="noopener noreferrer">CORS の挙動の観察と preflight request の検証</a><br><br><a href="https://it-web-life.com/javascript_cors_preflight/" target="_blank" rel="noopener noreferrer">【CORS】JavaScriptにおけるCORSやPreflightを理解する</a><br><br><a href="https://programmer-life.work/html_css/html-request" target="_blank" rel="noopener noreferrer">HTTPリクエストとは？HTTPリクエストを目で確認したい | Programmer LifeHTTPリクエストとは？HTTPリクエストを目...</a><br><br><a href="https://qiita.com/att55/items/2154a8aad8bf1409db2b" target="_blank" rel="noopener noreferrer">なんとなく CORS がわかる...はもう終わりにする。 - Qiita</a><br></p></body></html></div></div></div><style data-emotion="css 2sbw87">.css-2sbw87{background-color:#494949;margin:0 auto;padding-top:30px;padding-bottom:30px;color:#f2f2f2;letter-spacing:0.08rem;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-around;-ms-flex-pack:space-around;-webkit-justify-content:space-around;justify-content:space-around;-webkit-box-flex-wrap:wrap;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style><div class="css-2sbw87"><style data-emotion="css kta5xp">.css-kta5xp{box-sizing:border-box;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-basis:83.333333%;-ms-flex-preferred-size:83.333333%;flex-basis:83.333333%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:83.333333%;}@media (min-width:600px){.css-kta5xp{-webkit-flex-basis:83.333333%;-ms-flex-preferred-size:83.333333%;flex-basis:83.333333%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:83.333333%;}}@media (min-width:900px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}@media (min-width:1200px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}@media (min-width:1536px){.css-kta5xp{-webkit-flex-basis:66.666667%;-ms-flex-preferred-size:66.666667%;flex-basis:66.666667%;-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;max-width:66.666667%;}}</style><div class="MuiGrid-root MuiGrid-grid-xs-10 MuiGrid-grid-md-8 css-kta5xp"><style data-emotion="css 1lx0lai">.css-1lx0lai{box-sizing:border-box;margin:0;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;text-align:center;}</style><div class="MuiGrid-root MuiGrid-item css-1lx0lai"><a href="https://twitter.com/napi_nami"><style data-emotion="css 1ea777n">.css-1ea777n{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;margin:8px;}</style><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1ea777n" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="TwitterIcon"><path d="M22.46 6c-.77.35-1.6.58-2.46.69.88-.53 1.56-1.37 1.88-2.38-.83.5-1.75.85-2.72 1.05C18.37 4.5 17.26 4 16 4c-2.35 0-4.27 1.92-4.27 4.29 0 .34.04.67.11.98C8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15 0 1.49.75 2.81 1.91 3.56-.71 0-1.37-.2-1.95-.5v.03c0 2.08 1.48 3.82 3.44 4.21a4.22 4.22 0 0 1-1.93.07 4.28 4.28 0 0 0 4 2.98 8.521 8.521 0 0 1-5.33 1.84c-.34 0-.68-.02-1.02-.06C3.44 20.29 5.7 21 8.12 21 16 21 20.33 14.46 20.33 8.79c0-.19 0-.37-.01-.56.84-.6 1.56-1.36 2.14-2.23z"></path></svg></a><a href="https://github.com/hinakonagao"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-1ea777n" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="GitHubIcon"><path d="M12 1.27a11 11 0 00-3.48 21.46c.55.09.73-.28.73-.55v-1.84c-3.03.64-3.67-1.46-3.67-1.46-.55-1.29-1.28-1.65-1.28-1.65-.92-.65.1-.65.1-.65 1.1 0 1.73 1.1 1.73 1.1.92 1.65 2.57 1.2 3.21.92a2 2 0 01.64-1.47c-2.47-.27-5.04-1.19-5.04-5.5 0-1.1.46-2.1 1.2-2.84a3.76 3.76 0 010-2.93s.91-.28 3.11 1.1c1.8-.49 3.7-.49 5.5 0 2.1-1.38 3.02-1.1 3.02-1.1a3.76 3.76 0 010 2.93c.83.74 1.2 1.74 1.2 2.94 0 4.21-2.57 5.13-5.04 5.4.45.37.82.92.82 2.02v3.03c0 .27.1.64.73.55A11 11 0 0012 1.27"></path></svg></a></div><style data-emotion="css 198jr53">.css-198jr53{margin:0;font-family:"Roboto","Helvetica","Arial",sans-serif;font-weight:400;font-size:0.875rem;line-height:1.43;letter-spacing:0.01071em;text-align:center;font-weight:200;}</style><p class="MuiTypography-root MuiTypography-body2 css-198jr53">© 2022 hinako blog</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"id":"cors","createdAt":"2022-02-12T11:27:21.400Z","updatedAt":"2022-02-12T11:40:40.611Z","publishedAt":"2021-12-29T11:27:21.000Z","revisedAt":"2022-02-12T11:40:40.611Z","title":"同一オリジンポリシーとCORS","body":"\u003ch2 id=\"hd92040d0df\"\u003eきっかけ\u003c/h2\u003e\u003cp\u003e業務で、Next.jsのフロント側からLaravelのAPIを叩いた時に\u003cstrong\u003eCORSエラー\u003c/strong\u003eというのが出ました。\u003cbr\u003e\u003cbr\u003eエラー解消法はすぐに見つかったものの、セキュリティやその対策の仕組みについてはきちんと理解して実装したいと思い、色々調べたのでまとめておきます。\u003cbr\u003e\u003c/p\u003e\u003ch1 id=\"he84d5455fa\"\u003e同一オリジンポリシー\u003c/h1\u003e\u003cp\u003eCORSについて理解するためには、前提として「同一オリジンポリシー」について知る必要があります。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h19b65993c4\"\u003eオリジンとは\u003c/h3\u003e\u003cp\u003eドメイン＋プロトコル＋ポート番号 を合わせたもの。\u003cbr\u003e\u003cbr\u003e【例】\u003cbr\u003e・ドメイン (domain)：yahoo.co.jp\u003cbr\u003e・オリジン (origin)：\u0026nbsp;\u003ca style=\"color:#4aac00\" href=\"https://yahoo.co.jp/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://yahoo.co.jp:443\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"ha2aa5c29c6\"\u003e「同一オリジンである」とは\u003c/h3\u003e\u003cp\u003eドメイン・プロトコル・ポート番号の全てが一致している場合のこと。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h583e348ae7\"\u003e同一オリジンポリシー（Same-Origin Policy）とは\u003c/h3\u003e\u003cp\u003eMDNには以下のように書いてあります。\u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cstrong\u003e同一オリジンポリシー\u003c/strong\u003eは重要なセキュリティの仕組みであり、ある\u003ca style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Glossary/Origin\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eオリジン\u003c/a\u003eによって読み込まれた文書やスクリプトが、他のオリジンにあるリソースにアクセスできる方法を制限するものです。\u003cbr\u003e\u003ca style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e同一オリジンポリシー - ウェブセキュリティ | MDN\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003c/blockquote\u003e\u003cp\u003e要するに、別のオリジンへのアクセスに制限をかけることで、XSSやCSRFといった攻撃を防ぐことを目的とするセキュリティの仕組みです。\u003cbr\u003e\u003cbr\u003eXSSとCSRFについてそれぞれの詳しい攻撃手法はここでは取り上げませんが、対策を講じる上での要点を挙げておきます。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hafaeffc4cb\"\u003eXSS (Cross Site Scripting)\u003c/h3\u003e\u003cp\u003eユーザーが 意図しない不正なスクリプトが\u0026nbsp;Webサーバーに送られ、Webサーバーからのレスポンスを受け取ってしまった結果\u003cstrong\u003eクライアント側 (Web ブラウザ)\u003c/strong\u003e\u0026nbsp;で実行される攻撃。\u003cbr\u003e\u003cbr\u003eブラウザ上で出来ることは何でも悪用対象になるので、CSRFより攻撃範囲が広い。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hc9f9aae59b\"\u003e\u003cstrong\u003eCSRF (Cross-Site Request Forgeries)\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eユーザーが意図しない不正なスクリプトがWebサーバーに送られ、\u0026nbsp;\u003cstrong\u003eWeb アプリケーション (Web サーバー)\u003c/strong\u003e\u0026nbsp;上で実行される攻撃。通称「しーさーふ」。\u003cbr\u003e\u003cbr\u003e悪用内容はサーバー側で用意された処理に限定されるが、\u0026nbsp;\u003cstrong\u003eサーバーにリクエストが到達するだけで攻撃が成立する\u003c/strong\u003eので、XSS対策はできていてもCSRF対策は出来ていないということもあり得る。\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eJavaScript の組み込み API でありAjax 通信を実現する\u0026nbsp;\u003ccode\u003eXMLHttpRequest (XHR)\u003c/code\u003e\u0026nbsp;や\u0026nbsp;\u003ccode\u003eFetch API\u003c/code\u003e\u0026nbsp;などは、これらの脆弱性を回避するため\u003cstrong\u003e同一オリジンポリシー\u003c/strong\u003e（別のオリジンへのアクセスに制限をかける仕組み）に従っています。\u003cbr\u003eXSSとCSRFについての詳細は、以下の記事が分かりやすく勉強になりました。\u003cbr\u003e\u003ca href=\"https://qiita.com/att55/items/a50ca43adde206017525\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eXSS と CSRF って結局何が違うのか？ - Qiita\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e\u003ch1 id=\"h027a034520\"\u003eCORS\u003c/h1\u003e\u003cp\u003e同一オリジンポリシーについて抑えたところで、CORSについて見ていきます。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hac1783c7e1\"\u003eCORSとは\u003c/h2\u003e\u003cp\u003e読み方：コルス or シーオーアールエス\u003cbr\u003e\u003cstrong\u003eC\u003c/strong\u003eross-\u003cstrong\u003eO\u003c/strong\u003erigin\u0026nbsp;\u003cstrong\u003eR\u003c/strong\u003eesource\u0026nbsp;\u003cstrong\u003eS\u003c/strong\u003eharing の略で、日本語訳すると「\u003cstrong\u003eオリジン間リソース共有\u003c/strong\u003e」。\u003cbr\u003e\u003cbr\u003eCORSは、あるオリジンで動いているWebアプリケーションから別のオリジンのサーバーへのアクセスを許可する仕組みです。\u003cbr\u003e\u003cbr\u003e同一オリジンポリシーにより別のオリジンにはアクセスが出来ないという規制があるが、Web開発・制作では異なるオリジンにアクセスしたいケースもある…　\u003cbr\u003eそこで、同一オリジンポリシーの制約を回避・緩和してくれるのがCORSです。\u003cbr\u003e\u003cbr\u003e歴史をたどるとCORSが必要になった経緯がさらによく分かります。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h3aecdd16f5\"\u003e同一オリジンポリシーはあるが、CORSはない場合…（過去のブラウザ）\u003c/h3\u003e\u003cp\u003e出来たこと\u003c/p\u003e\u003cul\u003e\u003cli\u003e同一オリジンポリシーによりJavaScriptの安全性は確保される。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e生まれた課題\u003c/p\u003e\u003cul\u003e\u003cli\u003eAjaxの普及・発展により、異なるオリジン（主に異なるホスト）のAPIを呼び出したいという動機が生まれた。\u003c/li\u003e\u003cli\u003eJSONPなど同一オリジンポリシーの範囲内で異なるオリジンのAPIを呼び出す方法が考案されたが、裏技のようなものであって安全性には課題が残っていた。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h510870a262\"\u003eそこで生まれたCORS\u003c/h3\u003e\u003cp\u003e上記のような課題を解決するため生まれたCORSは、以下の機能を提供します。\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eクロスオリジンのアクセスを許可\u003c/li\u003e\u003cli\u003eオリジン単位でのアクセス制御が可能（例：オリジンA・オリジンBとの通信のみ許可する）\u003c/li\u003e\u003cli\u003eHTTPヘッダを用いてアクセス制御を行う\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h922d87a02b\"\u003eCORSはどうやってクロスオリジン通信を許可するのか\u003c/h2\u003e\u003cp\u003e以下のように事前に通信を行う双方で設定を行っておくことで、クロスオリジンの通信が可能になります。\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eクライアントサイド\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHTTPリクエストヘッダに\u003ccode\u003eOriginヘッダ\u003c/code\u003eを付ける。\u003cbr\u003e\u003cbr\u003e・XHRの場合：自動でOriginヘッダが付くので何もしなくて良い\u003cbr\u003e・FetchAPIの場合：mode: cors を付与する\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eサーバーサイド\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHTTPレスポンスヘッダに以下を付ける。\u003cbr\u003e※レスポンスヘッダを付ける方法は環境によって様々です。\u003cbr\u003eLaravelの場合は、Laravel7.0以降は\u003cstrong\u003e\u003ccode\u003econfig/cors.php\u003c/code\u003e\u003c/strong\u003e\u0026nbsp;を使ってCORSの設定ができます。\u003cbr\u003e\u003cbr\u003e\u003cstrong\u003e＊必須＊\u003c/strong\u003e\u003cbr\u003e・\u003ccode\u003eAccess-Control-Allow-Origin: アクセス元のオリジン\u003c/code\u003e\u003cbr\u003e\u003cstrong\u003e＊必要な場合のみ＊\u003c/strong\u003e\u003cbr\u003e・Access-Control-Allow-Credentials: true（Cookieを送信する場合は必要）\u003cbr\u003e・Access-Control-Allow-Headers\u003cbr\u003e・Access-Control-Request-Method\u003cbr\u003e・Access-Control-Max-Age\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h6562eef876\"\u003eCORSによるアクセス制御の流れ\u003c/h2\u003e\u003cp\u003e実際にCORSがアクセス制御を行う流れを、ブラウザの検証ツールのネットワークを観察して確認します。\u003cbr\u003e\u003cbr\u003e【前提】\u003cbr\u003e・フロント側（Next.js）をlocalhost:3001、API（Laravel）をlocalhost:8080で開発中。\u003cbr\u003e・localhost:3001のフロント側から、localhost:8080/logoutというURLにアクセスしてAPIをたたき、クロスオリジンの通信を発生させる。\u003cbr\u003e・リクエストはXHRにより行うので、リクエストヘッダには自動的にOriginヘッダが付く。\u003cbr\u003e・localhost:3001からのリクエストがあった場合は、レスポンスヘッダにAccess-Control-Allow-Originを載せるように、事前にAPI側で設定している。\u003cbr\u003e\u003cbr\u003e【実際の流れ】\u003cbr\u003e1.　ブラウザでlocalhost:3001にアクセスする。\u003cbr\u003e2.　localhots:3001からlocalhost:8080/logoutへHTTPリクエストを送る。\u003cbr\u003e　\u0026lt;ポイント\u0026gt; リクエストヘッダのOriginという項目に、リクエスト元のドメイン情報が載せられる。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eOrigin: http://localhost:3001\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e3.　レスポンスが返ってきたら、localhost:3001はlocalhost:8080からのレスポンスヘッダを見て、レスポンスを受け取るかどうか判断する。\u003cbr\u003e　\u0026lt;ポイント\u0026gt;　レスポンスヘッダに\u0026nbsp;\u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e\u0026nbsp;という項目があり、自分のドメイン情報（localhost:3001）が載せられていればレスポンスを受け取る。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// レスポンスヘッダに以下の記載があれば、レスポンスを受け取る\nAccess-Control-Allow-Origin：http://localhost:3001\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"h5d7a611c3a\"\u003e\u003cbr\u003eCORSエラーを起こしてみる\u003c/h3\u003e\u003cp\u003e上記の例では、事前にAPI側（Laravelのconfig/cors.php）でlocalhost:3001からのリクエストに対してAccess-Control-Allow-Originを返す設定をしていた為、クロスオリジンの通信が成立していました。\u003cbr\u003e\u003cbr\u003e試しにAPI側で設定を行っている箇所を削除してみると、レスポンスヘッダに\u0026nbsp;\u003ccode\u003eAccess-Control-Allow-Origin：http://localhost:3001\u003c/code\u003e\u0026nbsp;が無いので、CORSエラーが起こります。\u003cbr\u003e\u003cbr\u003eここでのエラーは、リクエスト自体は送っているけれど、レスポンスが返って来た時にそれを受け取らず\u003cstrong\u003eレスポンスエラー\u003c/strong\u003eということになっています。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h119f62b8ee\"\u003eプリフライトリクエスト\u003c/h2\u003e\u003ch3 id=\"hf8c9fef3ec\"\u003e無条件でリクエストが飛んでも大丈夫なのか？\u003c/h3\u003e\u003cp\u003eCORSの設定をしていないとエラーが発生して通信は成立しませんでしたが、そのエラーはあくまで\u003cstrong\u003eレスポンスを受け取らない\u003c/strong\u003eというものでした。\u003cbr\u003e\u003cbr\u003eしかし、そもそもリクエストが飛んで良いのか？という懸念が残ります。\u003cbr\u003e\u003cbr\u003e代表的なリスクがCSRFです。\u003cbr\u003e\u0026nbsp;\u003cstrong\u003eCSRFではレスポンスを受け取る必要は無く、リクエストが送信できれば攻撃できます。\u003c/strong\u003e\u003cbr\u003e\u003cbr\u003eこのようなリスク対策として、プリフライトリクエストが生まれました。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hbcb48602bc\"\u003eプリフライトリクエストの考え方\u003c/h3\u003e\u003cul\u003e\u003cli\u003e元々CORSが無いときにできていたクロスオリジンのリクエストに対して、大幅なリスク増にならない条件であれば、XHR等で無条件にクロスオリジンのリクエストを送信できるようにした。\u003c/li\u003e\u003cli\u003e「大幅なリスク増にならない」条件を単純リクエストとして定義した。\u003c/li\u003e\u003cli\u003e単純リクエストの要件を超える場合は、実際のリクエストを送る前にプリフライトリクエストを送り、実際のリクエストを送信して問題無いか事前に確認する。\u003c/li\u003e\u003cli\u003eプリフライトリクエストを挟むことで、プリフライトリクエストを送信した結果Access-Control-Allow-OriginのHTTPヘッダがついたレスポンスが返されなければ、実際のリクエストは送信しない、というように悪意あるリクエストを防ぐ。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"he303012d4a\"\u003e単純リクエスト（Simple Request）の要件\u003c/h3\u003e\u003cp\u003e以下の要件を全て満たす場合のみ、単純リクエストとなります。\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eメソッドは「GET, POST, HEAD」のいずれか\u003c/li\u003e\u003cli\u003e設定できるリクエストヘッダは以下のいずれか\u003cul\u003e\u003cli\u003eAccept\u003c/li\u003e\u003cli\u003eAccept-Language\u003c/li\u003e\u003cli\u003eContent-Language\u003c/li\u003e\u003cli\u003eContent-Type（条件付き）\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eContent-Typeについては以下のいずれかを満たすこと\u003cul\u003e\u003cli\u003eapplication/x-www-form-urlencoded\u003c/li\u003e\u003cli\u003emultipart/form-data（ファイルアップロードに使う）\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003etext/plain（滅多に使わない）\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"ha214098e44\"\u003eまとめ\u003c/h2\u003e\u003cul\u003e\u003cli\u003eXSSやCSRFなどの対策として、他のオリジンへのアクセスを制限する「同一オリジンポリシー」という仕組みがある。\u003c/li\u003e\u003cli\u003e他のオリジンへアクセスしたい、でも安全性も保ちたい、、を叶えるためCORSが生まれた。\u003c/li\u003e\u003cli\u003e通常のCORSはレスポンスが届いたときにレスポンスを受け取るかどうかの制御を行うので、リクエスト自体は無条件に飛んでしまう。そこで不正なリクエストが送られてしまうリスク対策として、プリフライトリクエストが生まれた。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h3bcda3e6b0\"\u003e最後に\u003c/h2\u003e\u003cp\u003eエラーが解消されて動けばOKではなく、きちんと仕組みを調べてみてかなり理解が深まったかなと思います。（もし誤りがあれば是非ご指摘いただけると幸いです…！！）\u003cbr\u003e\u003cbr\u003eこれまでHTTPリクエストヘッダやレスポンスヘッダをまじまじと見たことも無かったので、Ajax通信を行っている箇所で検証ツールを確認してみると面白かったです。\u003cbr\u003e確かにOriginやAccess-Control-Allow-Originがあったり、プリフライトリクエストが送られてレスポンスが返って来てから本番のリクエストが送られているのが確認できて、勉強になりました。\u003cbr\u003eセキュリティ対策についてしっかり理解できていなくても動くアプリを作ることが出来てしまうというのは怖いことだなと思うので、これからもセキュリティの勉強はしていきたいと思います。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"he45680f0bc\"\u003e参考記事\u003c/h2\u003e\u003cp\u003e\u003cbr\u003e\u003ca href=\"https://developer.mozilla.org/ja/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eオリジン間リソース共有 (CORS) - HTTP | MDN\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://labor.ewigleere.net/2020/10/13/cors_preflight_request_verification/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eCORS の挙動の観察と preflight request の検証\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://it-web-life.com/javascript_cors_preflight/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e【CORS】JavaScriptにおけるCORSやPreflightを理解する\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://programmer-life.work/html_css/html-request\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eHTTPリクエストとは？HTTPリクエストを目で確認したい | Programmer LifeHTTPリクエストとは？HTTPリクエストを目...\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://qiita.com/att55/items/2154a8aad8bf1409db2b\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eなんとなく CORS がわかる...はもう終わりにする。 - Qiita\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e","tags":[{"id":"web","createdAt":"2022-01-07T13:19:12.628Z","updatedAt":"2022-02-12T02:32:09.404Z","publishedAt":"2022-01-07T13:19:12.628Z","revisedAt":"2022-01-07T13:19:12.628Z","tag":"Web"}],"image":"other"},"highlightedBody":"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003ch2 id=\"hd92040d0df\"\u003eきっかけ\u003c/h2\u003e\u003cp\u003e業務で、Next.jsのフロント側からLaravelのAPIを叩いた時に\u003cstrong\u003eCORSエラー\u003c/strong\u003eというのが出ました。\u003cbr\u003e\u003cbr\u003eエラー解消法はすぐに見つかったものの、セキュリティやその対策の仕組みについてはきちんと理解して実装したいと思い、色々調べたのでまとめておきます。\u003cbr\u003e\u003c/p\u003e\u003ch1 id=\"he84d5455fa\"\u003e同一オリジンポリシー\u003c/h1\u003e\u003cp\u003eCORSについて理解するためには、前提として「同一オリジンポリシー」について知る必要があります。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h19b65993c4\"\u003eオリジンとは\u003c/h3\u003e\u003cp\u003eドメイン＋プロトコル＋ポート番号 を合わせたもの。\u003cbr\u003e\u003cbr\u003e【例】\u003cbr\u003e・ドメイン (domain)：yahoo.co.jp\u003cbr\u003e・オリジン (origin)：\u0026nbsp;\u003ca style=\"color:#4aac00\" href=\"https://yahoo.co.jp/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttps://yahoo.co.jp:443\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"ha2aa5c29c6\"\u003e「同一オリジンである」とは\u003c/h3\u003e\u003cp\u003eドメイン・プロトコル・ポート番号の全てが一致している場合のこと。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h583e348ae7\"\u003e同一オリジンポリシー（Same-Origin Policy）とは\u003c/h3\u003e\u003cp\u003eMDNには以下のように書いてあります。\u003cbr\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cstrong\u003e同一オリジンポリシー\u003c/strong\u003eは重要なセキュリティの仕組みであり、ある\u003ca style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Glossary/Origin\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eオリジン\u003c/a\u003eによって読み込まれた文書やスクリプトが、他のオリジンにあるリソースにアクセスできる方法を制限するものです。\u003cbr\u003e\u003ca style=\"color:#4aac00\" href=\"https://developer.mozilla.org/ja/docs/Web/Security/Same-origin_policy\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e同一オリジンポリシー - ウェブセキュリティ | MDN\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003c/blockquote\u003e\u003cp\u003e要するに、別のオリジンへのアクセスに制限をかけることで、XSSやCSRFといった攻撃を防ぐことを目的とするセキュリティの仕組みです。\u003cbr\u003e\u003cbr\u003eXSSとCSRFについてそれぞれの詳しい攻撃手法はここでは取り上げませんが、対策を講じる上での要点を挙げておきます。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hafaeffc4cb\"\u003eXSS (Cross Site Scripting)\u003c/h3\u003e\u003cp\u003eユーザーが 意図しない不正なスクリプトが\u0026nbsp;Webサーバーに送られ、Webサーバーからのレスポンスを受け取ってしまった結果\u003cstrong\u003eクライアント側 (Web ブラウザ)\u003c/strong\u003e\u0026nbsp;で実行される攻撃。\u003cbr\u003e\u003cbr\u003eブラウザ上で出来ることは何でも悪用対象になるので、CSRFより攻撃範囲が広い。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hc9f9aae59b\"\u003e\u003cstrong\u003eCSRF (Cross-Site Request Forgeries)\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eユーザーが意図しない不正なスクリプトがWebサーバーに送られ、\u0026nbsp;\u003cstrong\u003eWeb アプリケーション (Web サーバー)\u003c/strong\u003e\u0026nbsp;上で実行される攻撃。通称「しーさーふ」。\u003cbr\u003e\u003cbr\u003e悪用内容はサーバー側で用意された処理に限定されるが、\u0026nbsp;\u003cstrong\u003eサーバーにリクエストが到達するだけで攻撃が成立する\u003c/strong\u003eので、XSS対策はできていてもCSRF対策は出来ていないということもあり得る。\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eJavaScript の組み込み API でありAjax 通信を実現する\u0026nbsp;\u003ccode\u003eXMLHttpRequest (XHR)\u003c/code\u003e\u0026nbsp;や\u0026nbsp;\u003ccode\u003eFetch API\u003c/code\u003e\u0026nbsp;などは、これらの脆弱性を回避するため\u003cstrong\u003e同一オリジンポリシー\u003c/strong\u003e（別のオリジンへのアクセスに制限をかける仕組み）に従っています。\u003cbr\u003eXSSとCSRFについての詳細は、以下の記事が分かりやすく勉強になりました。\u003cbr\u003e\u003ca href=\"https://qiita.com/att55/items/a50ca43adde206017525\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eXSS と CSRF って結局何が違うのか？ - Qiita\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e\u003ch1 id=\"h027a034520\"\u003eCORS\u003c/h1\u003e\u003cp\u003e同一オリジンポリシーについて抑えたところで、CORSについて見ていきます。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"hac1783c7e1\"\u003eCORSとは\u003c/h2\u003e\u003cp\u003e読み方：コルス or シーオーアールエス\u003cbr\u003e\u003cstrong\u003eC\u003c/strong\u003eross-\u003cstrong\u003eO\u003c/strong\u003erigin\u0026nbsp;\u003cstrong\u003eR\u003c/strong\u003eesource\u0026nbsp;\u003cstrong\u003eS\u003c/strong\u003eharing の略で、日本語訳すると「\u003cstrong\u003eオリジン間リソース共有\u003c/strong\u003e」。\u003cbr\u003e\u003cbr\u003eCORSは、あるオリジンで動いているWebアプリケーションから別のオリジンのサーバーへのアクセスを許可する仕組みです。\u003cbr\u003e\u003cbr\u003e同一オリジンポリシーにより別のオリジンにはアクセスが出来ないという規制があるが、Web開発・制作では異なるオリジンにアクセスしたいケースもある…　\u003cbr\u003eそこで、同一オリジンポリシーの制約を回避・緩和してくれるのがCORSです。\u003cbr\u003e\u003cbr\u003e歴史をたどるとCORSが必要になった経緯がさらによく分かります。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h3aecdd16f5\"\u003e同一オリジンポリシーはあるが、CORSはない場合…（過去のブラウザ）\u003c/h3\u003e\u003cp\u003e出来たこと\u003c/p\u003e\u003cul\u003e\u003cli\u003e同一オリジンポリシーによりJavaScriptの安全性は確保される。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e生まれた課題\u003c/p\u003e\u003cul\u003e\u003cli\u003eAjaxの普及・発展により、異なるオリジン（主に異なるホスト）のAPIを呼び出したいという動機が生まれた。\u003c/li\u003e\u003cli\u003eJSONPなど同一オリジンポリシーの範囲内で異なるオリジンのAPIを呼び出す方法が考案されたが、裏技のようなものであって安全性には課題が残っていた。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"h510870a262\"\u003eそこで生まれたCORS\u003c/h3\u003e\u003cp\u003e上記のような課題を解決するため生まれたCORSは、以下の機能を提供します。\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eクロスオリジンのアクセスを許可\u003c/li\u003e\u003cli\u003eオリジン単位でのアクセス制御が可能（例：オリジンA・オリジンBとの通信のみ許可する）\u003c/li\u003e\u003cli\u003eHTTPヘッダを用いてアクセス制御を行う\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h922d87a02b\"\u003eCORSはどうやってクロスオリジン通信を許可するのか\u003c/h2\u003e\u003cp\u003e以下のように事前に通信を行う双方で設定を行っておくことで、クロスオリジンの通信が可能になります。\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eクライアントサイド\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHTTPリクエストヘッダに\u003ccode\u003eOriginヘッダ\u003c/code\u003eを付ける。\u003cbr\u003e\u003cbr\u003e・XHRの場合：自動でOriginヘッダが付くので何もしなくて良い\u003cbr\u003e・FetchAPIの場合：mode: cors を付与する\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eサーバーサイド\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHTTPレスポンスヘッダに以下を付ける。\u003cbr\u003e※レスポンスヘッダを付ける方法は環境によって様々です。\u003cbr\u003eLaravelの場合は、Laravel7.0以降は\u003cstrong\u003e\u003ccode\u003econfig/cors.php\u003c/code\u003e\u003c/strong\u003e\u0026nbsp;を使ってCORSの設定ができます。\u003cbr\u003e\u003cbr\u003e\u003cstrong\u003e＊必須＊\u003c/strong\u003e\u003cbr\u003e・\u003ccode\u003eAccess-Control-Allow-Origin: アクセス元のオリジン\u003c/code\u003e\u003cbr\u003e\u003cstrong\u003e＊必要な場合のみ＊\u003c/strong\u003e\u003cbr\u003e・Access-Control-Allow-Credentials: true（Cookieを送信する場合は必要）\u003cbr\u003e・Access-Control-Allow-Headers\u003cbr\u003e・Access-Control-Request-Method\u003cbr\u003e・Access-Control-Max-Age\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h6562eef876\"\u003eCORSによるアクセス制御の流れ\u003c/h2\u003e\u003cp\u003e実際にCORSがアクセス制御を行う流れを、ブラウザの検証ツールのネットワークを観察して確認します。\u003cbr\u003e\u003cbr\u003e【前提】\u003cbr\u003e・フロント側（Next.js）をlocalhost:3001、API（Laravel）をlocalhost:8080で開発中。\u003cbr\u003e・localhost:3001のフロント側から、localhost:8080/logoutというURLにアクセスしてAPIをたたき、クロスオリジンの通信を発生させる。\u003cbr\u003e・リクエストはXHRにより行うので、リクエストヘッダには自動的にOriginヘッダが付く。\u003cbr\u003e・localhost:3001からのリクエストがあった場合は、レスポンスヘッダにAccess-Control-Allow-Originを載せるように、事前にAPI側で設定している。\u003cbr\u003e\u003cbr\u003e【実際の流れ】\u003cbr\u003e1.　ブラウザでlocalhost:3001にアクセスする。\u003cbr\u003e2.　localhots:3001からlocalhost:8080/logoutへHTTPリクエストを送る。\u003cbr\u003e　\u0026lt;ポイント\u0026gt; リクエストヘッダのOriginという項目に、リクエスト元のドメイン情報が載せられる。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003eOrigin: http:\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003elocalhost:\u003cspan class=\"hljs-number\"\u003e3001\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e3.　レスポンスが返ってきたら、localhost:3001はlocalhost:8080からのレスポンスヘッダを見て、レスポンスを受け取るかどうか判断する。\u003cbr\u003e　\u0026lt;ポイント\u0026gt;　レスポンスヘッダに\u0026nbsp;\u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e\u0026nbsp;という項目があり、自分のドメイン情報（localhost:3001）が載せられていればレスポンスを受け取る。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e レスポンスヘッダに以下の記載があれば、レスポンスを受け取る\nAccess-Control-Allow-Origin：http:\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003elocalhost:\u003cspan class=\"hljs-number\"\u003e3001\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"h5d7a611c3a\"\u003e\u003cbr\u003eCORSエラーを起こしてみる\u003c/h3\u003e\u003cp\u003e上記の例では、事前にAPI側（Laravelのconfig/cors.php）でlocalhost:3001からのリクエストに対してAccess-Control-Allow-Originを返す設定をしていた為、クロスオリジンの通信が成立していました。\u003cbr\u003e\u003cbr\u003e試しにAPI側で設定を行っている箇所を削除してみると、レスポンスヘッダに\u0026nbsp;\u003ccode\u003eAccess-Control-Allow-Origin：http://localhost:3001\u003c/code\u003e\u0026nbsp;が無いので、CORSエラーが起こります。\u003cbr\u003e\u003cbr\u003eここでのエラーは、リクエスト自体は送っているけれど、レスポンスが返って来た時にそれを受け取らず\u003cstrong\u003eレスポンスエラー\u003c/strong\u003eということになっています。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h119f62b8ee\"\u003eプリフライトリクエスト\u003c/h2\u003e\u003ch3 id=\"hf8c9fef3ec\"\u003e無条件でリクエストが飛んでも大丈夫なのか？\u003c/h3\u003e\u003cp\u003eCORSの設定をしていないとエラーが発生して通信は成立しませんでしたが、そのエラーはあくまで\u003cstrong\u003eレスポンスを受け取らない\u003c/strong\u003eというものでした。\u003cbr\u003e\u003cbr\u003eしかし、そもそもリクエストが飛んで良いのか？という懸念が残ります。\u003cbr\u003e\u003cbr\u003e代表的なリスクがCSRFです。\u003cbr\u003e\u0026nbsp;\u003cstrong\u003eCSRFではレスポンスを受け取る必要は無く、リクエストが送信できれば攻撃できます。\u003c/strong\u003e\u003cbr\u003e\u003cbr\u003eこのようなリスク対策として、プリフライトリクエストが生まれました。\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"hbcb48602bc\"\u003eプリフライトリクエストの考え方\u003c/h3\u003e\u003cul\u003e\u003cli\u003e元々CORSが無いときにできていたクロスオリジンのリクエストに対して、大幅なリスク増にならない条件であれば、XHR等で無条件にクロスオリジンのリクエストを送信できるようにした。\u003c/li\u003e\u003cli\u003e「大幅なリスク増にならない」条件を単純リクエストとして定義した。\u003c/li\u003e\u003cli\u003e単純リクエストの要件を超える場合は、実際のリクエストを送る前にプリフライトリクエストを送り、実際のリクエストを送信して問題無いか事前に確認する。\u003c/li\u003e\u003cli\u003eプリフライトリクエストを挟むことで、プリフライトリクエストを送信した結果Access-Control-Allow-OriginのHTTPヘッダがついたレスポンスが返されなければ、実際のリクエストは送信しない、というように悪意あるリクエストを防ぐ。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"he303012d4a\"\u003e単純リクエスト（Simple Request）の要件\u003c/h3\u003e\u003cp\u003e以下の要件を全て満たす場合のみ、単純リクエストとなります。\u003cbr\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eメソッドは「GET, POST, HEAD」のいずれか\u003c/li\u003e\u003cli\u003e設定できるリクエストヘッダは以下のいずれか\u003cul\u003e\u003cli\u003eAccept\u003c/li\u003e\u003cli\u003eAccept-Language\u003c/li\u003e\u003cli\u003eContent-Language\u003c/li\u003e\u003cli\u003eContent-Type（条件付き）\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eContent-Typeについては以下のいずれかを満たすこと\u003cul\u003e\u003cli\u003eapplication/x-www-form-urlencoded\u003c/li\u003e\u003cli\u003emultipart/form-data（ファイルアップロードに使う）\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003etext/plain（滅多に使わない）\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"ha214098e44\"\u003eまとめ\u003c/h2\u003e\u003cul\u003e\u003cli\u003eXSSやCSRFなどの対策として、他のオリジンへのアクセスを制限する「同一オリジンポリシー」という仕組みがある。\u003c/li\u003e\u003cli\u003e他のオリジンへアクセスしたい、でも安全性も保ちたい、、を叶えるためCORSが生まれた。\u003c/li\u003e\u003cli\u003e通常のCORSはレスポンスが届いたときにレスポンスを受け取るかどうかの制御を行うので、リクエスト自体は無条件に飛んでしまう。そこで不正なリクエストが送られてしまうリスク対策として、プリフライトリクエストが生まれた。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"h3bcda3e6b0\"\u003e最後に\u003c/h2\u003e\u003cp\u003eエラーが解消されて動けばOKではなく、きちんと仕組みを調べてみてかなり理解が深まったかなと思います。（もし誤りがあれば是非ご指摘いただけると幸いです…！！）\u003cbr\u003e\u003cbr\u003eこれまでHTTPリクエストヘッダやレスポンスヘッダをまじまじと見たことも無かったので、Ajax通信を行っている箇所で検証ツールを確認してみると面白かったです。\u003cbr\u003e確かにOriginやAccess-Control-Allow-Originがあったり、プリフライトリクエストが送られてレスポンスが返って来てから本番のリクエストが送られているのが確認できて、勉強になりました。\u003cbr\u003eセキュリティ対策についてしっかり理解できていなくても動くアプリを作ることが出来てしまうというのは怖いことだなと思うので、これからもセキュリティの勉強はしていきたいと思います。\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"he45680f0bc\"\u003e参考記事\u003c/h2\u003e\u003cp\u003e\u003cbr\u003e\u003ca href=\"https://developer.mozilla.org/ja/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eオリジン間リソース共有 (CORS) - HTTP | MDN\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://labor.ewigleere.net/2020/10/13/cors_preflight_request_verification/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eCORS の挙動の観察と preflight request の検証\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://it-web-life.com/javascript_cors_preflight/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e【CORS】JavaScriptにおけるCORSやPreflightを理解する\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://programmer-life.work/html_css/html-request\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eHTTPリクエストとは？HTTPリクエストを目で確認したい | Programmer LifeHTTPリクエストとは？HTTPリクエストを目...\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e\u003ca href=\"https://qiita.com/att55/items/2154a8aad8bf1409db2b\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eなんとなく CORS がわかる...はもう終わりにする。 - Qiita\u003c/a\u003e\u003cbr\u003e\u003c/p\u003e\u003c/body\u003e\u003c/html\u003e"},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"cors"},"buildId":"EwuWiZmkeG3lYlO_XC9fM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
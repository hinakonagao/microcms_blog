{"pageProps":{"blog":{"id":"react-typescript","createdAt":"2022-02-12T10:20:56.912Z","updatedAt":"2022-02-17T13:33:23.975Z","publishedAt":"2022-01-16T10:20:56.000Z","revisedAt":"2022-02-12T10:21:12.181Z","title":"React×TypeScript　基本の型定義","body":"<h2 id=\"h04bc4be39a\"> はじめに</h2><p>業務でフロント側はReact（Next.js）, TypeScriptを使っているのですが、配属当初の私はReactにもTypeScriptにも触れたことが無く、何が分からないのか分からない状態でした。<br><br>TypeScriptの基礎を学んでもReact特有の型定義があり戸惑いましたが、ようやく理解して書けるようになって来たな…ということで、辞書代わりにまとめておきます。<br>（誤りのご指摘・アドバイスがあればぜひお願いします！）<br></p><h1 id=\"h2e4995e418\"> 基礎編</h1><p>まずは基本の型定義を一通り挙げます。<br></p><h2 id=\"hd817cee2b9\"> 関数コンポーネント</h2><p>関数コンポーネントでは、普通の関数と同じように引数（props）に型付けします。<br><br>戻り値はJSX要素を返せば型推論されるので、明らかな場合は型付けしなくてOKです。<br><br>※以下の例では、propsは分割代入の書き方で受け取るものとします。<br></p><h3 id=\"h480940b7cc\"> 引数（props）なしの場合</h3><p>propsを受け取らない場合は、JavaScriptで記述するときと変わりません。<br></p><pre><code>// ノーマルの関数コンポーネント（引数なしの場合）\nconst App = () =&gt; &lt;div&gt;なまえ&lt;/div&gt;</code></pre><p><br></p><h3 id=\"h40e5e6f6fd\"> ひとつのpropsを受け取る</h3><pre><code>// 引数に型付けする\nconst App = ({ name }: { name: string }) =&gt; &lt;div&gt;{name}&lt;/div&gt;\n\n// 型エイリアスを使っても良い\ntype Props = { name: string }\nconst App = ({ name }: Props) =&gt; &lt;div&gt;{name}&lt;/div&gt;</code></pre><p><br>型注釈を直接つけても、型エイリアスを使ってもOKです。<br><br>プロジェクト内で合わせておけば良いかと思います。<br></p><h3 id=\"h2ac392abf5\"> 複数のpropsを受け取る</h3><p>propsを複数受け取る場合は、型注釈を直接つけるよりも型エイリアスを付けた方が分かりやすいでしょう。<br></p><pre><code>// 引数が複数なら、型エイリアスを使う方が見やすい\ntype Props = {\n&nbsp;name: srting\n&nbsp;onClick: () =&gt; void\n&nbsp;children: ReactNode\n}</code></pre><p><br></p><h3 id=\"h5f171d61d9\"> propsの型いろいろ</h3><p>以下のように色々な型の値をpropsとして受け取ることができます。<br>ここはほとんどTypeScriptの基本通りです。<br></p><pre><code>// propsとして受け取る値の型定義色々\ntype Props = {\n&nbsp;str: string&nbsp;&nbsp;&nbsp;&nbsp;// 文字列\n&nbsp;num: number&nbsp;&nbsp;&nbsp;&nbsp;// 数値\n&nbsp;bool: boolean&nbsp;&nbsp;&nbsp;// 真偽値\n&nbsp;strArr: string[]&nbsp;&nbsp;// 配列\n&nbsp;obj: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// オブジェクト\n&nbsp;&nbsp;str: string\n&nbsp;}\n&nbsp;objArr: {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// オブジェクトの配列\n&nbsp;&nbsp;str: string\n&nbsp;&nbsp;num: number\n&nbsp;}[]\n&nbsp;func: () =&gt; void&nbsp;&nbsp;// 関数\n}</code></pre><p><br></p><h3 id=\"ha7733746f8\"> children</h3><p>childrenはコンポーネントのタグで囲った子要素をpropsとして受け取るときに使います。<br><br>よく使うのはReactNodeで、これはコンポーネントタグで囲ったJSX要素をまるっと受け取る場合に使います。<br></p><pre><code>// 共通レイアウトのコンポーネント\nconst MainLayout = ({ children }: { children: React.ReactNode }) =&gt; {\n&nbsp;return (\n&nbsp;&nbsp;&lt;&gt;\n&nbsp;&nbsp;&nbsp;&lt;Header /&gt;\n&nbsp;&nbsp;&nbsp;&lt;div&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;{children}\n&nbsp;&nbsp;&nbsp;&lt;/div&gt;\n&nbsp;&nbsp;&nbsp;&lt;Footer /&gt;\n&nbsp;&nbsp;&lt;/&gt;\n&nbsp;)\n}\n\n// 呼び出し側\nconst MenuPage = () =&gt; {\n&nbsp;return (\n&nbsp;&nbsp;&lt;MainLayout&gt;\n&nbsp;&nbsp;&nbsp;// この中にページの内容を書く\n&nbsp;&nbsp;&lt;/MainLayout&gt;\n&nbsp;)\n}</code></pre><p><br>もし特定の文字列や数値しか受け取らないというような場合は、ReactNodeではなく特定の型に制限することもできます。<br></p><pre><code>// Buttonコンポーネント\nconst Button = ({ children }: { children: string }) =&gt; {\n&nbsp;return (\n&nbsp;&nbsp;&lt;button&gt;{children}&lt;/button&gt;\n&nbsp;)\n}\n\n// 呼び出し側\nconst App = () =&gt; {\n&nbsp;return (\n&nbsp;&nbsp;&lt;&gt;\n// フォームの記述があるとする\n\n&nbsp;&nbsp;&nbsp;&lt;Button&gt;送信&lt;/Button&gt;\n&nbsp;&nbsp;&nbsp;&lt;Button&gt;戻る&lt;/Button&gt;\n&nbsp;&nbsp;&lt;/&gt;\n&nbsp;)\n}</code></pre><p><br>ちなみにReactNodeは以下の通りのUnion型で定義されています。<br></p><pre><code>type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;</code></pre><p><br></p><h3 id=\"h31df23c0b3\"> propsのデフォルト値を指定する</h3><p>コンポーネントの利用箇所ごとにpropsに渡す値を指定してもよいのですが、デフォルト値を指定することもできます。<br>よく指定される値がある時や、値が無かった場合の値を決めておきたい場合に有効です。<br></p><pre><code>const Name = ({ name = \"ゲスト\" }: { name?: string }) =&gt; &lt;div&gt;{name}さん&lt;/div&gt;</code></pre><p><br></p><h3 id=\"h5be2f009d7\"> オプショナルなprops（undefined許容）</h3><p><code>?</code> を付けることでオプショナルな型定義が出来ます。  <br>以下のように書いた場合、name・emailの型は<code>string | undefined</code>となります。  <br></p><pre><code>type Props = {\n&nbsp;name?: string\n&nbsp;email?: string\n}</code></pre><p><br>この場合はundefinedの可能性を考慮してpropsの初期値を設定するか、値の有無による条件分岐を行います。<br></p><pre><code>// nameは初期値を設定、emailはpropsの値が渡された場合のみ表示する\nconst Button = ({ name = 'ゲスト', email }: Props) =&gt; {\n&nbsp;return (\n&nbsp;&nbsp;&lt;div&gt;\n&nbsp;&nbsp;&nbsp;&lt;p&gt;{name}さん&lt;/p&gt;\n&nbsp;&nbsp;&nbsp;{email &amp;&amp; (\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;email:{email}&lt;/p&gt;\n&nbsp;&nbsp;&nbsp;)}\n&nbsp;&nbsp;&lt;/div&gt;\n&nbsp;)\n}</code></pre><p><br></p><h3 id=\"h61a1261837\"> 戻り値の型付け</h3><p>JSX要素を返せば型を指定していなくても推論してくれますが、明示しておけば正しい値が返されなかった場合エラーを表示してくれます。<br></p><pre><code>const App = ({ name }: { name: string }): JSX.Element =&gt; &lt;div&gt;{name}&lt;/div&gt;;</code></pre><p><br></p><h3 id=\"h40fc68507d\"> React.FC / VFC</h3><p>React.FC / VFC については、TypeSctriptを導入するのであれば不要と考えられるのでここでは取り上げません。（今の私の業務では使っていないのですが、もしなにか誤りやアドバイスがあれば是非ご教授ください…！）<br>参考記事：<a href=\"https://kray.jp/blog/dont-have-to-use-react-fc-and-react-vfc/\" target=\"_blank\" rel=\"noopener noreferrer\">【検証】React.FC と React.VFC はべつに使わなくていい説</a> <br></p><h2 id=\"h2e72b92d37\"> useState　状態変数の型</h2><h3 id=\"hde697c111e\"> 型推論に任せる</h3><p>useStateフックでは初期値を与えれば状態変数の型を推論してくれます。<br>なので極力初期値を与えて、推論させるようにします。<br></p><pre><code>// プリミティブ値\nconst [name, setName] = useState(\"\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// string型\nconst [count, setCount] = useState(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// number型\nconst [isChecked, setIsCheked] = useState(false)&nbsp;&nbsp;// boolean型\n\n// 配列\nconst [colors, setColors] = useState([\"red\", \"blue\"])&nbsp;&nbsp;// string型の配列\nconst [numbers, setNumbers] = useState([1, 2, 3])&nbsp;&nbsp;&nbsp;&nbsp;// number型の配列</code></pre><p><br></p><h3 id=\"h6b88d1350c\"> ジェネリック型で指定する</h3><ul><li> 基本の指定方法</li></ul><p>useStateの状態変数に対して明示的に型を指定する場合は、ジェネリック型 <code>&lt;T&gt;</code> を使います。  <br></p><pre><code>// useStateのジェネリック型&lt;T&gt;に明示的に型を指定する\nconst [name, setName] = useState&lt;string&gt;(\"\")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// string型\nconst [count, setCount] = useState&lt;number&gt;(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// number型\nconst [isChecked, setIsChecked] = useState&lt;boolean&gt;(false)&nbsp;&nbsp;// boolean型</code></pre><p><br></p><ul><li> 別途定義した型をジェネリック型で指定する</li></ul><p>別途定義したオブジェクトを初期値にしたり、別途定義した型をジェネリック型で指定することもできます。<br>（型や初期値を複数のコンポーネントで使い回す場合や情報量が多くなる場合は、別ファイルに切り出しても良いかと思います。）<br></p><pre><code>const initialUser = {\n&nbsp;number: 1,\n&nbsp;name: '名前',\n&nbsp;email: 'test@mail.com'\n}\n\ntype User = {\n&nbsp;number: number\n&nbsp;name: string\n&nbsp;email: string\n}\n\nconst [user, setUser] = useState&lt;User&gt;(initialUser)</code></pre><p><br></p><ul><li> ユニオン型でnullを含める </li></ul><p>値がnullの可能性があるときや、型は定めておきたいが初期値は後から決まるといった場合は、ユニオン型でnullを含めます。<br></p><pre><code>// nullを含む場合はユニオン型を用いる\nconst [count, setCount] = useState&lt;number | null&gt;(null)&nbsp;&nbsp;// number型もしくはnull型</code></pre><p><br></p><ul><li> 型アサーションを使う</li></ul><p>状態変数の初期値が決まらないけれどnullは許可しないという場合には、型アサーションを使うことができます。<br><br>まず、以下の書き方ではエラーが出ます。<br></p><pre><code>type User = {\n&nbsp;number: number\n&nbsp;name: string\n&nbsp;email: string\n}\n\nconst [user, setUser] = useState&lt;User&gt;({})\nuser[name] = 'ゲスト'\n\n// userは「空のオブジェクト型」とTypeScriptは認識するのでコンパイルエラーになる</code></pre><p><br>そこで有効なのが型アサーションです。<br></p><pre><code>type User = {\n&nbsp;number: number\n&nbsp;name: string\n&nbsp;email: string\n}\n\nconst [user, setUser] = useState&lt;User&gt;({} as User)\n\n// 型アサーションを使えばコンパイルエラーが出ない</code></pre><p><br>ただし型アサーションはTypeScriptに型を偽っているだけなので、もし必要なプロパティを忘れていてもコンパイラエラーが指摘してくれないので、なるべく初期値を設定して型アサーションを使わずに済む実装にした方がベターです。<br><br>もし全てのプロパティが任意ならば、初期値に空オブジェクトを与えても問題ないので型アサーションは必要ありません。<br></p><pre><code>type User = {&nbsp;\n&nbsp;name?: string\n&nbsp;email?: string\n&nbsp;age?: number\n}\n\nconst [user, setUser] = useState&lt;User&gt;({})\n\n// userはUser型のうち任意のプロパティを持つ（空オブジェクトの可能性もある）</code></pre><p><br></p><h2 id=\"h6553d2c03c\"> useEffect</h2><p>useEffectの戻り値は <code>undefined</code> もしくはクリーンアップ関数と決められており、戻り値を処理しないため型は必要ありません。  <br><br>ただし関数や値を返してしまうとエラーになるので、アロー関数の書き方に注意が必要です。<br><br>以下の書き方では、アロー関数式<code>=&gt;</code>の本体に波括弧<code>{}</code>なしに1行で書いた文が戻り値になってしまいます。   <br></p><pre><code>useEffect(() =&gt;&nbsp;\n&nbsp;setTimeout(() =&gt;&nbsp;\n&nbsp;&nbsp;// 処理\n&nbsp;, 1000);\n, []);</code></pre><p><br>以下のように、本体を <code>{}</code> で囲むようにしてください。  <br></p><pre><code>useEffect(() =&gt; {\n&nbsp;setTimeout(() =&gt; {\n&nbsp;&nbsp;// 処理\n&nbsp;}, 1000);\n}, []);</code></pre><p><br></p><h2 id=\"h7cf02dc148\"> イベントオブジェクトの型</h2><p>onClickやonChangeといったイベントハンドラで扱うイベントにも型があります。<br><br>イベントオブジェクトの型を知りたいときは、VSCodeがヒントをくれます。<br><br>例えばonClickなら、以下の状態でonClickの上にマウスをホバーさせると型情報を表示してくれます。<br></p><pre><code>&lt;button onClick={}&gt;&lt;/button&gt;</code></pre><p><br>以下のように要素のイベント属性に直接イベントハンドラを書く場合は、引数のイベントの型は推論されるので注釈が要りません。<br></p><pre><code>&lt;button onClick={(event) =&gt; //処理 }&gt;&lt;/button&gt;</code></pre><p><br>イベントハンドラの関数を別途定義する場合は、通常の関数と同様に型付けが必要になります。<br></p><h3 id=\"h745a3f474e\"> onClickイベント</h3><p>引数のイベントと戻り値に型付けをします。（戻り値は推論させてもOKです）<br></p><pre><code>// Buttonクリックの場合\nconst onClickButton = ( event: React.MouseEvent&lt;HTMLButtonElement, MouseEvent&gt; ):void =&gt; {\n&nbsp;// 処理\n}</code></pre><p><br></p><h3 id=\"hc860cddeda\"> onChangeイベント</h3><pre><code>// Inputの場合\nconst onChangeInput = ( event: React.ChangeEvent&lt;HTMLInputElement&gt;):void =&gt; {\n&nbsp;// 処理\n}</code></pre><p><br></p><h3 id=\"h0591b223f6\"> 複数種類の要素にイベントを適用する</h3><p>上記の例を見ると、ジェネリック型の部分に <code>HTMLButtonElement</code> <code>HTMLInputElement</code> とあるように特定のHTML要素のための型であることがわかります。   <br><br>もしDivタグ・Buttonタグ・Inputタグなどに同じイベントハンドラ関数を指定したい場合、通常は <code>HTMLButtonElement | HTMLInputElement | 続く...</code> と使いたい要素分の型を記述する必要があります。  <br><br>そんな時は、色んなHTML要素に共通して使える <code>HTMLElement</code> 型を使うこともできます。  <br></p><pre><code>type Props = {\n&nbsp;onClick: (event: React.MouseEvent&lt;HTMLElement, MouseEvent&gt;) =&gt; void\n}</code></pre><p><br>以下の記事に詳しくまとめられており、非常に分かりやすかったです。<br><br>個人的には、精度を高めるためには面倒でも使う要素分だけ指定する方が良いのかな…？とも思いますが、 <code>HTMLButtonElem ent</code>  も<code> HTMLInputElement</code> も<code>HTMLElement</code> 型を継承しているんだと知り、勉強になりました。<br><a href=\"https://qiita.com/Takepepe/items/f1ba99a7ca7e66290f24\" target=\"_blank\" rel=\"noopener noreferrer\">any型で諦めない React.EventCallback - Qiita</a> <br></p><h2 id=\"hadc4cddfcc\"> 【番外編】Axios</h2><p>Axiosを使って非同期通信を行う際に返されるレスポンスやエラーにも型があります。<br></p><pre><code>import { AxiosError, AxiosResponse } from 'axios'\n\naxios\n&nbsp;.get('/url')\n&nbsp;.then((response: AxiosResponse) =&gt; {\n&nbsp;&nbsp;// 成功時の処理\n&nbsp;})\n&nbsp;.catch((error: AxiosError) =&gt; {\n&nbsp;&nbsp;// エラー時の処理\n&nbsp;})</code></pre><p><br></p><h2 id=\"h691cb018bd\"> おわりに</h2><p>正直はじめは、何か書くたびにエラーが出るしコード量が増えて余計にわけわからんと思いました。<br><br>でも慣れてくると、型が明示してあると処理の流れを追わなくてもどういう値が入って来るのかパッと見でも分かりやすいし、エディタの補完が効くのは便利で間違いがあれば気付けてTypeScript良いなと思うようになりました。<br><br>今後もより実用的でスマートな型の活用法を学んでいきたいと思います。<br></p><h2 id=\"h3937880ed1\"> 参考記事</h2><p><a href=\"https://github.com/typescript-cheatsheets/react\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/typescript-cheatsheets/react</a><br><br><a href=\"https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB</a><br><br><a href=\"https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF</a><br><br><br><br><br></p>","tags":[{"id":"typescript","createdAt":"2022-01-07T13:18:58.358Z","updatedAt":"2022-02-17T03:22:47.524Z","publishedAt":"2022-01-07T13:18:58.358Z","revisedAt":"2022-02-17T03:22:47.524Z","tag":"TypeScript"},{"id":"react","createdAt":"2022-01-07T13:17:54.189Z","updatedAt":"2022-02-12T02:31:51.382Z","publishedAt":"2022-01-07T13:17:54.189Z","revisedAt":"2022-01-07T13:17:54.189Z","tag":"React"}],"image":"typescript"},"highlightedBody":"<html><head></head><body><h2 id=\"h04bc4be39a\"> はじめに</h2><p>業務でフロント側はReact（Next.js）, TypeScriptを使っているのですが、配属当初の私はReactにもTypeScriptにも触れたことが無く、何が分からないのか分からない状態でした。<br><br>TypeScriptの基礎を学んでもReact特有の型定義があり戸惑いましたが、ようやく理解して書けるようになって来たな…ということで、辞書代わりにまとめておきます。<br>（誤りのご指摘・アドバイスがあればぜひお願いします！）<br></p><h1 id=\"h2e4995e418\"> 基礎編</h1><p>まずは基本の型定義を一通り挙げます。<br></p><h2 id=\"hd817cee2b9\"> 関数コンポーネント</h2><p>関数コンポーネントでは、普通の関数と同じように引数（props）に型付けします。<br><br>戻り値はJSX要素を返せば型推論されるので、明らかな場合は型付けしなくてOKです。<br><br>※以下の例では、propsは分割代入の書き方で受け取るものとします。<br></p><h3 id=\"h480940b7cc\"> 引数（props）なしの場合</h3><p>propsを受け取らない場合は、JavaScriptで記述するときと変わりません。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// ノーマルの関数コンポーネント（引数なしの場合）</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>なまえ<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></code></pre><p><br></p><h3 id=\"h40e5e6f6fd\"> ひとつのpropsを受け取る</h3><pre><code class=\"hljs\"><span class=\"hljs-comment\">// 引数に型付けする</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\">{ name }: { name: <span class=\"hljs-built_in\">string</span> }</span>) =&gt; <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n\n<span class=\"hljs-comment\">// 型エイリアスを使っても良い</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Props</span> = { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span> }\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\">{ name }: Props</span>) =&gt; <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></code></pre><p><br>型注釈を直接つけても、型エイリアスを使ってもOKです。<br><br>プロジェクト内で合わせておけば良いかと思います。<br></p><h3 id=\"h2ac392abf5\"> 複数のpropsを受け取る</h3><p>propsを複数受け取る場合は、型注釈を直接つけるよりも型エイリアスを付けた方が分かりやすいでしょう。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// 引数が複数なら、型エイリアスを使う方が見やすい</span>\ntype Props = {\n&nbsp;<span class=\"hljs-attr\">name</span>: srting\n&nbsp;onClick: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">void</span>\n&nbsp;children: ReactNode\n}</code></pre><p><br></p><h3 id=\"h5f171d61d9\"> propsの型いろいろ</h3><p>以下のように色々な型の値をpropsとして受け取ることができます。<br>ここはほとんどTypeScriptの基本通りです。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// propsとして受け取る値の型定義色々</span>\ntype P<span class=\"hljs-attr\">rops</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-punctuation\">{</span>\n<span class=\"hljs-symbol\">&nbsp;str:</span> string&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// 文字列</span>\n<span class=\"hljs-symbol\">&nbsp;num:</span> number&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// 数値</span>\n<span class=\"hljs-symbol\">&nbsp;bool:</span> boolean&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// 真偽値</span>\n<span class=\"hljs-symbol\">&nbsp;strArr:</span> string[]&nbsp;&nbsp;<span class=\"hljs-comment\">// 配列</span>\n<span class=\"hljs-symbol\">&nbsp;obj:</span> <span class=\"hljs-punctuation\">{</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// オブジェクト</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;str:</span> string\n&nbsp;<span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-symbol\">&nbsp;objArr:</span> <span class=\"hljs-punctuation\">{</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// オブジェクトの配列</span>\n<span class=\"hljs-symbol\">&nbsp;&nbsp;str:</span> string\n<span class=\"hljs-symbol\">&nbsp;&nbsp;num:</span> number\n&nbsp;<span class=\"hljs-punctuation\">}</span>[]\n<span class=\"hljs-symbol\">&nbsp;func:</span> () =&gt; void&nbsp;&nbsp;<span class=\"hljs-comment\">// 関数</span>\n<span class=\"hljs-punctuation\">}</span></code></pre><p><br></p><h3 id=\"ha7733746f8\"> children</h3><p>childrenはコンポーネントのタグで囲った子要素をpropsとして受け取るときに使います。<br><br>よく使うのはReactNodeで、これはコンポーネントタグで囲ったJSX要素をまるっと受け取る場合に使います。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// 共通レイアウトのコンポーネント</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">MainLayout</span> = (<span class=\"hljs-params\">{ children }: { children: React.ReactNode }</span>) =&gt; {\n&nbsp;<span class=\"hljs-keyword\">return</span> (\n&nbsp;&nbsp;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;&nbsp;{children}\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span>\n&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;/&gt;</span></span>\n&nbsp;)\n}\n\n<span class=\"hljs-comment\">// 呼び出し側</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">MenuPage</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n&nbsp;<span class=\"hljs-keyword\">return</span> (\n&nbsp;&nbsp;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MainLayout</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;// この中にページの内容を書く\n&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MainLayout</span>&gt;</span></span>\n&nbsp;)\n}</code></pre><p><br>もし特定の文字列や数値しか受け取らないというような場合は、ReactNodeではなく特定の型に制限することもできます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// Buttonコンポーネント</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Button</span> = (<span class=\"hljs-params\">{ children }: { children: <span class=\"hljs-built_in\">string</span> }</span>) =&gt; {\n&nbsp;<span class=\"hljs-keyword\">return</span> (\n&nbsp;&nbsp;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>{children}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n&nbsp;)\n}\n\n<span class=\"hljs-comment\">// 呼び出し側</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">App</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n&nbsp;<span class=\"hljs-keyword\">return</span> (\n&nbsp;&nbsp;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n// フォームの記述があるとする\n\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span>&gt;</span>送信<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Button</span>&gt;</span>戻る<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Button</span>&gt;</span>\n&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;/&gt;</span></span>\n&nbsp;)\n}</code></pre><p><br>ちなみにReactNodeは以下の通りのUnion型で定義されています。<br></p><pre><code class=\"hljs\">type ReactNode = ReactChild | <span class=\"hljs-type\">ReactFragment</span> | <span class=\"hljs-type\">ReactPortal</span> | <span class=\"hljs-type\">boolean</span> | <span class=\"hljs-type\">null</span> | <span class=\"hljs-type\">undefined</span>;</code></pre><p><br></p><h3 id=\"h31df23c0b3\"> propsのデフォルト値を指定する</h3><p>コンポーネントの利用箇所ごとにpropsに渡す値を指定してもよいのですが、デフォルト値を指定することもできます。<br>よく指定される値がある時や、値が無かった場合の値を決めておきたい場合に有効です。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Name</span> = (<span class=\"hljs-params\">{ name = <span class=\"hljs-string\">\"ゲスト\"</span> }: { name?: <span class=\"hljs-built_in\">string</span> }</span>) =&gt; <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{name}さん<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span></code></pre><p><br></p><h3 id=\"h5be2f009d7\"> オプショナルなprops（undefined許容）</h3><p><code>?</code> を付けることでオプショナルな型定義が出来ます。  <br>以下のように書いた場合、name・emailの型は<code>string | undefined</code>となります。  <br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">type</span> Props = {\n&nbsp;name?: <span class=\"hljs-keyword\">string</span>\n&nbsp;email?: <span class=\"hljs-keyword\">string</span>\n}</code></pre><p><br>この場合はundefinedの可能性を考慮してpropsの初期値を設定するか、値の有無による条件分岐を行います。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// nameは初期値を設定、emailはpropsの値が渡された場合のみ表示する</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Button</span> = (<span class=\"hljs-params\">{ name = <span class=\"hljs-string\">'ゲスト'</span>, email }: Props</span>) =&gt; {\n&nbsp;<span class=\"hljs-keyword\">return</span> (\n&nbsp;&nbsp;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{name}さん<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;{email &amp;&amp; (\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>email:{email}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n&nbsp;&nbsp;&nbsp;)}\n&nbsp;&nbsp;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n&nbsp;)\n}</code></pre><p><br></p><h3 id=\"h61a1261837\"> 戻り値の型付け</h3><p>JSX要素を返せば型を指定していなくても推論してくれますが、明示しておけば正しい値が返されなかった場合エラーを表示してくれます。<br></p><pre><code class=\"hljs\">const App = ({<span class=\"hljs-built_in\"> name</span> }: {<span class=\"hljs-built_in\"> name</span>:<span class=\"hljs-built_in\"> string</span> }): JSX.Element =&gt; <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><span class=\"language-xquery\"><span class=\"hljs-built_in\">{name</span>}</span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;</code></pre><p><br></p><h3 id=\"h40fc68507d\"> React.FC / VFC</h3><p>React.FC / VFC については、TypeSctriptを導入するのであれば不要と考えられるのでここでは取り上げません。（今の私の業務では使っていないのですが、もしなにか誤りやアドバイスがあれば是非ご教授ください…！）<br>参考記事：<a href=\"https://kray.jp/blog/dont-have-to-use-react-fc-and-react-vfc/\" target=\"_blank\" rel=\"noopener noreferrer\">【検証】React.FC と React.VFC はべつに使わなくていい説</a> <br></p><h2 id=\"h2e72b92d37\"> useState　状態変数の型</h2><h3 id=\"hde697c111e\"> 型推論に任せる</h3><p>useStateフックでは初期値を与えれば状態変数の型を推論してくれます。<br>なので極力初期値を与えて、推論させるようにします。<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// プリミティブ値</span>\nconst <span class=\"hljs-selector-attr\">[name, setName]</span> = <span class=\"hljs-built_in\">useState</span>(<span class=\"hljs-string\">\"\"</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// string型</span>\nconst <span class=\"hljs-selector-attr\">[count, setCount]</span> = <span class=\"hljs-built_in\">useState</span>(<span class=\"hljs-number\">0</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// number型</span>\nconst <span class=\"hljs-selector-attr\">[isChecked, setIsCheked]</span> = <span class=\"hljs-built_in\">useState</span>(false)&nbsp;&nbsp;<span class=\"hljs-comment\">// boolean型</span>\n\n<span class=\"hljs-comment\">// 配列</span>\nconst <span class=\"hljs-selector-attr\">[colors, setColors]</span> = <span class=\"hljs-built_in\">useState</span>(<span class=\"hljs-selector-attr\">[<span class=\"hljs-string\">\"red\"</span>, <span class=\"hljs-string\">\"blue\"</span>]</span>)&nbsp;&nbsp;<span class=\"hljs-comment\">// string型の配列</span>\nconst <span class=\"hljs-selector-attr\">[numbers, setNumbers]</span> = <span class=\"hljs-built_in\">useState</span>(<span class=\"hljs-selector-attr\">[1, 2, 3]</span>)&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// number型の配列</span></code></pre><p><br></p><h3 id=\"h6b88d1350c\"> ジェネリック型で指定する</h3><ul><li> 基本の指定方法</li></ul><p>useStateの状態変数に対して明示的に型を指定する場合は、ジェネリック型 <code>&lt;T&gt;</code> を使います。  <br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// useStateのジェネリック型&lt;T&gt;に明示的に型を指定する</span>\n<span class=\"hljs-keyword\">const</span> [name, setName] = useState&lt;<span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-string\">\"\"</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// string型</span>\n<span class=\"hljs-keyword\">const</span> [count, setCount] = useState&lt;<span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-number\">0</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">// number型</span>\n<span class=\"hljs-keyword\">const</span> [isChecked, setIsChecked] = useState&lt;<span class=\"hljs-built_in\">boolean</span>&gt;(<span class=\"hljs-literal\">false</span>)&nbsp;&nbsp;<span class=\"hljs-comment\">// boolean型</span></code></pre><p><br></p><ul><li> 別途定義した型をジェネリック型で指定する</li></ul><p>別途定義したオブジェクトを初期値にしたり、別途定義した型をジェネリック型で指定することもできます。<br>（型や初期値を複数のコンポーネントで使い回す場合や情報量が多くなる場合は、別ファイルに切り出しても良いかと思います。）<br></p><pre><code class=\"hljs\">const initialUser = {\n<span class=\"hljs-built_in\">&nbsp;number</span>: <span class=\"hljs-number\">1</span>,\n<span class=\"hljs-built_in\">&nbsp;name</span>: <span class=\"hljs-string\">'名前'</span>,\n&nbsp;email: <span class=\"hljs-string\">'test@mail.com'</span>\n}\n\ntype User = {\n<span class=\"hljs-built_in\">&nbsp;number</span>:<span class=\"hljs-built_in\"> number</span>\n<span class=\"hljs-built_in\">&nbsp;name</span>:<span class=\"hljs-built_in\"> string</span>\n&nbsp;email:<span class=\"hljs-built_in\"> string</span>\n}\n\nconst [user, setUser] = useState<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">User</span>&gt;</span>(initialUser)</span></code></pre><p><br></p><ul><li> ユニオン型でnullを含める </li></ul><p>値がnullの可能性があるときや、型は定めておきたいが初期値は後から決まるといった場合は、ユニオン型でnullを含めます。<br></p><pre><code class=\"hljs\">// <span class=\"hljs-literal\">null</span>を含む場合はユニオン型を用いる\n<span class=\"hljs-keyword\">const</span> [count, setCount] = useState&lt;<span class=\"hljs-built_in\">number</span> | <span class=\"hljs-literal\">null</span>&gt;(<span class=\"hljs-literal\">null</span>)&nbsp;&nbsp;// <span class=\"hljs-built_in\">number</span>型もしくは<span class=\"hljs-literal\">null</span>型</code></pre><p><br></p><ul><li> 型アサーションを使う</li></ul><p>状態変数の初期値が決まらないけれどnullは許可しないという場合には、型アサーションを使うことができます。<br><br>まず、以下の書き方ではエラーが出ます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">User</span> = {\n&nbsp;number: number\n&nbsp;<span class=\"hljs-type\">name</span>: string\n&nbsp;email: string\n}\n\nconst [<span class=\"hljs-keyword\">user</span>, setUser] = useState&lt;<span class=\"hljs-keyword\">User</span>&gt;({})\n<span class=\"hljs-keyword\">user</span>[<span class=\"hljs-type\">name</span>] = <span class=\"hljs-string\">'ゲスト'</span>\n\n// <span class=\"hljs-keyword\">user</span>は「空のオブジェクト型」とTypeScriptは認識するのでコンパイルエラーになる</code></pre><p><br>そこで有効なのが型アサーションです。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">User</span> <span class=\"hljs-title\">= {\n&nbsp;number</span>: <span class=\"hljs-keyword\">number</span>\n&nbsp;name: <span class=\"hljs-keyword\">string</span>\n&nbsp;email: <span class=\"hljs-keyword\">string</span>\n}\n\nconst [user, setUser] = useState<span class=\"hljs-tag\">&lt;User&gt;</span>({} as User)\n\n// 型アサーションを使えばコンパイルエラーが出ない</code></pre><p><br>ただし型アサーションはTypeScriptに型を偽っているだけなので、もし必要なプロパティを忘れていてもコンパイラエラーが指摘してくれないので、なるべく初期値を設定して型アサーションを使わずに済む実装にした方がベターです。<br><br>もし全てのプロパティが任意ならば、初期値に空オブジェクトを与えても問題ないので型アサーションは必要ありません。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">User</span> <span class=\"hljs-title\">= {&nbsp;\n&nbsp;name</span>?: <span class=\"hljs-keyword\">string</span>\n&nbsp;email?: <span class=\"hljs-keyword\">string</span>\n&nbsp;age?: <span class=\"hljs-keyword\">number</span>\n}\n\nconst [user, setUser] = useState<span class=\"hljs-tag\">&lt;User&gt;</span>({})\n\n// userはUser型のうち任意のプロパティを持つ（空オブジェクトの可能性もある）</code></pre><p><br></p><h2 id=\"h6553d2c03c\"> useEffect</h2><p>useEffectの戻り値は <code>undefined</code> もしくはクリーンアップ関数と決められており、戻り値を処理しないため型は必要ありません。  <br><br>ただし関数や値を返してしまうとエラーになるので、アロー関数の書き方に注意が必要です。<br><br>以下の書き方では、アロー関数式<code>=&gt;</code>の本体に波括弧<code>{}</code>なしに1行で書いた文が戻り値になってしまいます。   <br></p><pre><code class=\"hljs\">useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span>&nbsp;\n&nbsp;<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span>&nbsp;\n&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> 処理\n&nbsp;, <span class=\"hljs-number\">1000</span>);\n, []);</code></pre><p><br>以下のように、本体を <code>{}</code> で囲むようにしてください。  <br></p><pre><code class=\"hljs\">useEffect(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n&nbsp;<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> 処理\n&nbsp;}, <span class=\"hljs-number\">1000</span>);\n}, []);</code></pre><p><br></p><h2 id=\"h7cf02dc148\"> イベントオブジェクトの型</h2><p>onClickやonChangeといったイベントハンドラで扱うイベントにも型があります。<br><br>イベントオブジェクトの型を知りたいときは、VSCodeがヒントをくれます。<br><br>例えばonClickなら、以下の状態でonClickの上にマウスをホバーさせると型情報を表示してくれます。<br></p><pre><code class=\"hljs\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre><p><br>以下のように要素のイベント属性に直接イベントハンドラを書く場合は、引数のイベントの型は推論されるので注釈が要りません。<br></p><pre><code class=\"hljs\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{(event)</span> =&gt;</span> //処理 }&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre><p><br>イベントハンドラの関数を別途定義する場合は、通常の関数と同様に型付けが必要になります。<br></p><h3 id=\"h745a3f474e\"> onClickイベント</h3><p>引数のイベントと戻り値に型付けをします。（戻り値は推論させてもOKです）<br></p><pre><code class=\"hljs\"><span class=\"hljs-comment\">// Buttonクリックの場合</span>\n<span class=\"hljs-keyword\">const</span> onClickButton = ( <span class=\"hljs-keyword\">event</span>: React.MouseEvent&lt;HTMLButtonElement, MouseEvent&gt; ):<span class=\"hljs-keyword\">void</span> =&gt; {\n&nbsp;<span class=\"hljs-comment\">// 処理</span>\n}</code></pre><p><br></p><h3 id=\"hc860cddeda\"> onChangeイベント</h3><pre><code class=\"hljs\"><span class=\"hljs-comment\">// Inputの場合</span>\n<span class=\"hljs-keyword\">const</span> onChangeInput = ( <span class=\"hljs-keyword\">event</span>: React.ChangeEvent&lt;HTMLInputElement&gt;):<span class=\"hljs-keyword\">void</span> =&gt; {\n&nbsp;<span class=\"hljs-comment\">// 処理</span>\n}</code></pre><p><br></p><h3 id=\"h0591b223f6\"> 複数種類の要素にイベントを適用する</h3><p>上記の例を見ると、ジェネリック型の部分に <code>HTMLButtonElement</code> <code>HTMLInputElement</code> とあるように特定のHTML要素のための型であることがわかります。   <br><br>もしDivタグ・Buttonタグ・Inputタグなどに同じイベントハンドラ関数を指定したい場合、通常は <code>HTMLButtonElement | HTMLInputElement | 続く...</code> と使いたい要素分の型を記述する必要があります。  <br><br>そんな時は、色んなHTML要素に共通して使える <code>HTMLElement</code> 型を使うこともできます。  <br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-type\">Props</span> = {\n&nbsp;onClick: (event: <span class=\"hljs-type\">React</span>.<span class=\"hljs-type\">MouseEvent</span>&lt;<span class=\"hljs-type\">HTMLElement</span>, <span class=\"hljs-type\">MouseEvent</span>&gt;) =&gt; void\n}</code></pre><p><br>以下の記事に詳しくまとめられており、非常に分かりやすかったです。<br><br>個人的には、精度を高めるためには面倒でも使う要素分だけ指定する方が良いのかな…？とも思いますが、 <code>HTMLButtonElem ent</code>  も<code> HTMLInputElement</code> も<code>HTMLElement</code> 型を継承しているんだと知り、勉強になりました。<br><a href=\"https://qiita.com/Takepepe/items/f1ba99a7ca7e66290f24\" target=\"_blank\" rel=\"noopener noreferrer\">any型で諦めない React.EventCallback - Qiita</a> <br></p><h2 id=\"hadc4cddfcc\"> 【番外編】Axios</h2><p>Axiosを使って非同期通信を行う際に返されるレスポンスやエラーにも型があります。<br></p><pre><code class=\"hljs\"><span class=\"hljs-keyword\">import</span> { AxiosError, AxiosResponse } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'axios'</span>\n\naxios\n&nbsp;.get(<span class=\"hljs-string\">'/url'</span>)\n&nbsp;.<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(response: AxiosResponse)</span> =&gt;</span> {\n&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> 成功時の処理\n&nbsp;})\n&nbsp;.<span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(error: AxiosError)</span> =&gt;</span> {\n&nbsp;&nbsp;<span class=\"hljs-regexp\">//</span> エラー時の処理\n&nbsp;})</code></pre><p><br></p><h2 id=\"h691cb018bd\"> おわりに</h2><p>正直はじめは、何か書くたびにエラーが出るしコード量が増えて余計にわけわからんと思いました。<br><br>でも慣れてくると、型が明示してあると処理の流れを追わなくてもどういう値が入って来るのかパッと見でも分かりやすいし、エディタの補完が効くのは便利で間違いがあれば気付けてTypeScript良いなと思うようになりました。<br><br>今後もより実用的でスマートな型の活用法を学んでいきたいと思います。<br></p><h2 id=\"h3937880ed1\"> 参考記事</h2><p><a href=\"https://github.com/typescript-cheatsheets/react\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/typescript-cheatsheets/react</a><br><br><a href=\"https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com/sangotaro/items/3ea63110517a1b66745b#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB</a><br><br><a href=\"https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF\" target=\"_blank\" rel=\"noopener noreferrer\">https://qiita.com/FumioNonaka/items/4361d1cdf34ffb5a5338#%E3%83%95%E3%83%83%E3%82%AF</a><br><br><br><br><br></p></body></html>"},"__N_SSG":true}